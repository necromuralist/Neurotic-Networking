<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="Studies in Deep Learning." name="description">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Neurotic Networking (old posts, page 21) | Neurotic Networking</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="rss.xml" hreflang="en" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/Neurotic-Networking/index-21.html" rel="canonical">
<link href="index-22.html" rel="prev" type="text/html">
<link href="index-20.html" rel="next" type="text/html"><!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
<link href="apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="site.webmanifest" rel="manifest">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="."><span id="blog-title">Neurotic Networking</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="rss.xml">RSS feed</a></li>
<li class="nav-item dropdown"><a aria-expanded="false" aria-haspopup="true" class="nav-link dropdown-toggle" data-toggle="dropdown" href="#">Monkey Pages</a>
<div class="dropdown-menu"><a class="dropdown-item" href="https://necromuralist.github.io/">The Cloistered Monkey</a> <a class="dropdown-item" href="https://necromuralist.github.io/Ape-Iron/">Ape Iron</a> <a class="dropdown-item" href="https://necromuralist.github.io/Bowling-For-Data/">Bowling For Data</a> <a class="dropdown-item" href="https://necromuralist.github.io/Beach-Pig-Thigh/">Beach-Pig Rump & Thigh</a> <a class="dropdown-item" href="https://necromuralist.github.io/Visions-Voices-Data/">Visions, Voices, Data</a></div>
</li>
</ul>
<!-- Google custom search -->
<form action="https://www.google.com/search" class="navbar-form navbar-right" method="get" role="search">
<div class="form-group"><input class="form-control" name="q" placeholder="Search" type="text"></div>
<!-- 
<button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
</button>
-->
<input name="sitesearch" type="hidden" value="https://necromuralist.github.io/Neurotic-Networking/"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<div class="postindex">
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/gans/wasserstein-gan-with-gradient-penalty/index.html">Wasserstein GAN With Gradient Penalty</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/gans/wasserstein-gan-with-gradient-penalty/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-04-21T13:24:27-07:00" itemprop="datePublished" title="2021-04-21 13:24">2021-04-21 13:24</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div class="outline-2" id="outline-container-orga42853d">
<h2 id="orga42853d">A Wasserstein GAN with Gradient Penalty (WGAN-GP)</h2>
<div class="outline-text-2" id="text-orga42853d">
<p>We're going to build a Wasserstein GAN with Gradient Penalty (WGAN-GP) that solves some of the stability issues with GANs. Specifically, we'll use a special kind of loss function known as the W-loss, where W stands for Wasserstein, and gradient penalties to prevent mode collapse (see <a href="https://www.wikiwand.com/en/Wasserstein_metric">Wasserstein Metric</a>).</p>
<p>Wasserstein is named after a mathematician at Penn State, <a href="https://www.wikiwand.com/en/Leonid_Vaserstein">Leonid Vaseršteĭn</a>.</p>
</div>
<div class="outline-3" id="outline-container-orgb0cb228">
<h3 id="orgb0cb228">Imports</h3>
<div class="outline-text-3" id="text-orgb0cb228">
<div class="highlight">
<pre><span></span><span class="c1"># python</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># from pypi</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>
<span class="kn">from</span> <span class="nn">torchvision.datasets</span> <span class="kn">import</span> <span class="n">MNIST</span>
<span class="kn">from</span> <span class="nn">torchvision.utils</span> <span class="kn">import</span> <span class="n">make_grid</span>

<span class="kn">import</span> <span class="nn">holoviews</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># my stuff</span>
<span class="kn">from</span> <span class="nn">graeae</span> <span class="kn">import</span> <span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">Timer</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org89335d4">
<h3 id="org89335d4">Set Up</h3>
<div class="outline-text-3" id="text-org89335d4"></div>
<div class="outline-4" id="outline-container-orgbbfbb7a">
<h4 id="orgbbfbb7a">The Random Seed</h4>
<div class="outline-text-4" id="text-orgbbfbb7a">
<div class="highlight">
<pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org8bda920">
<h4 id="org8bda920">Plotting and the Timer</h4>
<div class="outline-text-4" id="text-org8bda920">
<div class="highlight">
<pre><span></span><span class="n">TIMER</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
<span class="n">SLUG</span> <span class="o">=</span> <span class="s2">"wasserstein-gan-with-gradient-penalty"</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org7ac1eec">
<h3 id="org7ac1eec">Helper Functions</h3>
<div class="outline-text-3" id="text-org7ac1eec">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">save_tensor_images</span><span class="p">(</span><span class="n">image_tensor</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                       <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                       <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="sa">f</span><span class="s2">"files/posts/gans</span><span class="si">{</span><span class="n">SLUG</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
                       <span class="n">num_images</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">"""Plot an Image Tensor</span>

<span class="sd">    Args:</span>
<span class="sd">     image_tensor: tensor with the values for the image to plot</span>
<span class="sd">     filename: name to save the file under</span>
<span class="sd">     folder: path to put the file in</span>
<span class="sd">     title: title for the image</span>
<span class="sd">     num_images: how many images from the tensor to use</span>
<span class="sd">     size: the dimensions for each image</span>
<span class="sd">    """</span>
    <span class="n">image_tensor</span> <span class="o">=</span> <span class="p">(</span><span class="n">image_tensor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">image_unflat</span> <span class="o">=</span> <span class="n">image_tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">image_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">image_unflat</span><span class="p">[:</span><span class="n">num_images</span><span class="p">],</span> <span class="n">nrow</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image_grid</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="n">filename</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[[file:</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">]]"</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">holoviews_image</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">holoviews</span><span class="o">.</span><span class="n">Image</span><span class="p">:</span>
    <span class="n">image_tensor</span> <span class="o">=</span> <span class="p">(</span><span class="n">image_tensor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">image_unflat</span> <span class="o">=</span> <span class="n">image_tensor</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">image_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">image_unflat</span><span class="p">[:</span><span class="n">num_images</span><span class="p">],</span> <span class="n">nrow</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">holoview</span><span class="o">.</span><span class="n">Image</span><span class="p">(</span><span class="n">image_grid</span><span class="p">)</span>
</pre></div>
</div>
<div class="outline-4" id="outline-container-org7ed835c">
<h4 id="org7ed835c">Gradient Hook</h4>
<div class="outline-text-4" id="text-org7ed835c">
<p>This helps to keep track of the gradient for plotting</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">make_grad_hook</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Function to keep track of gradients for visualization purposes, </span>
<span class="sd">    which fills the grads list when using model.apply(grad_hook).</span>
<span class="sd">    """</span>
    <span class="n">grads</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">grad_hook</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">):</span>
            <span class="n">grads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">grad</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grads</span><span class="p">,</span> <span class="n">grad_hook</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org66ea658">
<h4 id="org66ea658">Noise</h4>
<div class="outline-text-4" id="text-org66ea658">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">make_noise</span><span class="p">(</span><span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">'cpu'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Alias for torch.randn</span>

<span class="sd">    Args:</span>
<span class="sd">      n_samples: the number of samples to generate</span>
<span class="sd">      z_dim: the dimension of the noise vector</span>
<span class="sd">      device: the device type</span>

<span class="sd">    Returns:</span>
<span class="sd">     tensor with random numbers from the normal distribution.</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org61a804f">
<h2 id="org61a804f">Middle</h2>
<div class="outline-text-2" id="text-org61a804f"></div>
<div class="outline-3" id="outline-container-org4983c31">
<h3 id="org4983c31">The Generator</h3>
<div class="outline-text-3" id="text-org4983c31">
<p>This is the Deep Convolutional GAN from before.</p>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Generator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""The DCGAN Generator</span>

<span class="sd">    Args:</span>
<span class="sd">       input_dim: the dimension of the input vector</span>
<span class="sd">       im_chan: the number of channels in the images, fitted for the dataset used</span>
<span class="sd">             (MNIST is black-and-white, so 1 channel is your default)</span>
<span class="sd">       hidden_dim: the inner dimension,</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">im_chan</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dim</span> <span class="o">=</span> <span class="n">input_dim</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">im_chan</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">final_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_gen_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">final_layer</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Creates a block for the generator (sub sequence)</span>

<span class="sd">       The parts</span>
<span class="sd">        - a transposed convolution</span>
<span class="sd">        - a batchnorm (except for in the last layer)</span>
<span class="sd">        - an activation.</span>

<span class="sd">       Args:</span>
<span class="sd">           input_channels: how many channels the input feature representation has</span>
<span class="sd">           output_channels: how many channels the output feature representation should have</span>
<span class="sd">           kernel_size: the size of each convolutional filter, equivalent to (kernel_size, kernel_size)</span>
<span class="sd">           stride: the stride of the convolution</span>
<span class="sd">           final_layer: a boolean, true if it is the final layer and false otherwise </span>
<span class="sd">                     (affects activation and batchnorm)</span>

<span class="sd">       Returns:</span>
<span class="sd">        the sub-sequence of layers</span>
<span class="sd">       """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">final_layer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">output_channels</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">Tanh</span><span class="p">(),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""complete a forward pass of the generator: Given a noise tensor, </span>

<span class="sd">       Args:</span>
<span class="sd">        noise: a noise tensor with dimensions (n_samples, z_dim)</span>

<span class="sd">       Returns:</span>
<span class="sd">        generated images.</span>
<span class="sd">       """</span>
        <span class="c1"># unsqueeze the noise</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">noise</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org6803d68">
<h3 id="org6803d68">The Critic</h3>
<div class="outline-text-3" id="text-org6803d68">
<p>This is also essentially the same as our Discriminator class from before.</p>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Critic</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Critic Class</span>

<span class="sd">    Args:</span>
<span class="sd">       im_chan: the number of channels in the images, fitted for the dataset used</span>
<span class="sd">             (MNIST is black-and-white, so 1 channel is your default)</span>
<span class="sd">       hidden_dim: the inner dimension</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_chan</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crit</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_crit_block</span><span class="p">(</span><span class="n">im_chan</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_crit_block</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_crit_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">final_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_crit_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                        <span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">final_layer</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Creates a sub-block for the network</span>

<span class="sd">        - a convolution</span>
<span class="sd">        - a batchnorm (except in the final layer)</span>
<span class="sd">        - an activation (except in the final layer).</span>

<span class="sd">       Args:</span>
<span class="sd">           input_channels: how many channels the input feature representation has</span>
<span class="sd">           output_channels: how many channels the output feature representation should have</span>
<span class="sd">           kernel_size: the size of each convolutional filter, equivalent to (kernel_size, kernel_size)</span>
<span class="sd">           stride: the stride of the convolution</span>
<span class="sd">           final_layer: a boolean, true if it is the final layer and false otherwise </span>
<span class="sd">                     (affects activation and batchnorm)</span>
<span class="sd">       """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">final_layer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span>
                          <span class="n">stride</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">output_channels</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span>
                          <span class="n">stride</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Run a forward pass of the critic</span>

<span class="sd">       Args:</span>
<span class="sd">           image: a flattened image tensor with dimension (im_chan)</span>

<span class="sd">       Returns:</span>
<span class="sd">        a 1-dimension tensor representing fake/real.</span>
<span class="sd">       """</span>
        <span class="n">crit_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crit</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">crit_pred</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">crit_pred</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org9eae22f">
<h3 id="org9eae22f">Training</h3>
<div class="outline-text-3" id="text-org9eae22f"></div>
<div class="outline-4" id="outline-container-org5b861fb">
<h4 id="org5b861fb">Hyperparameters</h4>
<div class="outline-text-4" id="text-org5b861fb">
<p>As usual, we'll start by setting the parameters:</p>
<ul class="org-ul">
<li>n<sub>epochs</sub>: the number of times you iterate through the entire dataset when training</li>
<li>z<sub>dim</sub>: the dimension of the noise vector</li>
<li>display<sub>step</sub>: how often to display/visualize the images</li>
<li>batch<sub>size</sub>: the number of images per forward/backward pass</li>
<li>lr: the learning rate</li>
<li>beta<sub>1</sub>, beta<sub>2</sub>: the momentum terms</li>
<li>c<sub>lambda</sub>: weight of the gradient penalty</li>
<li>crit<sub>repeats</sub>: number of times to update the critic per generator update - there are more details about this in the <b>Putting It All Together</b> section</li>
<li>device: the device type</li>
</ul>
<div class="highlight">
<pre><span></span><span class="n">n_epochs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">z_dim</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">display_step</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">lr</span> <span class="o">=</span> <span class="mf">0.0002</span>
<span class="n">beta_1</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">beta_2</span> <span class="o">=</span> <span class="mf">0.999</span>
<span class="n">c_lambda</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">crit_repeats</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">device</span> <span class="o">=</span> <span class="s1">'cuda'</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9db08b1">
<h4 id="org9db08b1">The Data</h4>
<div class="outline-text-4" id="text-org9db08b1">
<p>Once again we'll be using the MNIST dataset.</p>
<div class="highlight">
<pre><span></span><span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,)),</span>
<span class="p">])</span>

<span class="n">data_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">"~/pytorch-data/MNIST/"</span><span class="p">)</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>
<span class="n">dataloader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">MNIST</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">),</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6c55c81">
<h4 id="org6c55c81">Setup For Training</h4>
<div class="outline-text-4" id="text-org6c55c81">
<div class="highlight">
<pre><span></span><span class="n">gen</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="n">gen_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="p">(</span><span class="n">beta_1</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">))</span>
<span class="n">crit</span> <span class="o">=</span> <span class="n">Critic</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
<span class="n">crit_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">crit</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="p">(</span><span class="n">beta_1</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">weights_init</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">):</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">):</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">constant_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">gen</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">weights_init</span><span class="p">)</span>
<span class="n">crit</span> <span class="o">=</span> <span class="n">crit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">weights_init</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orge4865c3">
<h4 id="orge4865c3">The Gradient</h4>
<div class="outline-text-4" id="text-orge4865c3">
<p>Calculating the gradient penalty can be broken into two functions: (1) compute the gradient with respect to the images and (2) compute the gradient penalty given the gradient.</p>
<p>You can start by getting the gradient. The gradient is computed by first creating a mixed image. This is done by weighing the fake and real image using epsilon and then adding them together. Once you have the intermediate image, you can get the critic's output on the image. Finally, you compute the gradient of the critic score's on the mixed images (output) with respect to the pixels of the mixed images (input).</p>
<ul class="org-ul">
<li>See <a href="https://pytorch.org/docs/stable/autograd.html#torch.autograd.grad">pytorch's autograd documentation</a></li>
</ul>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_gradient</span><span class="p">(</span><span class="n">crit</span><span class="p">:</span> <span class="n">Critic</span><span class="p">,</span> <span class="n">real</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">fake</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                 <span class="n">epsilon</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Gradient of the critic's scores with respect to mixes of real and fake images.</span>

<span class="sd">    Args:</span>
<span class="sd">       crit: the critic model</span>
<span class="sd">       real: a batch of real images</span>
<span class="sd">       fake: a batch of fake images</span>
<span class="sd">       epsilon: a vector of the uniformly random proportions of real/fake per mixed image</span>

<span class="sd">    Returns:</span>
<span class="sd">       gradient: the gradient of the critic's scores, with respect to the mixed image</span>
<span class="sd">    """</span>
    <span class="c1"># Mix the images together</span>
    <span class="n">mixed_images</span> <span class="o">=</span> <span class="n">real</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">+</span> <span class="n">fake</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="c1"># Calculate the critic's scores on the mixed images</span>
    <span class="n">mixed_scores</span> <span class="o">=</span> <span class="n">crit</span><span class="p">(</span><span class="n">mixed_images</span><span class="p">)</span>

    <span class="c1"># Take the gradient of the scores with respect to the images</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
        <span class="c1"># Note: You need to take the gradient of outputs with respect to inputs.</span>
        <span class="c1">#### START CODE HERE ####</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="n">mixed_images</span><span class="p">,</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">mixed_scores</span><span class="p">,</span>
        <span class="c1">#### END CODE HERE ####</span>
        <span class="c1"># These other parameters have to do with how the pytorch autograd engine works</span>
        <span class="n">grad_outputs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">mixed_scores</span><span class="p">),</span> 
        <span class="n">create_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">gradient</span>
</pre></div>
</div>
<ul class="org-ul">
<li><a id="orgcbbf7dc"></a>Unit Tests<br>
<div class="outline-text-5" id="text-orgcbbf7dc">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_get_gradient</span><span class="p">(</span><span class="n">image_shape</span><span class="p">):</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">image_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">image_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">epsilon_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">image_shape</span><span class="p">]</span>
    <span class="n">epsilon_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">epsilon_shape</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="n">get_gradient</span><span class="p">(</span><span class="n">crit</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">fake</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gradient</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="n">image_shape</span>
    <span class="k">assert</span> <span class="n">gradient</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">gradient</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">gradient</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">gradient</span> <span class="o">=</span> <span class="n">test_get_gradient</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="outline-4" id="outline-container-org3043d78">
<h4 id="org3043d78">The Gradient Penalty</h4>
<div class="outline-text-4" id="text-org3043d78">
<p>The second function you need to complete is to compute the gradient penalty given the gradient. First, you calculate the magnitude of each image's gradient. The magnitude of a gradient is also called the norm. Then, you calculate the penalty by squaring the distance between each magnitude and the ideal norm of 1 and taking the mean of all the squared distances.</p>
<ol class="org-ol">
<li>Make sure you take the mean at the end.</li>
<li>Note that the magnitude of each gradient has already been calculated for you.</li>
</ol>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">gradient_penalty</span><span class="p">(</span><span class="n">gradient</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Calculate the size of each image's gradient</span>
<span class="sd">    and penalize the mean quadratic distance of each magnitude to 1.</span>

<span class="sd">    Args:</span>
<span class="sd">       gradient: the gradient of the critic's scores, with respect to the mixed image</span>

<span class="sd">    Returns:</span>
<span class="sd">       penalty: the gradient penalty</span>
<span class="sd">    """</span>
    <span class="c1"># Flatten the gradients so that each row captures one image</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gradient</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Calculate the magnitude of every row</span>
    <span class="n">gradient_norm</span> <span class="o">=</span> <span class="n">gradient</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Penalize the mean squared distance of the gradient norms from 1</span>
    <span class="n">penalty</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">gradient_norm</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">penalty</span>
</pre></div>
</div>
<ul class="org-ul">
<li><a id="orga880f8b"></a>Unit Testing<br>
<div class="outline-text-5" id="text-orga880f8b">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_gradient_penalty</span><span class="p">(</span><span class="n">image_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="n">bad_gradient</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="o">*</span><span class="n">image_shape</span><span class="p">)</span>
    <span class="n">bad_gradient_penalty</span> <span class="o">=</span> <span class="n">gradient_penalty</span><span class="p">(</span><span class="n">bad_gradient</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">bad_gradient_penalty</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">1.</span><span class="p">))</span>

    <span class="n">image_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">(</span><span class="n">image_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">good_gradient</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="o">*</span><span class="n">image_shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">image_size</span><span class="p">)</span>
    <span class="n">good_gradient_penalty</span> <span class="o">=</span> <span class="n">gradient_penalty</span><span class="p">(</span><span class="n">good_gradient</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">good_gradient_penalty</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">0.</span><span class="p">))</span>

    <span class="n">random_gradient</span> <span class="o">=</span> <span class="n">test_get_gradient</span><span class="p">(</span><span class="n">image_shape</span><span class="p">)</span>
    <span class="n">random_gradient_penalty</span> <span class="o">=</span> <span class="n">gradient_penalty</span><span class="p">(</span><span class="n">random_gradient</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">random_gradient_penalty</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_gradient_penalty</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="outline-4" id="outline-container-orgec472b5">
<h4 id="orgec472b5">Losses</h4>
<div class="outline-text-4" id="text-orgec472b5">
<p>Next, you need to calculate the loss for the generator and the critic.</p>
</div>
<ul class="org-ul">
<li><a id="org049327f"></a>Generator Loss<br>
<div class="outline-text-5" id="text-org049327f">
<p>For the generator, the loss is calculated by maximizing the critic's prediction on the generator's fake images. The argument has the scores for all fake images in the batch, but you will use the mean of them.</p>
<ol class="org-ol">
<li>This can be written in one line.</li>
<li>This is the negative of the mean of the critic's scores.</li>
</ol>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_gen_loss</span><span class="p">(</span><span class="n">crit_fake_pred</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""loss of generator given critic's scores of generator's fake images.</span>

<span class="sd">    Args:</span>
<span class="sd">       crit_fake_pred: the critic's scores of the fake images</span>

<span class="sd">    Returns:</span>
<span class="sd">       gen_loss: a scalar loss value for the current batch of the generator</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">crit_fake_pred</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
    <span class="n">get_gen_loss</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">1.</span><span class="p">)),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
    <span class="n">get_gen_loss</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10000</span><span class="p">)),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="mf">0.05</span>
<span class="p">)</span>
</pre></div>
</div>
</li>
<li><a id="org4c70701"></a>The Critic Loss<br>
<div class="outline-text-5" id="text-org4c70701">
<p>For the critic, the loss is calculated by maximizing the distance between the critic's predictions on the real images and the predictions on the fake images while also adding a gradient penalty. The gradient penalty is weighed according to lambda. The arguments are the scores for all the images in the batch, and you will use the mean of them.</p>
<ol class="org-ol">
<li>The higher the mean fake score, the higher the critic's loss is.</li>
<li>What does this suggest about the mean real score?</li>
<li>The higher the gradient penalty, the higher the critic's loss is, proportional to lambda.</li>
</ol>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_crit_loss</span><span class="p">(</span><span class="n">crit_fake_pred</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">crit_real_pred</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                  <span class="n">gp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">c_lambda</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""loss of a critic given critic's scores for fake and real images,</span>
<span class="sd">    the gradient penalty, and gradient penalty weight.</span>

<span class="sd">    Args:</span>
<span class="sd">       crit_fake_pred: the critic's scores of the fake images</span>
<span class="sd">       crit_real_pred: the critic's scores of the real images</span>
<span class="sd">       gp: the unweighted gradient penalty</span>
<span class="sd">       c_lambda: the current weight of the gradient penalty </span>

<span class="sd">    Returns:</span>
<span class="sd">       crit_loss: a scalar for the critic's loss, accounting for the relevant factors</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">crit_fake_pred</span> <span class="o">-</span> <span class="n">crit_real_pred</span>  <span class="o">+</span> <span class="n">gp</span> <span class="o">*</span> <span class="n">c_lambda</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
    <span class="n">get_crit_loss</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">2.</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">3.</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">),</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">-</span><span class="mf">0.7</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
    <span class="n">get_crit_loss</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">20.</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">-</span><span class="mf">20.</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">2.</span><span class="p">),</span> <span class="mi">10</span><span class="p">),</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="outline-4" id="outline-container-org2c2d74d">
<h4 id="org2c2d74d">Running the Training</h4>
<div class="outline-text-4" id="text-org2c2d74d">
<p>Before you put everything together, there are a few things to note.</p>
<ol class="org-ol">
<li>Even on GPU, the <b>training will run more slowly</b> than previous labs because the gradient penalty requires you to compute the gradient of a gradient – this means potentially a few minutes per epoch! For best results, run this for as long as you can while on GPU.</li>
<li>One important difference from earlier versions is that you will <b>update the critic multiple times</b> every time you update the generator This helps prevent the generator from overpowering the critic. Sometimes, you might see the reverse, with the generator updated more times than the critic. This depends on architectural (e.g. the depth and width of the network) and algorithmic choices (e.g. which loss you're using).</li>
<li>WGAN-GP isn't necessarily meant to improve overall performance of a GAN, but just <b>increases stability</b> and avoids mode collapse. In general, a WGAN will be able to train in a much more stable way than the vanilla DCGAN from last assignment, though it will generally run a bit slower. You should also be able to train your model for more epochs without it collapsing.</li>
</ol>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">update_critic</span><span class="p">(</span><span class="n">critic</span><span class="p">,</span> <span class="n">critic_optimizer</span><span class="p">,</span> <span class="n">generator</span><span class="p">,</span> <span class="n">generator_optimizer</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">real</span><span class="p">):</span>
    <span class="n">critic_optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
    <span class="n">fake_noise</span> <span class="o">=</span> <span class="n">make_noise</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">generator</span><span class="p">(</span><span class="n">fake_noise</span><span class="p">)</span>
    <span class="n">crit_fake_pred</span> <span class="o">=</span> <span class="n">critic</span><span class="p">(</span><span class="n">fake</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>
    <span class="n">crit_real_pred</span> <span class="o">=</span> <span class="n">critic</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>

    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">gradient</span> <span class="o">=</span> <span class="n">get_gradient</span><span class="p">(</span><span class="n">critic</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">fake</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">gradient_penalty</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span>
    <span class="n">crit_loss</span> <span class="o">=</span> <span class="n">get_crit_loss</span><span class="p">(</span><span class="n">crit_fake_pred</span><span class="p">,</span> <span class="n">crit_real_pred</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">c_lambda</span><span class="p">)</span>

    <span class="c1"># Keep track of the average critic loss in this batch</span>
    <span class="n">mean_iteration_critic_loss</span> <span class="o">=</span> <span class="n">crit_loss</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">crit_repeats</span>
    <span class="c1"># Update gradients</span>
    <span class="n">crit_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="c1"># Update optimizer</span>
    <span class="n">crit_opt</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mean_iteration_critic_loss</span><span class="p">,</span> <span class="n">fake</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">update_generator</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">generator_optimizer</span><span class="p">,</span> <span class="n">critic</span><span class="p">,</span> <span class="n">critic_optimizer</span><span class="p">,</span>
                     <span class="n">batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">):</span>
        <span class="n">generator_optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="n">fake_noise_2</span> <span class="o">=</span> <span class="n">make_noise</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">fake_2</span> <span class="o">=</span> <span class="n">generator</span><span class="p">(</span><span class="n">fake_noise_2</span><span class="p">)</span>
        <span class="n">crit_fake_pred</span> <span class="o">=</span> <span class="n">critic</span><span class="p">(</span><span class="n">fake_2</span><span class="p">)</span>

        <span class="n">gen_loss</span> <span class="o">=</span> <span class="n">get_gen_loss</span><span class="p">(</span><span class="n">crit_fake_pred</span><span class="p">)</span>
        <span class="n">gen_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># Update the weights</span>
        <span class="n">generator_optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">gen_loss</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">cur_step</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">generator_losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">critic_losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">fakes</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">with</span> <span class="n">TIMER</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">):</span>
        <span class="c1"># Dataloader returns the batches</span>
        <span class="k">for</span> <span class="n">real</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
            <span class="n">cur_batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
            <span class="n">real</span> <span class="o">=</span> <span class="n">real</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

            <span class="n">mean_iteration_critic_loss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">crit_repeats</span><span class="p">):</span>
                <span class="c1">### Update critic ###</span>
                <span class="n">this_loss</span><span class="p">,</span> <span class="n">fake</span> <span class="o">=</span> <span class="n">update_critic</span><span class="p">(</span><span class="n">crit</span><span class="p">,</span> <span class="n">crit_opt</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">gen_opt</span><span class="p">,</span>
                                                <span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">real</span><span class="p">)</span>
                <span class="n">mean_iteration_critic_loss</span> <span class="o">+=</span> <span class="n">this_loss</span>
            <span class="n">critic_losses</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mean_iteration_critic_loss</span><span class="p">]</span>

            <span class="c1">### Update generator ###</span>
            <span class="c1"># Keep track of the average generator loss</span>
            <span class="n">generator_losses</span> <span class="o">+=</span> <span class="n">update_generator</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">gen_opt</span><span class="p">,</span> <span class="n">crit</span><span class="p">,</span> <span class="n">crit_opt</span><span class="p">,</span>
                                                 <span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>

            <span class="c1">### Visualization code ###</span>
            <span class="k">if</span> <span class="n">cur_step</span> <span class="o">%</span> <span class="n">display_step</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cur_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gen_mean</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">generator_losses</span><span class="p">[</span><span class="o">-</span><span class="n">display_step</span><span class="p">:])</span> <span class="o">/</span> <span class="n">display_step</span>
                <span class="n">crit_mean</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">critic_losses</span><span class="p">[</span><span class="o">-</span><span class="n">display_step</span><span class="p">:])</span> <span class="o">/</span> <span class="n">display_step</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Step </span><span class="si">{</span><span class="n">cur_step</span><span class="si">}</span><span class="s2">: Generator loss: </span><span class="si">{</span><span class="n">gen_mean</span><span class="si">}</span><span class="s2">, critic loss: </span><span class="si">{</span><span class="n">crit_mean</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                <span class="n">fakes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fake</span><span class="p">)</span>
                <span class="c1">#show_tensor_images(fake)</span>
                <span class="c1"># show_tensor_images(real)</span>
                <span class="c1"># step_bins = 20</span>
                <span class="c1">#num_examples = (len(generator_losses) // step_bins) * step_bins</span>
                <span class="c1">#plt.plot(</span>
                <span class="c1">#    range(num_examples // step_bins), </span>
                <span class="c1">#    torch.Tensor(generator_losses[:num_examples]).view(-1, step_bins).mean(1),</span>
                <span class="c1">#    label="Generator Loss"</span>
                <span class="c1">#)</span>
                <span class="c1">#plt.plot(</span>
                <span class="c1">#    range(num_examples // step_bins), </span>
                <span class="c1">#    torch.Tensor(critic_losses[:num_examples]).view(-1, step_bins).mean(1),</span>
                <span class="c1">#    label="Critic Loss"</span>
                <span class="c1">#)</span>
                <span class="c1">#plt.legend()</span>
                <span class="c1">#plt.show()</span>

            <span class="n">cur_step</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
<pre class="example" id="orgb5f0907">
Started: 2021-04-23 16:44:37.086571
Step 50: Generator loss: 1.2940945455431938, critic loss: -2.5389487731456755
Step 100: Generator loss: 1.8233803486824036, critic loss: -10.170887191772463
Step 150: Generator loss: -0.8236922709643841, critic loss: -25.889275665283208
Step 200: Generator loss: -1.9489177632331849, critic loss: -57.93669644165039
Step 250: Generator loss: -1.6910316547751427, critic loss: -98.02721130371094
Step 300: Generator loss: -1.057899413406849, critic loss: -148.77607403564457
Step 350: Generator loss: -1.0930944073200226, critic loss: -199.94886077880858
Step 400: Generator loss: 1.900166620016098, critic loss: -245.53067184448247
Step 450: Generator loss: -18.928784263134002, critic loss: -251.46439450645448
Step 500: Generator loss: -7.688082475662231, critic loss: -289.45334830856325
Step 550: Generator loss: 12.447209596633911, critic loss: -395.351733947754
Step 600: Generator loss: 4.604712443947792, critic loss: -442.96986193847647
Step 650: Generator loss: 2.1788939160108565, critic loss: -480.044010131836
Step 700: Generator loss: 2.979072951376438, critic loss: -519.4769331054689
Step 750: Generator loss: -49.77768729448319, critic loss: -406.99980457305907
Step 800: Generator loss: 0.28986886143684387, critic loss: -444.8244698066711
Step 850: Generator loss: 31.1217813873291, critic loss: -608.1500103759765
Step 900: Generator loss: 12.006675623655319, critic loss: -632.0770750808719
Step 950: Generator loss: -0.15041383981704712, critic loss: -659.3277660064699
Step 1000: Generator loss: 15.936325817108154, critic loss: -629.952421447754
Step 1050: Generator loss: -43.25309041261673, critic loss: -504.54743419075004
Step 1100: Generator loss: -127.80617136001587, critic loss: -347.7993973159789
Step 1150: Generator loss: 4.186352119445801, critic loss: -461.6966292152405
Step 1200: Generator loss: 19.471285017728807, critic loss: -417.6742295103073
Step 1250: Generator loss: 34.04052387237549, critic loss: -327.74495936584475
Step 1300: Generator loss: -61.267093954086306, critic loss: -114.96264076042176
Step 1350: Generator loss: -56.96540081501007, critic loss: -257.8397505912781
Step 1400: Generator loss: -58.51407446861267, critic loss: -284.2404485015868
Step 1450: Generator loss: -31.23556293010712, critic loss: -282.15282668590544
Step 1500: Generator loss: 21.97936663866043, critic loss: -201.8184239835738
Step 1550: Generator loss: -35.051265001297, critic loss: -268.2542330398559
Step 1600: Generator loss: -13.768656857013703, critic loss: -201.92625104904172
Step 1650: Generator loss: 22.134875717163087, critic loss: -222.15251140356065
Step 1700: Generator loss: -33.80421092987061, critic loss: -196.00927429389947
Step 1750: Generator loss: -57.25435597419739, critic loss: -182.85244289588928
Step 1800: Generator loss: -41.60410815238953, critic loss: -213.254286611557
Step 1850: Generator loss: -4.978743267059326, critic loss: -101.88668561553959
Step 1900: Generator loss: 43.375376815795896, critic loss: 24.468120357513428
Step 1950: Generator loss: 37.55927352905273, critic loss: 19.142875072479246
Step 2000: Generator loss: 30.793880767822266, critic loss: 27.632160606384268
Step 2050: Generator loss: 28.9916410446167, critic loss: 37.41749234771728
Step 2100: Generator loss: 28.57459102630615, critic loss: 36.46667390441895
Step 2150: Generator loss: 27.179994583129883, critic loss: 37.36057964324953
Step 2200: Generator loss: 26.722407608032228, critic loss: 36.42123816680908
Step 2250: Generator loss: 26.215636711120606, critic loss: 35.10568865203857
Step 2300: Generator loss: 25.28977954864502, critic loss: 38.4949776916504
Step 2350: Generator loss: 25.161714172363283, critic loss: 30.91700393295288
Step 2400: Generator loss: 25.609521713256836, critic loss: 27.127794273376463
Step 2450: Generator loss: 26.457210426330565, critic loss: 23.25596778869629
Step 2500: Generator loss: 27.144473686218262, critic loss: 18.423582084655763
Step 2550: Generator loss: 28.104863624572754, critic loss: 16.720462280273438
Step 2600: Generator loss: 29.460466690063477, critic loss: 13.846090631484987
Step 2650: Generator loss: 31.16196632385254, critic loss: 10.717047594070436
Step 2700: Generator loss: 32.86851013183594, critic loss: 8.973742393493652
Step 2750: Generator loss: 33.90616256713867, critic loss: 9.844469717025756
Step 2800: Generator loss: 34.65669334411621, critic loss: 8.557393852233888
Step 2850: Generator loss: 35.84923110961914, critic loss: 6.227309632301333
Step 2900: Generator loss: 37.1290372467041, critic loss: 4.664727992773057
Step 2950: Generator loss: 39.00773422241211, critic loss: 3.6960949053764343
Step 3000: Generator loss: 41.04932693481445, critic loss: 3.064339481592179
Step 3050: Generator loss: 43.54303398132324, critic loss: 1.5976664029359815
Step 3100: Generator loss: 46.25879165649414, critic loss: 0.43558707976341254
Step 3150: Generator loss: 48.358483200073245, critic loss: -0.8735819962918758
Step 3200: Generator loss: 49.9193138885498, critic loss: -1.9399951877593993
Step 3250: Generator loss: 50.604149169921875, critic loss: -2.96596682035923
Step 3300: Generator loss: 51.37260269165039, critic loss: -4.266795755624772
Step 3350: Generator loss: 50.53414665222168, critic loss: -6.2572406907081595
Step 3400: Generator loss: 49.34995780944824, critic loss: -8.031075536847114
Step 3450: Generator loss: 46.14337966918945, critic loss: -8.019683789610863
Step 3500: Generator loss: 42.769298782348635, critic loss: -9.498445952415468
Step 3550: Generator loss: 37.38293798446655, critic loss: -9.02791331624985
Step 3600: Generator loss: 32.84453460693359, critic loss: -9.934100509524345
Step 3650: Generator loss: 29.88087886810303, critic loss: -9.069164658904075
Step 3700: Generator loss: 27.295934791564942, critic loss: -12.109804625511167
Step 3750: Generator loss: 23.694135398864745, critic loss: -14.327697192192076
Step 3800: Generator loss: 22.836445541381835, critic loss: -15.450897558450697
Step 3850: Generator loss: 21.66964967727661, critic loss: -18.371595690727236
Step 3900: Generator loss: 22.644691734313966, critic loss: -18.472765784740442
Step 3950: Generator loss: 23.275020160675048, critic loss: -14.622903740763663
Step 4000: Generator loss: 20.404177145957945, critic loss: -20.265531128883364
Step 4050: Generator loss: 20.57322360277176, critic loss: -22.811122689247135
Step 4100: Generator loss: 20.653975734710695, critic loss: -21.081045699119564
Step 4150: Generator loss: 22.07396845817566, critic loss: -25.1140656299591
Step 4200: Generator loss: 23.147041385173797, critic loss: -25.637423175573346
Step 4250: Generator loss: 24.7466512966156, critic loss: -27.446938713431358
Step 4300: Generator loss: 23.155011949539183, critic loss: -29.866371290445326
Step 4350: Generator loss: 28.670740413665772, critic loss: -27.526438851594932
Step 4400: Generator loss: 28.197952184677124, critic loss: -32.777981144189845
Step 4450: Generator loss: 30.352355518341064, critic loss: -27.1594803442955
Step 4500: Generator loss: 28.54464930534363, critic loss: -33.94081681919097
Step 4550: Generator loss: 30.315768175125122, critic loss: -32.86432695555688
Step 4600: Generator loss: 31.542511186599732, critic loss: -30.20407930350304
Step 4650: Generator loss: 32.1046596121788, critic loss: -25.409390352845193
Step 4700: Generator loss: 32.14258025169372, critic loss: -31.69375462341309
Step 4750: Generator loss: 34.99601099014282, critic loss: -17.207461384415634
Step 4800: Generator loss: 34.72456073760986, critic loss: -28.68983098757266
Step 4850: Generator loss: 43.15867195129395, critic loss: -3.741025509417056
Step 4900: Generator loss: 39.205870933532715, critic loss: -10.995340047717095
Step 4950: Generator loss: 33.214964599609374, critic loss: -22.35341439080238
Step 5000: Generator loss: 36.83505029678345, critic loss: -22.059852074146274
Step 5050: Generator loss: 44.310142288208006, critic loss: -9.833503689646719
Step 5100: Generator loss: 46.455570983886716, critic loss: -6.97827914196253
Step 5150: Generator loss: 50.3965446472168, critic loss: 2.86564082187414
Step 5200: Generator loss: 49.87795219421387, critic loss: -1.3452879690229889
Step 5250: Generator loss: 47.53674819946289, critic loss: -2.096805039405823
Step 5300: Generator loss: 46.8746314239502, critic loss: -3.2593628435134883
Step 5350: Generator loss: 45.44812057495117, critic loss: -8.15779336643219
Step 5400: Generator loss: 44.419895820617675, critic loss: -14.570247013330457
Step 5450: Generator loss: 46.02410781860352, critic loss: -15.177982830524446
Step 5500: Generator loss: 49.54875686645508, critic loss: -9.89209368979931
Step 5550: Generator loss: 48.06167510986328, critic loss: -14.110691767692567
Step 5600: Generator loss: 49.201857833862306, critic loss: -14.137419148623945
Step 5650: Generator loss: 50.152088012695316, critic loss: -12.306397112727165
Step 5700: Generator loss: 48.29638786315918, critic loss: -16.661144974470133
Step 5750: Generator loss: 48.57353067398071, critic loss: -14.890159791767603
Step 5800: Generator loss: 49.75064552307129, critic loss: -18.844482659339906
Step 5850: Generator loss: 60.04904914855957, critic loss: -6.717597324132919
Step 5900: Generator loss: 51.537723999023434, critic loss: -16.97626993632317
Step 5950: Generator loss: 53.64197952270508, critic loss: -17.934735801696778
Step 6000: Generator loss: 58.61811660766602, critic loss: -12.544874910593034
Step 6050: Generator loss: 57.9530167388916, critic loss: -12.869983579158779
Step 6100: Generator loss: 58.112417755126955, critic loss: -14.860800614833833
Step 6150: Generator loss: 59.45550857543945, critic loss: -16.21854728984833
Step 6200: Generator loss: 61.55990020751953, critic loss: -13.752459713578226
Step 6250: Generator loss: 63.91949012756348, critic loss: -15.32866345870495
Step 6300: Generator loss: 61.11529357910156, critic loss: -19.138810309529305
Step 6350: Generator loss: 68.78476165771484, critic loss: -3.858711770117282
Step 6400: Generator loss: 72.07508163452148, critic loss: -3.3317795319557204
Step 6450: Generator loss: 62.11038558959961, critic loss: -12.74781008577347
Step 6500: Generator loss: 66.10368064880372, critic loss: -13.66576182627678
Step 6550: Generator loss: 62.73857864379883, critic loss: -19.79733684468269
Step 6600: Generator loss: 64.86283889770507, critic loss: -15.91535943055153
Step 6650: Generator loss: 65.02771781921386, critic loss: -16.515603628635407
Step 6700: Generator loss: 73.10651649475098, critic loss: -7.974747009277344
Step 6750: Generator loss: 69.39200439453126, critic loss: -12.647881946563723
Step 6800: Generator loss: 70.61859390258789, critic loss: -14.981548887073998
Step 6850: Generator loss: 71.39209846496583, critic loss: -12.02037605035305
Step 6900: Generator loss: 68.91642692565918, critic loss: -17.377452049493794
Step 6950: Generator loss: 73.83714424133301, critic loss: -14.842290714025498
Step 7000: Generator loss: 76.0492682647705, critic loss: -4.022153543114662
Step 7050: Generator loss: 73.60314575195312, critic loss: -11.167652189731598
Step 7100: Generator loss: 73.69744178771973, critic loss: -16.215790304422377
Step 7150: Generator loss: 73.02161018371582, critic loss: -11.844917020320892
Step 7200: Generator loss: 84.43860961914062, critic loss: -4.338678442955016
Step 7250: Generator loss: 72.4216611480713, critic loss: -16.95018665671349
Step 7300: Generator loss: 75.08161041259766, critic loss: -13.94019952297211
Step 7350: Generator loss: 76.7044221496582, critic loss: -14.254385577440262
Step 7400: Generator loss: 81.03584564208984, critic loss: -3.171723330259324
Step 7450: Generator loss: 80.19454528808593, critic loss: -6.323260527610778
Step 7500: Generator loss: 74.55620361328126, critic loss: -8.62027923491597
Step 7550: Generator loss: 84.05591217041015, critic loss: -3.5706960783004775
Step 7600: Generator loss: 81.2258724975586, critic loss: -8.142396178722382
Step 7650: Generator loss: 73.19812255859375, critic loss: -16.196065732836722
Step 7700: Generator loss: 74.52944702148437, critic loss: -15.7419521817565
Step 7750: Generator loss: 80.32163719177247, critic loss: -7.413010147571564
Step 7800: Generator loss: 76.99493499755859, critic loss: -12.079633572757244
Step 7850: Generator loss: 81.32430145263672, critic loss: -2.8193510160446174
Step 7900: Generator loss: 80.63022003173828, critic loss: -3.1151746976375576
Step 7950: Generator loss: 75.89005561828613, critic loss: -8.688790566921234
Step 8000: Generator loss: 72.94720428466798, critic loss: -14.186805599212649
Step 8050: Generator loss: 80.84135955810547, critic loss: -11.586392744839191
Step 8100: Generator loss: 79.48079322814941, critic loss: -1.3788062819838527
Step 8150: Generator loss: 72.63796539306641, critic loss: -14.767250993669036
Step 8200: Generator loss: 76.29679145812989, critic loss: -16.04671211397648
Step 8250: Generator loss: 72.60974617004395, critic loss: -17.008654308915133
Step 8300: Generator loss: 75.25621772766114, critic loss: -12.109682399034496
Step 8350: Generator loss: 81.09654647827148, critic loss: -10.706179085254668
Step 8400: Generator loss: 77.28005485534668, critic loss: -4.09239830350876
Step 8450: Generator loss: 83.45014526367187, critic loss: -3.1862959499359125
Step 8500: Generator loss: 80.24715942382812, critic loss: -4.144565615177154
Step 8550: Generator loss: 76.43464157104492, critic loss: -9.53649512773752
Step 8600: Generator loss: 73.67140350341796, critic loss: -15.18680296653509
Step 8650: Generator loss: 75.6114599609375, critic loss: -10.128391755342484
Step 8700: Generator loss: 73.68272163391113, critic loss: -16.97586714470387
Step 8750: Generator loss: 83.1702619934082, critic loss: -0.6609140309095384
Step 8800: Generator loss: 80.41752578735351, critic loss: -4.212692310333251
Step 8850: Generator loss: 71.03237358093261, critic loss: -14.983835175275805
Step 8900: Generator loss: 75.80495880126954, critic loss: -12.667168443322183
Step 8950: Generator loss: 81.14228034973145, critic loss: 2.7472501730918872
Step 9000: Generator loss: 81.20193344116211, critic loss: -3.052738008499146
Step 9050: Generator loss: 73.43904174804688, critic loss: -7.423715700268742
Step 9100: Generator loss: 73.12181861877441, critic loss: -14.306883191585541
Step 9150: Generator loss: 76.89906158447266, critic loss: -13.396733086347583
Step 9200: Generator loss: 75.99712623596191, critic loss: -12.318668732821939
Step 9250: Generator loss: 77.78204513549805, critic loss: -6.621456883490087
Step 9300: Generator loss: 77.82661689758301, critic loss: -11.999425900220869
Step 9350: Generator loss: 81.48483535766601, critic loss: -11.480147421479224
Step 9400: Generator loss: 75.37383903503418, critic loss: -11.605070021390913
Step 9450: Generator loss: 83.24758972167969, critic loss: -1.770111013114451
Step 9500: Generator loss: 75.71745803833008, critic loss: -14.370290687352417
Step 9550: Generator loss: 80.75228134155273, critic loss: -12.244659341961144
Step 9600: Generator loss: 80.36522689819336, critic loss: -9.994889120757579
Step 9650: Generator loss: 79.76879989624024, critic loss: -12.11628355455398
Step 9700: Generator loss: 75.03965270996093, critic loss: -15.582087687492374
Step 9750: Generator loss: 78.26055725097656, critic loss: -9.227732668161394
Step 9800: Generator loss: 86.73946716308593, critic loss: -3.9114915781021113
Step 9850: Generator loss: 77.57634506225585, critic loss: -16.903033419966697
Step 9900: Generator loss: 79.62038360595703, critic loss: -13.387711975812913
Step 9950: Generator loss: 83.48049461364747, critic loss: 0.4212318459749224
Step 10000: Generator loss: 86.0385548400879, critic loss: -3.0202082567214954
Step 10050: Generator loss: 84.96556030273437, critic loss: -3.2984186277389527
Step 10100: Generator loss: 82.55163467407226, critic loss: -5.651416356563568
Step 10150: Generator loss: 72.47459297180175, critic loss: -16.2935069770813
Step 10200: Generator loss: 77.47050117492675, critic loss: -14.219993201971054
Step 10250: Generator loss: 82.40048095703125, critic loss: -9.951535837292676
Step 10300: Generator loss: 78.51686393737793, critic loss: -5.037457182884218
Step 10350: Generator loss: 79.00918548583985, critic loss: -10.983480290770531
Step 10400: Generator loss: 79.10479446411132, critic loss: -11.458023426651957
Step 10450: Generator loss: 79.01952590942383, critic loss: -13.550984252214432
Step 10500: Generator loss: 79.7324333190918, critic loss: -15.04755926167965
Step 10550: Generator loss: 83.25529792785645, critic loss: -10.678096773743627
Step 10600: Generator loss: 78.7729409790039, critic loss: -14.363517974853519
Step 10650: Generator loss: 83.80620101928712, critic loss: -12.4009742795825
Step 10700: Generator loss: 83.44554489135743, critic loss: -5.4632708239853365
Step 10750: Generator loss: 84.38950912475586, critic loss: -4.946207571595907
Step 10800: Generator loss: 84.90599151611327, critic loss: -10.688541789770127
Step 10850: Generator loss: 80.39469886779786, critic loss: -13.391746405303474
Step 10900: Generator loss: 79.68403381347656, critic loss: -14.792330410242082
Step 10950: Generator loss: 84.55435623168945, critic loss: -12.792006389081477
Step 11000: Generator loss: 85.3377848815918, critic loss: -1.002582928955554
Step 11050: Generator loss: 76.42176498413086, critic loss: -16.618346381425855
Step 11100: Generator loss: 82.8500619506836, critic loss: -10.213502784013746
Step 11150: Generator loss: 80.111083984375, critic loss: -16.506468793153765
Step 11200: Generator loss: 81.84511749267578, critic loss: -14.588824108004571
Step 11250: Generator loss: 82.36108421325683, critic loss: -14.826971750736238
Step 11300: Generator loss: 82.89525245666503, critic loss: -14.743118989944467
Step 11350: Generator loss: 78.9609211730957, critic loss: -6.072368972778322
Step 11400: Generator loss: 79.75704879760742, critic loss: -11.66915795624256
Step 11450: Generator loss: 92.73718231201173, critic loss: -8.626956017732619
Step 11500: Generator loss: 76.74110557556152, critic loss: -13.485125755786896
Step 11550: Generator loss: 86.92150177001953, critic loss: -11.96049699956179
Step 11600: Generator loss: 87.94025703430175, critic loss: -7.829241111636162
Step 11650: Generator loss: 78.58638778686523, critic loss: -13.818019400000573
Step 11700: Generator loss: 82.94163925170898, critic loss: -16.088717435359957
Step 11750: Generator loss: 82.20194442749023, critic loss: -13.443735618114472
Step 11800: Generator loss: 77.3590771484375, critic loss: -0.26538432469963885
Step 11850: Generator loss: 87.65712219238281, critic loss: -2.2925723257064816
Step 11900: Generator loss: 86.44266906738281, critic loss: -2.755362086296081
Step 11950: Generator loss: 85.7614064025879, critic loss: -2.9416364326477047
Step 12000: Generator loss: 84.22476821899414, critic loss: -3.100327790260315
Step 12050: Generator loss: 81.84705871582031, critic loss: -3.3889783926010137
Step 12100: Generator loss: 74.62463600158691, critic loss: -9.155223772525787
Step 12150: Generator loss: 83.41003746032715, critic loss: -7.312069640517238
Step 12200: Generator loss: 77.82574188232422, critic loss: -10.063361536026001
Step 12250: Generator loss: 77.09058532714843, critic loss: -15.389594004154203
Step 12300: Generator loss: 85.65135437011719, critic loss: -11.597671725511553
Step 12350: Generator loss: 79.91491325378418, critic loss: -0.8456090040206905
Step 12400: Generator loss: 83.31446044921876, critic loss: -3.5672192862033842
Step 12450: Generator loss: 80.4154541015625, critic loss: -9.493659735798834
Step 12500: Generator loss: 77.22660888671875, critic loss: -11.343838263094426
Step 12550: Generator loss: 76.51863540649414, critic loss: -15.957162732720372
Step 12600: Generator loss: 71.82434341430664, critic loss: -15.232202378749843
Step 12650: Generator loss: 81.55846801757812, critic loss: -12.02893185913563
Step 12700: Generator loss: 77.01351791381836, critic loss: -14.394531373143197
Step 12750: Generator loss: 82.79933059692382, critic loss: -10.995534277558324
Step 12800: Generator loss: 80.33022705078125, critic loss: -7.422801446437835
Step 12850: Generator loss: 77.88019416809082, critic loss: -10.48680070441961
Step 12900: Generator loss: 77.28355583190918, critic loss: -15.062006795048712
Step 12950: Generator loss: 72.02762420654297, critic loss: -18.125201426446434
Step 13000: Generator loss: 78.97825164794922, critic loss: -11.02606911355257
Step 13050: Generator loss: 76.02745002746582, critic loss: -13.242777463912965
Step 13100: Generator loss: 82.44893028259277, critic loss: -10.203380972802634
Step 13150: Generator loss: 80.63447105407715, critic loss: -11.436619911789894
Step 13200: Generator loss: 69.52673934936523, critic loss: -12.998723325610163
Step 13250: Generator loss: 75.26367416381837, critic loss: -12.58380482053757
Step 13300: Generator loss: 78.29216751098633, critic loss: 0.21028297042846839
Step 13350: Generator loss: 70.94842475891113, critic loss: -8.405993442416191
Step 13400: Generator loss: 77.60350791931153, critic loss: -12.201066960632803
Step 13450: Generator loss: 78.38650337219238, critic loss: -13.255251537919046
Step 13500: Generator loss: 72.39071220397949, critic loss: -13.91472595399618
Step 13550: Generator loss: 78.81595336914063, critic loss: -12.717635474145416
Step 13600: Generator loss: 69.23250061035156, critic loss: -15.01334501111508
Step 13650: Generator loss: 77.3666291809082, critic loss: -16.321711009979246
Step 13700: Generator loss: 73.45859939575195, critic loss: -17.17580293393135
Step 13750: Generator loss: 74.07134948730469, critic loss: -14.143001305580142
Step 13800: Generator loss: 68.98319381713867, critic loss: -18.013431072473526
Step 13850: Generator loss: 73.18379371643067, critic loss: -13.245033169150352
Step 13900: Generator loss: 73.70108238220215, critic loss: -15.747089947700497
Step 13950: Generator loss: 71.67143341064452, critic loss: -6.442092946648602
Step 14000: Generator loss: 74.99322380065918, critic loss: -5.310949310302733
Step 14050: Generator loss: 69.55456466674805, critic loss: -7.584069814443586
Step 14100: Generator loss: 68.11343818664551, critic loss: -15.932588892817499
Step 14150: Generator loss: 73.32868095397949, critic loss: -14.538219540774824
Step 14200: Generator loss: 71.54050506591797, critic loss: -6.507004916965961
Step 14250: Generator loss: 73.50055587768554, critic loss: -12.074983437180519
Step 14300: Generator loss: 75.37609176635742, critic loss: -12.215355042934414
Step 14350: Generator loss: 78.41978523254394, critic loss: -13.282461894750588
Step 14400: Generator loss: 69.06725090026856, critic loss: -8.44315874606371
Step 14450: Generator loss: 77.47375007629394, critic loss: -10.59642046368122
Step 14500: Generator loss: 72.112548828125, critic loss: -9.080148652315138
Step 14550: Generator loss: 71.41747200012207, critic loss: -12.610691975355143
Step 14600: Generator loss: 68.53853507995605, critic loss: -14.517420025825501
Step 14650: Generator loss: 71.00217765808105, critic loss: -16.055311642885208
Step 14700: Generator loss: 75.56183944702148, critic loss: -4.261986103117466
Step 14750: Generator loss: 68.21860916137695, critic loss: -14.03696541213989
Step 14800: Generator loss: 71.7959959411621, critic loss: -13.989702057063587
Step 14850: Generator loss: 76.38227409362793, critic loss: -10.939811514139176
Step 14900: Generator loss: 67.81556015014648, critic loss: -15.070325279712678
Step 14950: Generator loss: 71.62906150817871, critic loss: -12.239016912937165
Step 15000: Generator loss: 73.60893783569335, critic loss: -5.476252611890436
Step 15050: Generator loss: 64.43828086853027, critic loss: -11.680644391536712
Step 15100: Generator loss: 66.76135398864746, critic loss: -18.935012437820443
Step 15150: Generator loss: 64.45999412536621, critic loss: -16.77594568133354
Step 15200: Generator loss: 68.81907485961914, critic loss: -16.819265387773513
Step 15250: Generator loss: 71.44663459777831, critic loss: -14.780536164999004
Step 15300: Generator loss: 69.05639785766601, critic loss: -15.773872276782981
Step 15350: Generator loss: 72.00610313415527, critic loss: -12.428475862145426
Step 15400: Generator loss: 66.33817840576172, critic loss: -11.460507846534249
Step 15450: Generator loss: 73.98657371520996, critic loss: -12.046799251675607
Step 15500: Generator loss: 71.14604766845703, critic loss: -14.48868891143799
Step 15550: Generator loss: 72.55676879882813, critic loss: -9.285633412837981
Step 15600: Generator loss: 72.27706947326661, critic loss: -11.433179477930068
Step 15650: Generator loss: 70.14899436950684, critic loss: -14.64919223260879
Step 15700: Generator loss: 70.52759353637695, critic loss: -13.822800672113893
Step 15750: Generator loss: 66.5163092803955, critic loss: -13.497988208055496
Step 15800: Generator loss: 65.68713722229003, critic loss: -13.090139507174491
Step 15850: Generator loss: 68.86076667785645, critic loss: -12.112882311582563
Step 15900: Generator loss: 72.71573020935058, critic loss: -11.739855915784835
Step 15950: Generator loss: 69.23649925231933, critic loss: 1.5610642746686931
Step 16000: Generator loss: 63.27606719970703, critic loss: -6.625546929836272
Step 16050: Generator loss: 65.96758232116699, critic loss: -17.750343059539794
Step 16100: Generator loss: 62.09547576904297, critic loss: -17.4672027888298
Step 16150: Generator loss: 75.76868995666504, critic loss: -12.86666469740868
Step 16200: Generator loss: 64.08884880065918, critic loss: -7.587684287369252
Step 16250: Generator loss: 64.09755882263184, critic loss: -10.57423495966196
Step 16300: Generator loss: 66.86840660095214, critic loss: -3.5877239196300508
Step 16350: Generator loss: 70.60188285827637, critic loss: -7.692209842979907
Step 16400: Generator loss: 62.29129165649414, critic loss: -12.677523095130923
Step 16450: Generator loss: 62.98073165893555, critic loss: -13.866112356960771
Step 16500: Generator loss: 61.780632400512694, critic loss: -6.281874860048294
Step 16550: Generator loss: 62.74724609375, critic loss: -13.956338333368299
Step 16600: Generator loss: 61.48925178527832, critic loss: -16.810678883075717
Step 16650: Generator loss: 52.7329150390625, critic loss: -18.111987345457074
Step 16700: Generator loss: 60.26760322570801, critic loss: -17.837719259858133
Step 16750: Generator loss: 60.27441291809082, critic loss: -14.668455944180492
Step 16800: Generator loss: 64.81710945129394, critic loss: -8.937785160303115
Step 16850: Generator loss: 61.87463485717773, critic loss: -13.174851733446122
Step 16900: Generator loss: 66.52726516723632, critic loss: -17.641908020138743
Step 16950: Generator loss: 63.35795883178711, critic loss: -17.725372922539712
Step 17000: Generator loss: 67.46929817199707, critic loss: -13.343407141447067
Step 17050: Generator loss: 59.79177055358887, critic loss: -16.512492282271385
Step 17100: Generator loss: 66.42052528381348, critic loss: -9.183917128443717
Step 17150: Generator loss: 59.208996353149416, critic loss: -13.243339603602893
Step 17200: Generator loss: 63.88817520141602, critic loss: -13.442776112914084
Step 17250: Generator loss: 69.03452033996582, critic loss: -11.0614826682806
Step 17300: Generator loss: 57.58331108093262, critic loss: -13.529039879202841
Step 17350: Generator loss: 67.6368569946289, critic loss: -11.620229701399802
Step 17400: Generator loss: 60.044710845947264, critic loss: -9.055887681692841
Step 17450: Generator loss: 64.43620628356933, critic loss: -11.920627628207207
Step 17500: Generator loss: 56.046851272583005, critic loss: -22.301562000870714
Step 17550: Generator loss: 62.282958908081056, critic loss: -14.955312865734099
Step 17600: Generator loss: 65.897964553833, critic loss: -6.340100202620029
Step 17650: Generator loss: 58.14865257263184, critic loss: -10.649906709671022
Step 17700: Generator loss: 66.7437523651123, critic loss: -12.996105446338657
Step 17750: Generator loss: 63.59517837524414, critic loss: -12.67168800020218
Step 17800: Generator loss: 65.87414787292481, critic loss: -13.124171116769311
Step 17850: Generator loss: 66.03790901184082, critic loss: -13.294757736086847
Step 17900: Generator loss: 56.273787307739255, critic loss: -18.649981175422667
Step 17950: Generator loss: 68.3505224609375, critic loss: -13.77443748676777
Step 18000: Generator loss: 59.758854675292966, critic loss: -13.528435281991955
Step 18050: Generator loss: 70.61318840026856, critic loss: -12.014795050919052
Step 18100: Generator loss: 62.63155372619629, critic loss: -9.601117482304572
Step 18150: Generator loss: 58.44773849487305, critic loss: -9.71425095164776
Step 18200: Generator loss: 59.341090240478515, critic loss: -16.878086137115954
Step 18250: Generator loss: 57.848808708190916, critic loss: -19.507797758817674
Step 18300: Generator loss: 63.10433967590332, critic loss: -4.3734778246283526
Step 18350: Generator loss: 57.56446601867676, critic loss: -10.789146659135817
Step 18400: Generator loss: 51.76399398803711, critic loss: -15.076736944794657
Step 18450: Generator loss: 57.02366355895996, critic loss: -12.479052137970923
Step 18500: Generator loss: 62.833531875610355, critic loss: -12.99720428943634
Step 18550: Generator loss: 56.588841400146485, critic loss: -14.211519970417026
Step 18600: Generator loss: 61.620222854614255, critic loss: -14.894168957710265
Step 18650: Generator loss: 59.04514297485352, critic loss: -3.9987226614952096
Step 18700: Generator loss: 54.68501613616943, critic loss: -13.798751793980603
Step 18750: Generator loss: 60.477030181884764, critic loss: -13.97087904036045
Step 18800: Generator loss: 59.51054759979248, critic loss: -18.694762709856033
Step 18850: Generator loss: 53.82080192565918, critic loss: -14.210277070969342
Step 18900: Generator loss: 64.43251205444336, critic loss: -13.768319549560543
Step 18950: Generator loss: 56.9788289642334, critic loss: -10.571144456863403
Step 19000: Generator loss: 59.03595703125, critic loss: -12.603199533462528
Step 19050: Generator loss: 60.19775802612305, critic loss: -14.499388661146167
Step 19100: Generator loss: 59.592409973144534, critic loss: -8.202755635917187
Step 19150: Generator loss: 55.50546585083008, critic loss: -16.347688998579976
Step 19200: Generator loss: 61.19869083404541, critic loss: -18.950819284915923
Step 19250: Generator loss: 66.31558391571045, critic loss: -12.890463754177098
Step 19300: Generator loss: 57.29240139007568, critic loss: -18.10998232960701
Step 19350: Generator loss: 59.32999900817871, critic loss: -13.577078444600104
Step 19400: Generator loss: 65.96876052856446, critic loss: -11.8188825455904
Step 19450: Generator loss: 56.72755683898926, critic loss: -14.319641982913016
Step 19500: Generator loss: 57.38858169555664, critic loss: -17.450813733339313
Step 19550: Generator loss: 66.02516723632813, critic loss: -10.693548452854154
Step 19600: Generator loss: 54.7833975982666, critic loss: -13.142704640865325
Step 19650: Generator loss: 57.28132354736328, critic loss: -14.967523851156233
Step 19700: Generator loss: 59.98361915588379, critic loss: -16.183865994155408
Step 19750: Generator loss: 58.18478466033935, critic loss: -15.35918751955032
Step 19800: Generator loss: 63.54511661529541, critic loss: -10.502776491999626
Step 19850: Generator loss: 56.24938293457031, critic loss: -6.75664558506012
Step 19900: Generator loss: 60.40652961730957, critic loss: -13.489446130156516
Ended: 2021-04-23 17:33:03.659309
Elapsed: 0:48:26.572738
</pre>
<pre class="example" id="org7551d1c">
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
&lt;ipython-input-35-08d8bddbdcc4&gt; in &lt;module&gt;
     14             for _ in range(crit_repeats):
     15                 ### Update critic ###
---&gt; 16                 this_loss, fake = update_critic(crit, crit_opt, gen, gen_opt,
     17                                                 cur_batch_size, z_dim, real)
     18                 mean_iteration_critic_loss += this_loss

&lt;ipython-input-33-696fefd91963&gt; in update_critic(critic, critic_optimizer, generator, generator_optimizer, batch_size, z_dim, real)
      7 
      8     epsilon = torch.rand(len(real), 1, 1, 1, device=device, requires_grad=True)
----&gt; 9     gradient = get_gradient(critic, real, fake.detach(), epsilon)
     10     gp = gradient_penalty(gradient)
     11     crit_loss = get_crit_loss(crit_fake_pred, crit_real_pred, gp, c_lambda)

&lt;ipython-input-16-06dea6615386&gt; in get_gradient(crit, real, fake, epsilon)
     19 
     20     # Take the gradient of the scores with respect to the images
---&gt; 21     gradient = torch.autograd.grad(
     22         # Note: You need to take the gradient of outputs with respect to inputs.
     23         #### START CODE HERE ####

~/.conda/envs/neurotic-pytorch/lib/python3.9/site-packages/torch/autograd/__init__.py in grad(outputs, inputs, grad_outputs, retain_graph, create_graph, only_inputs, allow_unused)
    221         retain_graph = create_graph
    222 
--&gt; 223     return Variable._execution_engine.run_backward(
    224         outputs, grad_outputs_, retain_graph, create_graph,
    225         inputs, allow_unused, accumulate_grad=False)

RuntimeError: CUDA out of memory. Tried to allocate 20.00 MiB (GPU 0; 7.92 GiB total capacity; 7.13 GiB already allocated; 24.62 MiB free; 7.13 GiB reserved in total by PyTorch)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org6b62742">
<h2 id="org6b62742">End</h2>
<div class="outline-text-2" id="text-org6b62742">
<ul class="org-ul">
<li>Arjovsky M, Chintala S, Bottou L. Wasserstein generative adversarial networks. International conference on machine learning 2017 Jul 17 (pp. 214-223). PMLR. (<a href="https://arxiv.org/abs/1701.07875?source=post_page-----aee68ed8a38c----------------------">archiv.org</a>)</li>
<li>Gulrajani I, Ahmed F, Arjovsky M, Dumoulin V, Courville A. Improved training of wasserstein gans. arXiv preprint arXiv:1704.00028. 2017 Mar 31. (<a href="https://arxiv.org/abs/1704.00028">archiv.org</a>)</li>
</ul>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/gans/cnn-gan/index.html">CNN GAN</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/gans/cnn-gan/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-04-14T19:52:11-07:00" itemprop="datePublished" title="2021-04-14 19:52">2021-04-14 19:52</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/gans/cnn-gan/index.html#org38b4464">Deep Convolutional GAN (DCGAN)</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#org9e3828d">Imports</a></li>
<li><a href="posts/gans/cnn-gan/index.html#orgc3d03f2">Set Up</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#org69243bd">The Random Seed</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org96c0b8f">Plotting and Timing</a></li>
</ul>
</li>
<li><a href="posts/gans/cnn-gan/index.html#orgc180031">Helper Functions</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#orgd8cb036">A Plotter</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org3cf63f3">A Noise Maker</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="posts/gans/cnn-gan/index.html#org77f0e59">Middle</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#org8a21582">The Generator</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#orgf3c0033">The Generator Class</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org0534792">Setup Testing</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org9641f6d">Unit Tests</a></li>
</ul>
</li>
<li><a href="posts/gans/cnn-gan/index.html#org9d73b27">The Discriminator</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#org80e08e3">The Discriminator Class</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org2d98cad">Set Up Testing</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org0d490bb">Unit Testing</a></li>
</ul>
</li>
<li><a href="posts/gans/cnn-gan/index.html#org89a09ee">Training The Model</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#orgaefac82">Set Up The Data</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org9b24a98">Set Up the GAN</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org32d1913">A Weight Initializer</a></li>
<li><a href="posts/gans/cnn-gan/index.html#org6eb9978">Train it</a></li>
</ul>
</li>
<li><a href="posts/gans/cnn-gan/index.html#org2b6f5a5">Looking at the Final model.</a></li>
</ul>
</li>
<li><a href="posts/gans/cnn-gan/index.html#org925156c">End</a>
<ul>
<li><a href="posts/gans/cnn-gan/index.html#orgaa5233f">Sources</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org38b4464">
<h2 id="org38b4464">Deep Convolutional GAN (DCGAN)</h2>
<div class="outline-text-2" id="text-org38b4464">
<p>We're going to build a Generative Adversarial Network to generate handwritten digits. Instead of using fully-connected layers we'll use Convolutional layers.</p>
<p>Here are the main features of a DCGAN.</p>
<ul class="org-ul">
<li>Replace any pooling layers with strided convolutions (discriminator) and fractional-strided convolutions (generator).</li>
<li>Use BatchNorm in both the generator and the discriminator.</li>
<li>Remove fully connected hidden layers for deeper architectures.</li>
<li>ReLU activation in generator for all layers except for the output, which uses Tanh.</li>
<li>Use LeakyReLU activation in the discriminator for all layers.</li>
</ul>
</div>
<div class="outline-3" id="outline-container-org9e3828d">
<h3 id="org9e3828d">Imports</h3>
<div class="outline-text-3" id="text-org9e3828d">
<div class="highlight">
<pre><span></span><span class="c1"># python</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># conda</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>
<span class="kn">from</span> <span class="nn">torchvision.datasets</span> <span class="kn">import</span> <span class="n">MNIST</span>
<span class="kn">from</span> <span class="nn">torchvision.utils</span> <span class="kn">import</span> <span class="n">make_grid</span>

<span class="kn">import</span> <span class="nn">holoviews</span>
<span class="kn">import</span> <span class="nn">hvplot.pandas</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="c1"># my stuff</span>
<span class="kn">from</span> <span class="nn">graeae</span> <span class="kn">import</span> <span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">Timer</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgc3d03f2">
<h3 id="orgc3d03f2">Set Up</h3>
<div class="outline-text-3" id="text-orgc3d03f2"></div>
<div class="outline-4" id="outline-container-org69243bd">
<h4 id="org69243bd">The Random Seed</h4>
<div class="outline-text-4" id="text-org69243bd">
<div class="highlight">
<pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org96c0b8f">
<h4 id="org96c0b8f">Plotting and Timing</h4>
<div class="outline-text-4" id="text-org96c0b8f">
<div class="highlight">
<pre><span></span><span class="n">TIMER</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
<span class="n">slug</span> <span class="o">=</span> <span class="s2">"cnn-gan"</span>

<span class="n">Embed</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="sa">f</span><span class="s2">"files/posts/gans/</span><span class="si">{</span><span class="n">slug</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">Plot</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"Plot"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"width"</span><span class="p">,</span> <span class="s2">"height"</span><span class="p">,</span> <span class="s2">"fontscale"</span><span class="p">,</span> <span class="s2">"tan"</span><span class="p">,</span> <span class="s2">"blue"</span><span class="p">,</span> <span class="s2">"red"</span><span class="p">])</span>
<span class="n">PLOT</span> <span class="o">=</span> <span class="n">Plot</span><span class="p">(</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">900</span><span class="p">,</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">750</span><span class="p">,</span>
    <span class="n">fontscale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">tan</span><span class="o">=</span><span class="s2">"#ddb377"</span><span class="p">,</span>
    <span class="n">blue</span><span class="o">=</span><span class="s2">"#4687b7"</span><span class="p">,</span>
    <span class="n">red</span><span class="o">=</span><span class="s2">"#ce7b6d"</span><span class="p">,</span>
 <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgc180031">
<h3 id="orgc180031">Helper Functions</h3>
<div class="outline-text-3" id="text-orgc180031"></div>
<div class="outline-4" id="outline-container-orgd8cb036">
<h4 id="orgd8cb036">A Plotter</h4>
<div class="outline-text-4" id="text-orgd8cb036">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="n">num_images</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                <span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span>
                <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="sa">f</span><span class="s2">"files/posts/gans/</span><span class="si">{</span><span class="n">slug</span><span class="si">}</span><span class="s2">/"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Plot the image and save it</span>

<span class="sd">    Args:</span>
<span class="sd">     image: the tensor with the image to plot</span>
<span class="sd">     filename: name for the final image file</span>
<span class="sd">     title: title to put on top of the image</span>
<span class="sd">     num_images: how many images to put in the composite image</span>
<span class="sd">     size: the size for the image</span>
<span class="sd">     folder: sub-folder to save the file in</span>
<span class="sd">    """</span>
    <span class="n">unflattened_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
    <span class="n">image_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">unflattened_image</span><span class="p">[:</span><span class="n">num_images</span><span class="p">],</span> <span class="n">nrow</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image_grid</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>

    <span class="n">pyplot</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="n">filename</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[[file:</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">]]"</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org3cf63f3">
<h4 id="org3cf63f3">A Noise Maker</h4>
<div class="outline-text-4" id="text-org3cf63f3">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">make_some_noise</span><span class="p">(</span><span class="n">n_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">"cpu"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""create noise vectors</span>

<span class="sd">    creates </span>
<span class="sd">    Args:</span>
<span class="sd">       n_samples: the number of samples to generate, a scalar</span>
<span class="sd">       z_dim: the dimension of the noise vector, a scalar</span>
<span class="sd">       device: the device type (cpu or cuda)</span>

<span class="sd">    Returns:</span>
<span class="sd">     tensor with random numbers from the normal distribution.</span>
<span class="sd">    """</span>

    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org77f0e59">
<h2 id="org77f0e59">Middle</h2>
<div class="outline-text-2" id="text-org77f0e59"></div>
<div class="outline-3" id="outline-container-org8a21582">
<h3 id="org8a21582">The Generator</h3>
<div class="outline-text-3" id="text-org8a21582">
<p>The first component you will make is the generator. You may notice that instead of passing in the image dimension, you will pass the number of image channels to the generator. This is because with DCGAN, you use convolutions which don’t depend on the number of pixels on an image. However, the number of channels is important to determine the size of the filters.</p>
<p>You will build a generator using 4 layers (3 hidden layers + 1 output layer). As before, you will need to write a function to create a single block for the generator's neural network. From the paper:</p>
<ul class="org-ul">
<li>[u]se batchnorm in both the generator and the discriminator"</li>
<li>[u]se ReLU activation in generator for all layers except for the output, which uses Tanh.</li>
</ul>
<p>Since in DCGAN the activation function will be different for the output layer, you will need to check what layer is being created.</p>
<p>At the end of the generator class, you are given a forward pass function that takes in a noise vector and generates an image of the output dimension using your neural network. You are also given a function to create a noise vector. These functions are the same as the ones from the last assignment.</p>
<p>See also:</p>
<ul class="org-ul">
<li><a href="https://pytorch.org/docs/master/generated/torch.nn.ConvTranspose2d.html">nn.ConvTranspose2d</a></li>
<li><a href="https://pytorch.org/docs/master/generated/torch.nn.BatchNorm2d.html">nn.BatchNorm2d</a></li>
</ul>
</div>
<div class="outline-4" id="outline-container-orgf3c0033">
<h4 id="orgf3c0033">The Generator Class</h4>
<div class="outline-text-4" id="text-orgf3c0033">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Generator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""The DCGAN Generator</span>

<span class="sd">    Args:</span>
<span class="sd">       z_dim: the dimension of the noise vector</span>
<span class="sd">       im_chan: the number of channels in the images, fitted for the dataset used</span>
<span class="sd">             (MNIST is black-and-white, so 1 channel is your default)</span>
<span class="sd">       hidden_dim: the inner dimension,</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">im_chan</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_dim</span> <span class="o">=</span> <span class="n">z_dim</span>
        <span class="c1"># Build the neural network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">im_chan</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">final_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_gen_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                       <span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">final_layer</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Creates a block for the generator (sub sequence)</span>

<span class="sd">       The parts</span>
<span class="sd">        - a transposed convolution</span>
<span class="sd">        - a batchnorm (except for in the last layer)</span>
<span class="sd">        - an activation.</span>

<span class="sd">       Args:</span>
<span class="sd">           input_channels: how many channels the input feature representation has</span>
<span class="sd">           output_channels: how many channels the output feature representation should have</span>
<span class="sd">           kernel_size: the size of each convolutional filter, equivalent to (kernel_size, kernel_size)</span>
<span class="sd">           stride: the stride of the convolution</span>
<span class="sd">           final_layer: a boolean, true if it is the final layer and false otherwise </span>
<span class="sd">                     (affects activation and batchnorm)</span>

<span class="sd">       Returns:</span>
<span class="sd">        the sub-sequence of layers</span>
<span class="sd">       """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">final_layer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">output_channels</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Final Layer</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">Tanh</span><span class="p">()</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">unsqueeze_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""transforms the noise tensor</span>

<span class="sd">       Args:</span>
<span class="sd">           noise: a noise tensor with dimensions (n_samples, z_dim)</span>

<span class="sd">       Returns:</span>
<span class="sd">        copy of noise with width and height = 1 and channels = z_dim.</span>
<span class="sd">       """</span>
        <span class="k">return</span> <span class="n">noise</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">noise</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""complete a forward pass of the generator: Given a noise tensor, </span>

<span class="sd">       Args:</span>
<span class="sd">        noise: a noise tensor with dimensions (n_samples, z_dim)</span>

<span class="sd">       Returns:</span>
<span class="sd">        generated images.</span>
<span class="sd">       """</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unsqueeze_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org0534792">
<h4 id="org0534792">Setup Testing</h4>
<div class="outline-text-4" id="text-org0534792">
<div class="highlight">
<pre><span></span><span class="n">gen</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">()</span>
<span class="n">num_test</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Test the hidden block</span>
<span class="n">test_hidden_noise</span> <span class="o">=</span> <span class="n">make_some_noise</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">z_dim</span><span class="p">)</span>
<span class="n">test_hidden_block</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">test_uns_noise</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">unsqueeze_noise</span><span class="p">(</span><span class="n">test_hidden_noise</span><span class="p">)</span>
<span class="n">hidden_output</span> <span class="o">=</span> <span class="n">test_hidden_block</span><span class="p">(</span><span class="n">test_uns_noise</span><span class="p">)</span>

<span class="c1"># Check that it works with other strides</span>
<span class="n">test_hidden_block_stride</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">test_final_noise</span> <span class="o">=</span> <span class="n">make_some_noise</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">z_dim</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span>
<span class="n">test_final_block</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">make_gen_block</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">final_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">test_final_uns_noise</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">unsqueeze_noise</span><span class="p">(</span><span class="n">test_final_noise</span><span class="p">)</span>
<span class="n">final_output</span> <span class="o">=</span> <span class="n">test_final_block</span><span class="p">(</span><span class="n">test_final_uns_noise</span><span class="p">)</span>

<span class="c1"># Test the whole thing:</span>
<span class="n">test_gen_noise</span> <span class="o">=</span> <span class="n">make_some_noise</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">z_dim</span><span class="p">)</span>
<span class="n">test_uns_gen_noise</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">unsqueeze_noise</span><span class="p">(</span><span class="n">test_gen_noise</span><span class="p">)</span>
<span class="n">gen_output</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">test_uns_gen_noise</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9641f6d">
<h4 id="org9641f6d">Unit Tests</h4>
<div class="outline-text-4" id="text-org9641f6d">
<div class="highlight">
<pre><span></span><span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hidden_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">assert</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.2</span>
<span class="k">assert</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span>

<span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">test_hidden_block_stride</span><span class="p">(</span><span class="n">hidden_output</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">final_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>
<span class="k">assert</span> <span class="n">final_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gen_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">gen_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
<span class="k">assert</span> <span class="n">gen_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.8</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Success!"</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org9d73b27">
<h3 id="org9d73b27">The Discriminator</h3>
<div class="outline-text-3" id="text-org9d73b27">
<p>The second component you need to create is the discriminator.</p>
<p>You will use 3 layers in your discriminator's neural network. Like with the generator, you will need to create the method to create a single neural network block for the discriminator.</p>
<p>From the paper:</p>
<ul class="org-ul">
<li>[u]se LeakyReLU activation in the discriminator for all layers.</li>
<li>For the LeakyReLUs, "the slope of the leak was set to 0.2" in DCGAN.</li>
</ul>
<p>See Also:</p>
<ul class="org-ul">
<li><a href="https://pytorch.org/docs/master/generated/torch.nn.Conv2d.html">nn.Conv2d</a></li>
<li><a href="https://pytorch.org/docs/master/generated/torch.nn.BatchNorm2d.html">nn.BatchNorm2d</a></li>
<li><a href="https://pytorch.org/docs/master/generated/torch.nn.LeakyReLU.html">nn.LeakyReLU</a></li>
</ul>
</div>
<div class="outline-4" id="outline-container-org80e08e3">
<h4 id="org80e08e3">The Discriminator Class</h4>
<div class="outline-text-4" id="text-org80e08e3">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Discriminator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""The DCGAN Discriminator</span>

<span class="sd">    Args:</span>
<span class="sd">     im_chan: the number of channels in the images, fitted for the dataset used</span>
<span class="sd">             (MNIST is black-and-white, so 1 channel is the default)</span>
<span class="sd">     hidden_dim: the inner dimension,</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_chan</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Discriminator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_disc_block</span><span class="p">(</span><span class="n">im_chan</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_disc_block</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_disc_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">final_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">make_disc_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                        <span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                        <span class="n">final_layer</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Make a sub-block of layers for the discriminator</span>

<span class="sd">        - a convolution</span>
<span class="sd">        - a batchnorm (except for in the last layer)</span>
<span class="sd">        - an activation.</span>

<span class="sd">       Args:</span>
<span class="sd">         input_channels: how many channels the input feature representation has</span>
<span class="sd">         output_channels: how many channels the output feature representation should have</span>
<span class="sd">         kernel_size: the size of each convolutional filter, equivalent to (kernel_size, kernel_size)</span>
<span class="sd">         stride: the stride of the convolution</span>
<span class="sd">         final_layer: if true it is the final layer and otherwise not</span>
<span class="sd">                     (affects activation and batchnorm)</span>
<span class="sd">       """</span>        
        <span class="c1"># Build the neural block</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">final_layer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">output_channels</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Final Layer</span>
            <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">input_channels</span><span class="p">,</span> <span class="n">output_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Complete a forward pass of the discriminator</span>

<span class="sd">       Args:</span>
<span class="sd">         image: a flattened image tensor with dimension (im_dim)</span>

<span class="sd">       Returns:</span>
<span class="sd">        a 1-dimension tensor representing fake/real.</span>
<span class="sd">       """</span>
        <span class="n">disc_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">disc_pred</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">disc_pred</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org2d98cad">
<h4 id="org2d98cad">Set Up Testing</h4>
<div class="outline-text-4" id="text-org2d98cad">
<div class="highlight">
<pre><span></span><span class="n">num_test</span> <span class="o">=</span> <span class="mi">100</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">()</span>
<span class="n">disc</span> <span class="o">=</span> <span class="n">Discriminator</span><span class="p">()</span>
<span class="n">test_images</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">make_some_noise</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">z_dim</span><span class="p">))</span>

<span class="c1"># Test the hidden block</span>
<span class="n">test_hidden_block</span> <span class="o">=</span> <span class="n">disc</span><span class="o">.</span><span class="n">make_disc_block</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">hidden_output</span> <span class="o">=</span> <span class="n">test_hidden_block</span><span class="p">(</span><span class="n">test_images</span><span class="p">)</span>

<span class="c1"># Test the final block</span>
<span class="n">test_final_block</span> <span class="o">=</span> <span class="n">disc</span><span class="o">.</span><span class="n">make_disc_block</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">final_layer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">final_output</span> <span class="o">=</span> <span class="n">test_final_block</span><span class="p">(</span><span class="n">test_images</span><span class="p">)</span>

<span class="c1"># Test the whole thing:</span>
<span class="n">disc_output</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">test_images</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org0d490bb">
<h4 id="org0d490bb">Unit Testing</h4>
<div class="outline-text-4" id="text-org0d490bb"></div>
<ul class="org-ul">
<li><a id="orge64e01f"></a>The Hidden Block<br>
<div class="outline-text-5" id="text-orge64e01f">
<div class="highlight">
<pre><span></span><span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">hidden_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="c1"># Because of the LeakyReLU slope</span>
<span class="k">assert</span> <span class="o">-</span><span class="n">hidden_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.15</span>
<span class="k">assert</span> <span class="o">-</span><span class="n">hidden_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.25</span>
<span class="k">assert</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
<span class="k">assert</span> <span class="n">hidden_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span>
</pre></div>
</div>
</li>
<li><a id="org819fd67"></a>The Final Block<br>
<div class="outline-text-5" id="text-org819fd67">
<div class="highlight">
<pre><span></span><span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">final_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">final_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1.0</span>
<span class="k">assert</span> <span class="n">final_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.0</span>
<span class="k">assert</span> <span class="n">final_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.3</span>
<span class="k">assert</span> <span class="n">final_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.6</span>
</pre></div>
</div>
</li>
<li><a id="orgb91ac7c"></a>The Whole Thing<br>
<div class="outline-text-5" id="text-orgb91ac7c">
<div class="highlight">
<pre><span></span><span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">disc_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">disc_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.25</span>
<span class="k">assert</span> <span class="n">disc_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Success!"</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org89a09ee">
<h3 id="org89a09ee">Training The Model</h3>
<div class="outline-text-3" id="text-org89a09ee">
<p>Remember that these are your parameters:</p>
<ul class="org-ul">
<li>criterion: the loss function</li>
<li>n_epochs: the number of times you iterate through the entire dataset when training</li>
<li>z_dim: the dimension of the noise vector</li>
<li>display_step: how often to display/visualize the images</li>
<li>batch_size: the number of images per forward/backward pass</li>
<li>lr: the learning rate</li>
<li>beta_1, beta_2: the momentum term</li>
<li>device: the device type</li>
</ul>
</div>
<div class="outline-4" id="outline-container-orgaefac82">
<h4 id="orgaefac82">Set Up The Data</h4>
<div class="outline-text-4" id="text-orgaefac82">
<div class="highlight">
<pre><span></span><span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">()</span>
<span class="n">z_dim</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="c1"># A learning rate of 0.0002 works well on DCGAN</span>
<span class="n">lr</span> <span class="o">=</span> <span class="mf">0.0002</span>

<span class="c1"># These parameters control the optimizer's momentum, which you can read more about here:</span>
<span class="c1"># https://distill.pub/2017/momentum/ but you don’t need to worry about it for this course!</span>
<span class="n">beta_1</span> <span class="o">=</span> <span class="mf">0.5</span> 
<span class="n">beta_2</span> <span class="o">=</span> <span class="mf">0.999</span>
<span class="n">device</span> <span class="o">=</span> <span class="s1">'cuda'</span>

<span class="c1"># You can tranform the image values to be between -1 and 1 (the range of the tanh activation)</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
    <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,)),</span>
<span class="p">])</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">"~/pytorch-data/MNIST"</span><span class="p">)</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>
<span class="n">dataloader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">MNIST</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">),</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9b24a98">
<h4 id="org9b24a98">Set Up the GAN</h4>
<div class="outline-text-4" id="text-org9b24a98">
<div class="highlight">
<pre><span></span><span class="n">gen</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="n">gen_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="p">(</span><span class="n">beta_1</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">))</span>
<span class="n">disc</span> <span class="o">=</span> <span class="n">Discriminator</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
<span class="n">disc_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">disc</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="p">(</span><span class="n">beta_1</span><span class="p">,</span> <span class="n">beta_2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org32d1913">
<h4 id="org32d1913">A Weight Initializer</h4>
<div class="outline-text-4" id="text-org32d1913">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">initial_weights</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Initialize the weights to the normal distribution</span>

<span class="sd">     - mean 0</span>
<span class="sd">     - standard deviation 0.02</span>

<span class="sd">    Args:</span>
<span class="sd">     m: layer whose weights to initialize</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">):</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">):</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">constant_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">gen</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">initial_weights</span><span class="p">)</span>
<span class="n">disc</span> <span class="o">=</span> <span class="n">disc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">initial_weights</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6eb9978">
<h4 id="org6eb9978">Train it</h4>
<div class="outline-text-4" id="text-org6eb9978">
<p>For each epoch, you will process the entire dataset in batches. For every batch, you will update the discriminator and generator. Then, you can see DCGAN's results!</p>
<p>Here's roughly the progression you should be expecting. On GPU this takes about 30 seconds per thousand steps. On CPU, this can take about 8 hours per thousand steps. You might notice that in the image of Step 5000, the generator is disproprotionately producing things that look like ones. If the discriminator didn't learn to detect this imbalance quickly enough, then the generator could just produce more ones. As a result, it may have ended up tricking the discriminator so well that there would be no more improvement, known as mode collapse.</p>
<div class="highlight">
<pre><span></span><span class="n">n_epochs</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">cur_step</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">display_step</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">mean_generator_loss</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mean_discriminator_loss</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">generator_losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">discriminator_losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">best_loss</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">"inf"</span><span class="p">)</span>
<span class="n">best_step</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">best_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">"~/models/gans/mnist-dcgan/best_model.pth"</span><span class="p">)</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>

<span class="k">with</span> <span class="n">TIMER</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">):</span>
        <span class="c1"># Dataloader returns the batches</span>
        <span class="k">for</span> <span class="n">real</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
            <span class="n">cur_batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
            <span class="n">real</span> <span class="o">=</span> <span class="n">real</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

            <span class="c1">## Update discriminator ##</span>
            <span class="n">disc_opt</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="n">fake_noise</span> <span class="o">=</span> <span class="n">make_some_noise</span><span class="p">(</span><span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">fake</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">fake_noise</span><span class="p">)</span>
            <span class="n">disc_fake_pred</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">fake</span><span class="o">.</span><span class="n">detach</span><span class="p">())</span>
            <span class="n">disc_fake_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">disc_fake_pred</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">disc_fake_pred</span><span class="p">))</span>
            <span class="n">disc_real_pred</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
            <span class="n">disc_real_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">disc_real_pred</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">disc_real_pred</span><span class="p">))</span>
            <span class="n">disc_loss</span> <span class="o">=</span> <span class="p">(</span><span class="n">disc_fake_loss</span> <span class="o">+</span> <span class="n">disc_real_loss</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="c1"># Keep track of the average discriminator loss</span>
            <span class="n">mean_discriminator_loss</span> <span class="o">+=</span> <span class="n">disc_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">display_step</span>
            <span class="c1"># Update gradients</span>
            <span class="n">disc_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Update optimizer</span>
            <span class="n">disc_opt</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

            <span class="c1">## Update generator ##</span>
            <span class="n">gen_opt</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="n">fake_noise_2</span> <span class="o">=</span> <span class="n">make_some_noise</span><span class="p">(</span><span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="n">fake_2</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">fake_noise_2</span><span class="p">)</span>
            <span class="n">disc_fake_pred</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">fake_2</span><span class="p">)</span>
            <span class="n">gen_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">disc_fake_pred</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">disc_fake_pred</span><span class="p">))</span>
            <span class="n">gen_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">gen_opt</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

            <span class="c1"># Keep track of the average generator loss</span>
            <span class="n">mean_generator_loss</span> <span class="o">+=</span> <span class="n">gen_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">display_step</span>
            <span class="k">if</span> <span class="n">mean_generator_loss</span> <span class="o">&lt;</span> <span class="n">best_loss</span><span class="p">:</span>
                <span class="n">best_loss</span><span class="p">,</span> <span class="n">best_step</span> <span class="o">=</span> <span class="n">mean_generator_loss</span><span class="p">,</span> <span class="n">cur_step</span>
                <span class="k">with</span> <span class="n">best_path</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">writer</span><span class="p">)</span>
            <span class="c1">## Visualization code ##</span>
            <span class="k">if</span> <span class="n">cur_step</span> <span class="o">%</span> <span class="n">display_step</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cur_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Epoch </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">, step </span><span class="si">{</span><span class="n">cur_step</span><span class="si">}</span><span class="s2">: Generator loss:"</span>
                        <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">mean_generator_loss</span><span class="si">}</span><span class="s2">, discriminator loss:"</span>
                        <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">mean_discriminator_loss</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

                <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_step</span><span class="p">)</span>
                <span class="n">generator_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_generator_loss</span><span class="p">)</span>
                <span class="n">discriminator_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_discriminator_loss</span><span class="p">)</span>

                <span class="n">mean_generator_loss</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">mean_discriminator_loss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cur_step</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
<pre class="example" id="org6b21b22">
Started: 2021-04-21 12:45:12.452739
Epoch 2, step 1000: Generator loss: 1.2671969079673289, discriminator loss: 0.43014343224465823
Epoch 4, step 2000: Generator loss: 1.1353899730443968, discriminator loss: 0.5306872705817226
Epoch 6, step 3000: Generator loss: 0.8764803466945883, discriminator loss: 0.611450107574464
Epoch 8, step 4000: Generator loss: 0.7747784045338618, discriminator loss: 0.6631499938964849
Epoch 10, step 5000: Generator loss: 0.7640163034200661, discriminator loss: 0.6734729865789411
Epoch 12, step 6000: Generator loss: 0.7452541967928404, discriminator loss: 0.6805261079072958
Epoch 14, step 7000: Generator loss: 0.7337032879889016, discriminator loss: 0.6874966211915009
Epoch 17, step 8000: Generator loss: 0.7245009585618979, discriminator loss: 0.6908933531045917
Epoch 19, step 9000: Generator loss: 0.7180560626983646, discriminator loss: 0.6936621717810626
Epoch 21, step 10000: Generator loss: 0.7115822317004211, discriminator loss: 0.695760274052621
Epoch 23, step 11000: Generator loss: 0.7090291924774644, discriminator loss: 0.6962701203227039
Epoch 25, step 12000: Generator loss: 0.7059894913136957, discriminator loss: 0.6973492541313167
Epoch 27, step 13000: Generator loss: 0.7030480077862743, discriminator loss: 0.6978999735713001
Epoch 29, step 14000: Generator loss: 0.7028095332086096, discriminator loss: 0.6974007876515396
Epoch 31, step 15000: Generator loss: 0.7027116653919212, discriminator loss: 0.6965595571994787
Epoch 34, step 16000: Generator loss: 0.7005282629728309, discriminator loss: 0.6962912415862079
Epoch 36, step 17000: Generator loss: 0.7007142878770828, discriminator loss: 0.6961965024471283
Epoch 38, step 18000: Generator loss: 0.699474583208561, discriminator loss: 0.6952810400128371
Epoch 40, step 19000: Generator loss: 0.6989677719473828, discriminator loss: 0.6954642050266268
Epoch 42, step 20000: Generator loss: 0.6977452509403238, discriminator loss: 0.695180906951427
Epoch 44, step 21000: Generator loss: 0.6973587237596515, discriminator loss: 0.6950308464765543
Epoch 46, step 22000: Generator loss: 0.6960379970669743, discriminator loss: 0.6949119175076485
Epoch 49, step 23000: Generator loss: 0.6957966268062581, discriminator loss: 0.6948324624896048
Epoch 51, step 24000: Generator loss: 0.6958502059578898, discriminator loss: 0.6945331234931943
Epoch 53, step 25000: Generator loss: 0.6954856168627734, discriminator loss: 0.6943869084119801
Epoch 55, step 26000: Generator loss: 0.6957543395757682, discriminator loss: 0.694317172288894
Epoch 57, step 27000: Generator loss: 0.6947923063635825, discriminator loss: 0.694082073867321
Epoch 59, step 28000: Generator loss: 0.6945026598572728, discriminator loss: 0.6939926172494871
Epoch 61, step 29000: Generator loss: 0.6947789136767392, discriminator loss: 0.6938506522774704
Epoch 63, step 30000: Generator loss: 0.6946699734926227, discriminator loss: 0.6937169924378406
Epoch 66, step 31000: Generator loss: 0.6944284628629694, discriminator loss: 0.6936815274357805
Epoch 68, step 32000: Generator loss: 0.6940396347641948, discriminator loss: 0.6935891906023032
Epoch 70, step 33000: Generator loss: 0.6946771386265761, discriminator loss: 0.6937210547327995
Epoch 72, step 34000: Generator loss: 0.693429798424244, discriminator loss: 0.6937174627780922
Epoch 74, step 35000: Generator loss: 0.6937471128702157, discriminator loss: 0.6935204346776015
Epoch 76, step 36000: Generator loss: 0.6938841561675072, discriminator loss: 0.6934832554459566
Epoch 78, step 37000: Generator loss: 0.6934520475268362, discriminator loss: 0.6934578058719627
Epoch 81, step 38000: Generator loss: 0.6936635475754732, discriminator loss: 0.6934186050295835
Epoch 83, step 39000: Generator loss: 0.6936795052289972, discriminator loss: 0.6935187472105031
Epoch 85, step 40000: Generator loss: 0.6933113215565679, discriminator loss: 0.6933534587025645
Epoch 87, step 41000: Generator loss: 0.6934976277351385, discriminator loss: 0.6933284662365923
Epoch 89, step 42000: Generator loss: 0.6933313971757892, discriminator loss: 0.693348657488824
Epoch 91, step 43000: Generator loss: 0.6937436528205883, discriminator loss: 0.6933502901792529
Epoch 93, step 44000: Generator loss: 0.6943431540131578, discriminator loss: 0.6933887023925772
Epoch 95, step 45000: Generator loss: 0.6938722513914105, discriminator loss: 0.6932663491368296
Epoch 98, step 46000: Generator loss: 0.6933276618123067, discriminator loss: 0.6934270900487906
Ended: 2021-04-21 13:06:00.256725
Elapsed: 0:20:47.803986
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org2b6f5a5">
<h3 id="org2b6f5a5">Looking at the Final model.</h3>
<div class="outline-text-3" id="text-org2b6f5a5">
<div class="highlight">
<pre><span></span><span class="n">fake_noise</span> <span class="o">=</span> <span class="n">make_some_noise</span><span class="p">(</span><span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

<span class="n">best_model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">best_path</span><span class="p">)</span>
<span class="n">fake</span> <span class="o">=</span> <span class="n">best_model</span><span class="p">(</span><span class="n">fake_noise</span><span class="p">)</span>
<span class="n">plot_image</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">fake</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"fake_digits.png"</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">"Fake Digits"</span><span class="p">)</span>
</pre></div>
<div class="figure" id="org944d7e1">
<p><img alt="fake_digits.png" src="posts/gans/cnn-gan/fake_digits.png"></p>
</div>
<div class="highlight">
<pre><span></span><span class="n">plot_image</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"real_digits.png"</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">"Real Digits"</span><span class="p">)</span>
</pre></div>
<div class="figure" id="orgdaa9fc9">
<p><img alt="real_digits.png" src="posts/gans/cnn-gan/real_digits.png"></p>
</div>
<div class="highlight">
<pre><span></span><span class="n">plotting</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span>
    <span class="s2">"Step"</span><span class="p">:</span> <span class="n">steps</span><span class="p">,</span>
    <span class="s2">"Generator Loss"</span><span class="p">:</span> <span class="n">generator_losses</span><span class="p">,</span>
    <span class="s2">"Discriminator Loss"</span><span class="p">:</span> <span class="n">discriminator_losses</span>
<span class="p">})</span>

<span class="n">best</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">plotting</span><span class="p">[</span><span class="s2">"Generator Loss"</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()]</span>
<span class="n">best_line</span> <span class="o">=</span> <span class="n">holoviews</span><span class="o">.</span><span class="n">VLine</span><span class="p">(</span><span class="n">best</span><span class="o">.</span><span class="n">Step</span><span class="p">)</span>
<span class="n">gen_plot</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"Step"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"Generator Loss"</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">blue</span><span class="p">)</span>
<span class="n">disc_plot</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"Step"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"Discriminator Loss"</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">red</span><span class="p">)</span>

<span class="n">plot</span> <span class="o">=</span> <span class="p">(</span><span class="n">gen_plot</span> <span class="o">*</span> <span class="n">disc_plot</span> <span class="o">*</span> <span class="n">best_line</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">"Training Losses"</span><span class="p">,</span>
                                               <span class="n">height</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
                                               <span class="n">width</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                                               <span class="n">ylabel</span><span class="o">=</span><span class="s2">"Loss"</span><span class="p">,</span>
                                               <span class="n">fontscale</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">fontscale</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">Embed</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">"losses"</span><span class="p">)()</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
<object data="posts/gans/cnn-gan/losses.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object></div>
</div>
</div>
<div class="outline-2" id="outline-container-org925156c">
<h2 id="org925156c">End</h2>
<div class="outline-text-2" id="text-org925156c"></div>
<div class="outline-3" id="outline-container-orgaa5233f">
<h3 id="orgaa5233f">Sources</h3>
<div class="outline-text-3" id="text-orgaa5233f">
<ul class="org-ul">
<li>Radford A, Metz L, Chintala S. Unsupervised representation learning with deep convolutional generative adversarial networks. arXiv preprint arXiv:1511.06434. 2015 Nov 19. (<a href="https://arxiv.org/pdf/1511.06434v1.pdf">PDF</a>)</li>
</ul>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/pytorch/pytorch-linear-regression/index.html">PyTorch Linear Regression</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/pytorch/pytorch-linear-regression/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-04-10T16:05:44-07:00" itemprop="datePublished" title="2021-04-10 16:05">2021-04-10 16:05</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/pytorch/pytorch-linear-regression/index.html#orgb0f73ce">Beginning</a>
<ul>
<li><a href="posts/pytorch/pytorch-linear-regression/index.html#org399e4b3">Imports</a></li>
<li><a href="posts/pytorch/pytorch-linear-regression/index.html#org1636efc">Set Up</a></li>
</ul>
</li>
<li><a href="posts/pytorch/pytorch-linear-regression/index.html#org118f7f4">Middle</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgb0f73ce">
<h2 id="orgb0f73ce">Beginning</h2>
<div class="outline-text-2" id="text-orgb0f73ce"></div>
<div class="outline-3" id="outline-container-org399e4b3">
<h3 id="org399e4b3">Imports</h3>
<div class="outline-text-3" id="text-org399e4b3">
<div class="highlight">
<pre><span></span><span class="c1"># python</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="c1"># pypi</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">DataLoader</span>

<span class="kn">import</span> <span class="nn">hvplot.pandas</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="c1"># local stuff</span>
<span class="kn">from</span> <span class="nn">graeae</span> <span class="kn">import</span> <span class="n">EmbedHoloviews</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org1636efc">
<h3 id="org1636efc">Set Up</h3>
<div class="outline-text-3" id="text-org1636efc">
<div class="highlight">
<pre><span></span><span class="n">random_generator</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">2021</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">slug</span> <span class="o">=</span> <span class="s2">"pytorch-linear-regression"</span>
<span class="n">Embed</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="sa">f</span><span class="s2">"files/posts/pytorch/</span><span class="si">{</span><span class="n">slug</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">Plot</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"Plot"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"width"</span><span class="p">,</span> <span class="s2">"height"</span><span class="p">,</span> <span class="s2">"fontscale"</span><span class="p">,</span> <span class="s2">"tan"</span><span class="p">,</span> <span class="s2">"blue"</span><span class="p">,</span> <span class="s2">"red"</span><span class="p">])</span>
<span class="n">PLOT</span> <span class="o">=</span> <span class="n">Plot</span><span class="p">(</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">900</span><span class="p">,</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">750</span><span class="p">,</span>
    <span class="n">fontscale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">tan</span><span class="o">=</span><span class="s2">"#ddb377"</span><span class="p">,</span>
    <span class="n">blue</span><span class="o">=</span><span class="s2">"#4687b7"</span><span class="p">,</span>
    <span class="n">red</span><span class="o">=</span><span class="s2">"#ce7b6d"</span><span class="p">,</span>
 <span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">uniform</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Create a random sample</span>

<span class="sd">    Args:</span>
<span class="sd">     start: lowest allowed value</span>
<span class="sd">     stop: highest allowed value</span>
<span class="sd">     shape: shape for the final array (just an int for single values)</span>
<span class="sd">     uniform: use the uniform distribution instead of the standard normal</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="n">uniform</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="n">random_generator</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="n">random_generator</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org118f7f4">
<h2 id="org118f7f4">Middle</h2>
<div class="outline-text-2" id="text-org118f7f4">
<div class="highlight">
<pre><span></span><span class="n">SAMPLES</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">X_RANGE</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">x_values</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="o">-</span><span class="n">X_RANGE</span><span class="p">,</span> <span class="n">X_RANGE</span><span class="p">,</span> <span class="n">SAMPLES</span><span class="p">)</span>
<span class="n">SLOPE</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">INTERCEPT</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SAMPLES</span><span class="p">,</span> <span class="n">uniform</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">y_values</span> <span class="o">=</span> <span class="n">SLOPE</span> <span class="o">*</span> <span class="n">x_values</span> <span class="o">+</span> <span class="n">INTERCEPT</span> <span class="o">+</span> <span class="n">noise</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">data_frame</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">x_values</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">y_values</span><span class="p">))</span>
<span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">x_values</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x_values</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">line_frame</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
    <span class="nb">dict</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">],</span>
         <span class="n">Y</span><span class="o">=</span><span class="p">[</span><span class="n">SLOPE</span> <span class="o">*</span> <span class="n">first</span> <span class="o">+</span> <span class="n">INTERCEPT</span><span class="p">,</span>
            <span class="n">SLOPE</span> <span class="o">*</span> <span class="n">last</span> <span class="o">+</span> <span class="n">INTERCEPT</span><span class="p">]))</span>
<span class="n">line_plot</span> <span class="o">=</span> <span class="n">line_frame</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"X"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"Y"</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">blue</span><span class="p">)</span>
<span class="n">data_plot</span> <span class="o">=</span> <span class="n">data_frame</span><span class="o">.</span><span class="n">hvplot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"X"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"Y"</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">"Sample Data"</span><span class="p">,</span>
                                      <span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">tan</span><span class="p">)</span>
<span class="n">plot</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_plot</span> <span class="o">*</span> <span class="n">line_plot</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
    <span class="n">height</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
    <span class="n">width</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
    <span class="n">fontscale</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">fontscale</span>
<span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">Embed</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">"sample_data"</span><span class="p">)()</span>
</pre></div>
<object data="posts/pytorch/pytorch-linear-regression/sample_data.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">XY</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">{</span><span class="s2">"x"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s2">"y"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">index</span><span class="p">]}</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">dataset</span> <span class="o">=</span> <span class="n">XY</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/gans/mnist-gan/index.html">MNIST GAN</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/gans/mnist-gan/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-04-06T17:48:17-07:00" itemprop="datePublished" title="2021-04-06 17:48">2021-04-06 17:48</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/gans/mnist-gan/index.html#org4711200">Beginning</a>
<ul>
<li><a href="posts/gans/mnist-gan/index.html#org9019c5c">Imports</a></li>
<li><a href="posts/gans/mnist-gan/index.html#orgddf03b9">Some Setup</a></li>
</ul>
</li>
<li><a href="posts/gans/mnist-gan/index.html#org3980cee">Middle</a>
<ul>
<li><a href="posts/gans/mnist-gan/index.html#org84f5f6b">The MNIST Dataset</a></li>
<li><a href="posts/gans/mnist-gan/index.html#org316991a">The Generator</a>
<ul>
<li><a href="posts/gans/mnist-gan/index.html#org8c3d8cf">Verify the generator block function</a></li>
<li><a href="posts/gans/mnist-gan/index.html#orgfb39bcb">Building the Generator Class</a></li>
<li><a href="posts/gans/mnist-gan/index.html#orgc33ed75">Verify the Generator Class</a></li>
</ul>
</li>
<li><a href="posts/gans/mnist-gan/index.html#org67be30a">Noise</a>
<ul>
<li><a href="posts/gans/mnist-gan/index.html#orgd1417f6">Verify the noise vector function</a></li>
</ul>
</li>
<li><a href="posts/gans/mnist-gan/index.html#orga75b6c0">The Discriminator</a>
<ul>
<li><a href="posts/gans/mnist-gan/index.html#org539b485">Verify the discriminator block function</a></li>
<li><a href="posts/gans/mnist-gan/index.html#orge111513">The Discriminator Class</a></li>
</ul>
</li>
<li><a href="posts/gans/mnist-gan/index.html#org26876d7">Training</a>
<ul>
<li><a href="posts/gans/mnist-gan/index.html#orgc3918ee">Set your parameters</a></li>
<li><a href="posts/gans/mnist-gan/index.html#org6047182">Load MNIST dataset as tensors</a></li>
<li><a href="posts/gans/mnist-gan/index.html#org7ad8569">Generator Loss</a></li>
<li><a href="posts/gans/mnist-gan/index.html#org8c598fa">All Together</a></li>
</ul>
</li>
<li><a href="posts/gans/mnist-gan/index.html#orge873e41">Looking at the Final model.</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org4711200">
<h2 id="org4711200">Beginning</h2>
<div class="outline-text-2" id="text-org4711200"></div>
<div class="outline-3" id="outline-container-org9019c5c">
<h3 id="org9019c5c">Imports</h3>
<div class="outline-text-3" id="text-org9019c5c">
<div class="highlight">
<pre><span></span><span class="c1"># python</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># from pypi</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">transforms</span>
<span class="kn">from</span> <span class="nn">torchvision.datasets</span> <span class="kn">import</span> <span class="n">MNIST</span>
<span class="kn">from</span> <span class="nn">torchvision.utils</span> <span class="kn">import</span> <span class="n">make_grid</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>

<span class="kn">import</span> <span class="nn">hvplot.pandas</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># local code</span>
<span class="kn">from</span> <span class="nn">graeae</span> <span class="kn">import</span> <span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">Timer</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgddf03b9">
<h3 id="orgddf03b9">Some Setup</h3>
<div class="outline-text-3" id="text-orgddf03b9">
<p>First we'll set the manual seed to make this reproducible.</p>
<div class="highlight">
<pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
<p>This is a convenience object to time the training.</p>
<div class="highlight">
<pre><span></span><span class="n">TIMER</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
</pre></div>
<p>This is for plotting.</p>
<div class="highlight">
<pre><span></span><span class="n">slug</span> <span class="o">=</span> <span class="s2">"mnist-gan"</span>

<span class="n">Embed</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="sa">f</span><span class="s2">"files/posts/gans/</span><span class="si">{</span><span class="n">slug</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">Plot</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"Plot"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"width"</span><span class="p">,</span> <span class="s2">"height"</span><span class="p">,</span> <span class="s2">"fontscale"</span><span class="p">,</span>
                           <span class="s2">"tan"</span><span class="p">,</span> <span class="s2">"blue"</span><span class="p">,</span> <span class="s2">"red"</span><span class="p">,</span> <span class="s2">"sizing_mode"</span><span class="p">],</span>
                  <span class="n">defaults</span><span class="o">=</span><span class="p">[</span>
                      <span class="mi">900</span><span class="p">,</span>
                      <span class="mi">556</span><span class="p">,</span>
                      <span class="mi">2</span><span class="p">,</span>
                      <span class="s2">"#ddb377"</span><span class="p">,</span>
                      <span class="s2">"#4687b7"</span><span class="p">,</span>
                      <span class="s2">"#ce7b6d"</span><span class="p">,</span>
                      <span class="s2">"scale_both"</span><span class="p">,</span>
                  <span class="p">])()</span>

<span class="n">GANParts</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"GANParts"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"generator"</span><span class="p">,</span> <span class="s2">"generator_optimizer"</span><span class="p">,</span>
                                   <span class="s2">"discriminator"</span><span class="p">,</span> <span class="s2">"discriminator_optimizer"</span><span class="p">])</span>

<span class="n">PlotData</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"PlotData"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"steps"</span><span class="p">,</span> <span class="s2">"generator_losses"</span><span class="p">,</span> <span class="s2">"discriminator_losses"</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org3980cee">
<h2 id="org3980cee">Middle</h2>
<div class="outline-text-2" id="text-org3980cee"></div>
<div class="outline-3" id="outline-container-org84f5f6b">
<h3 id="org84f5f6b">The MNIST Dataset</h3>
<div class="outline-text-3" id="text-org84f5f6b">
<p>The training images we will be using are from a dataset called <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>. The dataset contains 60,000 images of handwritten digits, from 0 to 9.</p>
<p>The images are 28 pixels x 28 pixels in size. The small size of its images makes MNIST ideal for simple training. Additionally, these images are also in black-and-white so only one dimension, or "color channel", is needed to represent them. Pytorch has a <a href="https://pytorch.org/vision/0.8/datasets.html#mnist">version of it</a> ready-made for their system so we'll use theirs.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org316991a">
<h3 id="org316991a">The Generator</h3>
<div class="outline-text-3" id="text-org316991a">
<p>The first step is to build the generator component.</p>
<p>We'll start by creating a function to make a single layer/block for the generator's neural network. Each block should include a <a href="https://pytorch.org/docs/stable/generated/torch.nn.Linear.html">linear transformation</a> (\(y=xA^T + b\)) to the input to another shape, <a href="https://pytorch.org/docs/stable/generated/torch.nn.BatchNorm1d.html">batch normalization</a> for stabilization, and finally a non-linear activation function (<a href="https://pytorch.org/docs/master/generated/torch.nn.ReLU.html">ReLU</a> in this case).</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">generator_block</span><span class="p">(</span><span class="n">input_features</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">output_features</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Creates a block of the generator's neural network</span>

<span class="sd">    Args:</span>
<span class="sd">      input_features: the dimension of the input vector</span>
<span class="sd">      output_features: the dimension of the output vector</span>

<span class="sd">    Returns:</span>
<span class="sd">       a generator neural network layer, with a linear transformation </span>
<span class="sd">         followed by a batch normalization and then a relu activation</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">input_features</span><span class="p">,</span> <span class="n">output_features</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm1d</span><span class="p">(</span><span class="n">output_features</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>
</pre></div>
</div>
<div class="outline-4" id="outline-container-org8c3d8cf">
<h4 id="org8c3d8cf">Verify the generator block function</h4>
<div class="outline-text-4" id="text-org8c3d8cf">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_gen_block</span><span class="p">(</span><span class="n">in_features</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">out_features</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                   <span class="n">test_rows</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Test the generator block creator</span>

<span class="sd">    Args:</span>
<span class="sd">     in_features: number of features for the block input</span>
<span class="sd">     out_features: the final number of features for it to output</span>
<span class="sd">     test_rows: how many rows to put in the test Tensor</span>

<span class="sd">    Raises:</span>
<span class="sd">     AssertionError: something isn't right</span>
<span class="sd">    """</span>
    <span class="n">block</span> <span class="o">=</span> <span class="n">generator_block</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span>

    <span class="c1"># Check the three parts</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm1d</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span>

    <span class="c1"># Check the output shape</span>
    <span class="n">test_output</span> <span class="o">=</span> <span class="n">block</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">test_rows</span><span class="p">,</span> <span class="n">in_features</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">test_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">test_rows</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span>

    <span class="c1"># check the normalization</span>
    <span class="k">assert</span> <span class="mf">0.65</span> <span class="o">&gt;</span> <span class="n">test_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.55</span>
    <span class="k">return</span>

<span class="n">test_gen_block</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="n">test_gen_block</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgfb39bcb">
<h4 id="orgfb39bcb">Building the Generator Class</h4>
<div class="outline-text-4" id="text-orgfb39bcb">
<p>Now that we have the block-builder we can define our Generator network. It's going to contain a sequence of blocks output by our block-building function and a final two layers that use the linear transformation again, but don't apply normalization and use a <a href="https://pytorch.org/docs/master/generated/torch.nn.Sigmoid.html">Sigmoid Function</a> instead of the ReLU. Each block will have an output double that of the previous one.</p>
<div class="figure" id="org0fe9673">
<p><img alt="generator.png" src="posts/gans/mnist-gan/generator.png"></p>
</div>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Generator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Generator Class</span>

<span class="sd">    Args:</span>
<span class="sd">      input_dimension: the dimension of the noise vector</span>
<span class="sd">      image_dimension: the dimension of the images, fitted for the dataset used</span>
<span class="sd">        (MNIST images are 28 x 28 = 784 so that is the default)</span>
<span class="sd">      hidden_dimension: the initial hidden-layer dimension</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">image_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">784</span><span class="p">,</span>
                 <span class="n">hidden_dimension</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">generator_block</span><span class="p">(</span><span class="n">input_dimension</span><span class="p">,</span> <span class="n">hidden_dimension</span><span class="p">),</span>
            <span class="n">generator_block</span><span class="p">(</span><span class="n">hidden_dimension</span><span class="p">,</span> <span class="n">hidden_dimension</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">generator_block</span><span class="p">(</span><span class="n">hidden_dimension</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hidden_dimension</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">generator_block</span><span class="p">(</span><span class="n">hidden_dimension</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">hidden_dimension</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_dimension</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">image_dimension</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">       Method for a forward pass of the generator</span>

<span class="sd">       Args:</span>
<span class="sd">        noise: a noise tensor with dimensions (n_samples, z_dim)</span>

<span class="sd">       Returns: </span>
<span class="sd">        generated images.</span>
<span class="sd">       """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgc33ed75">
<h4 id="orgc33ed75">Verify the Generator Class</h4>
<div class="outline-text-4" id="text-orgc33ed75">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_generator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">im_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                   <span class="n">num_test</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Test the Generator Class</span>

<span class="sd">    Args:</span>
<span class="sd">     z_dim: the size of the input</span>
<span class="sd">     im_dim: the size of the image</span>
<span class="sd">     hidden_dim: the size of the initial hidden layer</span>

<span class="sd">    Raises:</span>
<span class="sd">     AssertionError: something is wrong</span>
<span class="sd">    """</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">im_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">)</span><span class="o">.</span><span class="n">generator</span>

    <span class="c1"># Check there are six modules in the sequential part</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
    <span class="n">test_output</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>

    <span class="c1"># Check that the output shape is correct</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">test_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">im_dim</span><span class="p">)</span>

    <span class="c1"># Chechk the output</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">test_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">"Make sure to use a sigmoid"</span>
    <span class="k">assert</span> <span class="n">test_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">"Don't use a block in your solution"</span>
    <span class="k">assert</span> <span class="mf">0.15</span> <span class="o">&gt;</span> <span class="n">test_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.05</span><span class="p">,</span> <span class="s2">"Don't use batchnorm here"</span>
    <span class="k">return</span>

<span class="n">test_generator</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">test_generator</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org67be30a">
<h3 id="org67be30a">Noise</h3>
<div class="outline-text-3" id="text-org67be30a">
<p>To be able to use the generator, we will need to be able to create noise vectors. The noise vector <code>z</code> has the important role of making sure the images generated from the same class don't all look the same – think of it as a random seed. You will generate it randomly using PyTorch by sampling random numbers from the normal distribution. Since multiple images will be processed per pass, you will generate all the noise vectors at once.</p>
<p>Note that whenever you create a new tensor using torch.ones, torch.zeros, or <a href="https://pytorch.org/docs/master/generated/torch.randn.html">torch.randn</a>, you either need to create it on the target device, e.g. <code>torch.ones(3, 3, device=device)</code>, or move it onto the target device using <code>torch.ones(3, 3).to(device)</code>. You do not need to do this if you're creating a tensor by manipulating another tensor or by using a variation that defaults the device to the input, such as <code>torch.ones_like</code>. In general, use <code>torch.ones_like</code> and <code>torch.zeros_like</code> instead of <code>torch.ones</code> or <code>torch.zeros</code> where possible.</p>
<div class="highlight">
<pre><span></span><span class="n">get_noise</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">"cuda"</span><span class="p">)</span>
<span class="c1"># def get_noise(n_samples: int, z_dim: int, device='cuda') -&gt; torch.Tensor:</span>
<span class="c1">#     """create noise vectors</span>
<span class="c1"># </span>
<span class="c1">#     Args:</span>
<span class="c1">#         n_samples: the number of samples to generate, a scalar</span>
<span class="c1">#         z_dim: the dimension of the noise vector, a scalar</span>
<span class="c1">#         device: the device type</span>
<span class="c1">#     """</span>
<span class="c1">#     return torch.randn(n_samples, z_dim, device=device)</span>
</pre></div>
</div>
<div class="outline-4" id="outline-container-orgd1417f6">
<h4 id="orgd1417f6">Verify the noise vector function</h4>
<div class="outline-text-4" id="text-orgd1417f6">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_get_noise</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">'cpu'</span><span class="p">):</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">get_noise</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># Make sure a normal distribution was used</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">noise</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="n">test_get_noise</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orga75b6c0">
<h3 id="orga75b6c0">The Discriminator</h3>
<div class="outline-text-3" id="text-orga75b6c0">
<p>The second component that you need to construct is the discriminator. As with the generator component, you will start by creating a function that builds a neural network block for the discriminator.</p>
<p><b>Note: You use <a href="https://pytorch.org/docs/master/generated/torch.nn.LeakyReLU.html">leaky ReLUs</a> to prevent the "dying ReLU" problem, which refers to the phenomenon where the parameters stop changing due to consistently negative values passed to a ReLU, which result in a zero gradient.</b></p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_discriminator_block</span><span class="p">(</span><span class="n">input_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                            <span class="n">negative_slope</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Create the Discriminator block</span>

<span class="sd">    Args:</span>
<span class="sd">      input_dim: the dimension of the input vector, a scalar</span>
<span class="sd">      output_dim: the dimension of the output vector, a scalar</span>
<span class="sd">      negative_slope: angle for the negative slope</span>

<span class="sd">    Returns:</span>
<span class="sd">       a discriminator neural network layer, with a linear transformation </span>
<span class="sd">         followed by an nn.LeakyReLU activation with negative slope of 0.2 </span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">input_dim</span><span class="p">,</span> <span class="n">output_dim</span><span class="p">),</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="n">negative_slope</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
</div>
<div class="outline-4" id="outline-container-org539b485">
<h4 id="org539b485">Verify the discriminator block function</h4>
<div class="outline-text-4" id="text-org539b485">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_disc_block</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="n">out_features</span><span class="p">,</span> <span class="n">num_test</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
    <span class="n">block</span> <span class="o">=</span> <span class="n">get_discriminator_block</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span>

    <span class="c1"># Check there are two parts</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">in_features</span><span class="p">)</span>
    <span class="n">test_output</span> <span class="o">=</span> <span class="n">block</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>

    <span class="c1"># Check that the shape is right</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">test_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span>

    <span class="c1"># Check that the LeakyReLU slope is about 0.2</span>
    <span class="k">assert</span> <span class="o">-</span><span class="n">test_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">test_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="o">-</span><span class="n">test_output</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">test_output</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.3</span>
    <span class="k">assert</span> <span class="n">test_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.3</span>
    <span class="k">assert</span> <span class="n">test_output</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span>

<span class="n">test_disc_block</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
<span class="n">test_disc_block</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orge111513">
<h4 id="orge111513">The Discriminator Class</h4>
<div class="outline-text-4" id="text-orge111513">
<p>The discriminator class holds 2 values:</p>
<ul class="org-ul">
<li>The image dimension</li>
<li>The hidden dimension</li>
</ul>
<p>The discriminator will build a neural network with 4 layers. It will start with the image tensor and transform it until it returns a single number (1-dimension tensor) output. This output classifies whether an image is fake or real. Note that you do not need a sigmoid after the output layer since it is included in the loss function. Finally, to use your discrimator's neural network you are given a forward pass function that takes in an image tensor to be classified.</p>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Discriminator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""The Discriminator Class</span>

<span class="sd">    Args:</span>
<span class="sd">       im_dim: the dimension of the images, fitted for the dataset used, a scalar</span>
<span class="sd">           (MNIST images are 28x28 = 784 so that is your default)</span>
<span class="sd">       hidden_dim: the inner dimension, a scalar</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">784</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">128</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">get_discriminator_block</span><span class="p">(</span><span class="n">im_dim</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">get_discriminator_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">get_discriminator_block</span><span class="p">(</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""forward pass of the discriminator</span>

<span class="sd">       Args:</span>
<span class="sd">           image: a flattened image tensor with dimension (im_dim)</span>

<span class="sd">       Returns a 1-dimension tensor representing fake/real.</span>
<span class="sd">       """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<ul class="org-ul">
<li><a id="orge4bf60a"></a>Verify the discriminator class<br>
<div class="outline-text-5" id="text-orge4bf60a">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_discriminator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">,</span> <span class="n">num_test</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>

    <span class="n">disc</span> <span class="o">=</span> <span class="n">Discriminator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">)</span><span class="o">.</span><span class="n">disc</span>

    <span class="c1"># Check there are three parts</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>

    <span class="c1"># Check the linear layer is correct</span>
    <span class="n">test_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
    <span class="n">test_output</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">test_output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Don't use a block</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">disc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">)</span>

<span class="n">test_discriminator</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">test_discriminator</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org26876d7">
<h3 id="org26876d7">Training</h3>
<div class="outline-text-3" id="text-org26876d7">
<p>First, you will set your parameters:</p>
<ul class="org-ul">
<li>criterion: the loss function (<a href="https://pytorch.org/docs/stable/generated/torch.nn.BCEWithLogitsLoss.html?highlight=bcewithlogitsloss">BCEWithLogitsLoss</a></li>
<li>n_epochs: the number of times you iterate through the entire dataset when training</li>
<li>z_dim: the dimension of the noise vector</li>
<li>display_step: how often to display/visualize the images</li>
<li>batch_size: the number of images per forward/backward pass</li>
<li>lr: the learning rate</li>
<li>device: the device type, here using a GPU (which runs CUDA), not CPU</li>
</ul>
<p>Next, you will load the MNIST dataset as tensors using a dataloader.</p>
</div>
<div class="outline-4" id="outline-container-orgc3918ee">
<h4 id="orgc3918ee">Set your parameters</h4>
<div class="outline-text-4" id="text-orgc3918ee">
<div class="highlight">
<pre><span></span><span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">()</span>
<span class="n">z_dim</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">lr</span> <span class="o">=</span> <span class="mf">0.00001</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6047182">
<h4 id="org6047182">Load MNIST dataset as tensors</h4>
<div class="outline-text-4" id="text-org6047182">
<div class="highlight">
<pre><span></span><span class="n">data_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">"~/data/datasets/pytorch/"</span><span class="p">)</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>
<span class="n">dataloader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">MNIST</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">data_path</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">()),</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>Now, you can initialize your generator, discriminator, and optimizers. Note that each optimizer only takes the parameters of one particular model, since we want each optimizer to optimize only one of the models.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">build_parts</span><span class="p">(</span><span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="n">z_dim</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GANParts</span><span class="p">:</span>
    <span class="n">device</span> <span class="o">=</span> <span class="s2">"cuda"</span>
    <span class="n">generator</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">gen_optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">generator</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">)</span>
    <span class="n">discriminator</span> <span class="o">=</span> <span class="n">Discriminator</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
    <span class="n">disc_optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">discriminator</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">learning_rate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GANParts</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">gen_optimizer</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">,</span> <span class="n">disc_optimizer</span><span class="p">)</span>

<span class="n">gen</span><span class="p">,</span> <span class="n">gen_opt</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">disc_opt</span> <span class="o">=</span> <span class="n">build_parts</span><span class="p">()</span>
</pre></div>
<p>This next bit is from <a href="https://stackoverflow.com/questions/48152674/how-to-check-if-pytorch-is-using-the-gpu">https://stackoverflow.com/questions/48152674/how-to-check-if-pytorch-is-using-the-gpu</a>.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">check_gpu</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
    <span class="n">current_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_device</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">current_device</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device_count</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_device_name</span><span class="p">(</span><span class="n">current_device</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'Memory Usage:'</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Allocated: </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory_allocated</span><span class="p">(</span><span class="n">current_device</span><span class="p">)</span><span class="o">/</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">"</span>
          <span class="s2">" MB"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Cached:   </span><span class="si">{</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory_reserved</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> MB"</span><span class="p">)</span>
    <span class="k">return</span>

<span class="n">check_gpu</span><span class="p">()</span>
</pre></div>
<pre class="example">
0
1
NVIDIA GeForce GTX 1070 Ti
Memory Usage:
Allocated: 7.92138671875 MB
Cached:   22.0 MB
</pre>
<p>Before you train your GAN, you will need to create functions to calculate the discriminator's loss and the generator's loss. This is how the discriminator and generator will know how they are doing and improve themselves. Since the generator is needed when calculating the discriminator's loss, you will need to call .detach() on the generator result to ensure that only the discriminator is updated!</p>
<p>Remember that you have already defined a loss function earlier (<code>criterion</code>) and you are encouraged to use <a href="https://pytorch.org/docs/master/generated/torch.ones_like.html?highlight=ones_like#torch.ones_like"><code>torch.ones_like</code></a> and <a href="https://pytorch.org/docs/master/generated/torch.zeros_like.html?highlight=zeros_like#torch.zeros_like"><code>torch.zeros_like</code></a> instead of <code>torch.ones</code> or <code>torch.zeros</code>. If you use <code>torch.ones</code> or <code>torch.zeros</code>, you'll need to pass <code>device=device</code> to them.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_disc_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">disc</span><span class="p">:</span> <span class="n">Discriminator</span><span class="p">,</span>
                  <span class="n">criterion</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">,</span>
                  <span class="n">real</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                  <span class="n">num_images</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                  <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">"cuda"</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Get the loss of the discriminator given inputs.</span>

<span class="sd">    Args:</span>
<span class="sd">       gen: the generator model, which returns an image given z-dimensional noise</span>
<span class="sd">       disc: the discriminator model, which returns a single-dimensional prediction of real/fake</span>
<span class="sd">       criterion: the loss function, which should be used to compare </span>
<span class="sd">              the discriminator's predictions to the ground truth reality of the images </span>
<span class="sd">              (e.g. fake = 0, real = 1)</span>
<span class="sd">       real: a batch of real images</span>
<span class="sd">       num_images: the number of images the generator should produce, </span>
<span class="sd">               which is also the length of the real images</span>
<span class="sd">       z_dim: the dimension of the noise vector, a scalar</span>
<span class="sd">       device: the device type</span>

<span class="sd">    Returns:</span>
<span class="sd">       disc_loss: a torch scalar loss value for the current batch</span>
<span class="sd">    """</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">fakes</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

    <span class="n">fake_prediction</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">fakes</span><span class="p">)</span>
    <span class="n">fake_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">fake_prediction</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fake_prediction</span><span class="p">))</span>

    <span class="n">real_prediction</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
    <span class="n">real_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">real_prediction</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">real_prediction</span><span class="p">))</span>
    <span class="n">disc_loss</span> <span class="o">=</span> <span class="p">(</span><span class="n">fake_loss</span> <span class="o">+</span> <span class="n">real_loss</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">disc_loss</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_disc_reasonable</span><span class="p">(</span><span class="n">num_images</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Don't use explicit casts to cuda - use the device argument</span>
    <span class="kn">import</span> <span class="nn">inspect</span><span class="o">,</span> <span class="nn">re</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">get_disc_loss</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">"to\(.cuda.\)"</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">"\.cuda\(\)"</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="n">z_dim</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span> <span class="c1"># Multiply</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
    <span class="n">disc_loss</span> <span class="o">=</span> <span class="n">get_disc_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="s1">'cpu'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">disc_loss</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">)</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span> <span class="c1"># Multiply</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">get_disc_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="s1">'cpu'</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">)</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span> <span class="c1"># Multiply</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">get_disc_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="s1">'cpu'</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">)</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">disc</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">disc</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">disc_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">disc</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">disc_loss</span> <span class="o">=</span> <span class="n">get_disc_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="s1">'cpu'</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">disc_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">disc</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="mf">11.25</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mf">3.75</span><span class="p">))</span>
    <span class="k">return</span>

<span class="n">test_disc_reasonable</span><span class="p">()</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">device</span> <span class="o">=</span> <span class="s2">"cuda"</span>
<span class="k">def</span> <span class="nf">test_disc_loss</span><span class="p">(</span><span class="n">max_tests</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">z_dim</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">gen_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">Discriminator</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
    <span class="n">disc_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">disc</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
    <span class="n">num_steps</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">real</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
        <span class="n">cur_batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>
        <span class="n">real</span> <span class="o">=</span> <span class="n">real</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cur_batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

        <span class="c1">### Update discriminator ###</span>
        <span class="c1"># Zero out the gradient before backpropagation</span>
        <span class="n">disc_opt</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

        <span class="c1"># Calculate discriminator loss</span>
        <span class="n">disc_loss</span> <span class="o">=</span> <span class="n">get_disc_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">disc_loss</span> <span class="o">-</span> <span class="mf">0.68</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">disc_loss</span>

        <span class="c1"># Update gradients</span>
        <span class="n">disc_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Check that they detached correctly</span>
        <span class="k">assert</span> <span class="n">gen</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="c1"># Update optimizer</span>
        <span class="n">old_weight</span> <span class="o">=</span> <span class="n">disc</span><span class="o">.</span><span class="n">disc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">disc_opt</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="n">new_weight</span> <span class="o">=</span> <span class="n">disc</span><span class="o">.</span><span class="n">disc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Check that some discriminator weights changed</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">old_weight</span><span class="p">,</span> <span class="n">new_weight</span><span class="p">))</span>
        <span class="n">num_steps</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num_steps</span> <span class="o">&gt;=</span> <span class="n">max_tests</span><span class="p">:</span>
            <span class="k">break</span>

<span class="n">test_disc_loss</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org7ad8569">
<h4 id="org7ad8569">Generator Loss</h4>
<div class="outline-text-4" id="text-org7ad8569">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_gen_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">:</span> <span class="n">Generator</span><span class="p">,</span>
                 <span class="n">disc</span><span class="p">:</span> <span class="n">Discriminator</span><span class="p">,</span>
                 <span class="n">criterion</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">BCEWithLogitsLoss</span><span class="p">,</span>
                 <span class="n">num_images</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                 <span class="n">z_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">"cuda"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Calculates the loss for the generator</span>

<span class="sd">    Args:</span>
<span class="sd">       gen: the generator model, which returns an image given z-dimensional noise</span>
<span class="sd">       disc: the discriminator model, which returns a single-dimensional prediction of real/fake</span>
<span class="sd">       criterion: the loss function, which should be used to compare </span>
<span class="sd">              the discriminator's predictions to the ground truth reality of the images </span>
<span class="sd">              (e.g. fake = 0, real = 1)</span>
<span class="sd">       num_images: the number of images the generator should produce, </span>
<span class="sd">               which is also the length of the real images</span>
<span class="sd">       z_dim: the dimension of the noise vector, a scalar</span>
<span class="sd">       device: the device type</span>
<span class="sd">    Returns:</span>
<span class="sd">       gen_loss: a torch scalar loss value for the current batch</span>
<span class="sd">    """</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">fakes</span> <span class="o">=</span> <span class="n">gen</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
    <span class="n">fake_prediction</span> <span class="o">=</span> <span class="n">disc</span><span class="p">(</span><span class="n">fakes</span><span class="p">)</span>
    <span class="n">gen_loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">fake_prediction</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">fake_prediction</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">gen_loss</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_gen_reasonable</span><span class="p">(</span><span class="n">num_images</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Don't use explicit casts to cuda - use the device argument</span>
    <span class="kn">import</span> <span class="nn">inspect</span><span class="o">,</span> <span class="nn">re</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">get_gen_loss</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">"to\(.cuda.\)"</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">"\.cuda\(\)"</span><span class="p">,</span> <span class="n">lines</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="n">z_dim</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span> <span class="c1"># Multiply</span>
    <span class="n">gen_loss_tensor</span> <span class="o">=</span> <span class="n">get_gen_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="s1">'cpu'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gen_loss_tensor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">)</span>
    <span class="c1">#Verify shape. Related to gen_noise parametrization</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gen_loss_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
    <span class="n">criterion</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mul</span> <span class="c1"># Multiply</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">gen_loss_tensor</span> <span class="o">=</span> <span class="n">get_gen_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="s1">'cpu'</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gen_loss_tensor</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">)</span>
    <span class="c1">#Verify shape. Related to gen_noise parametrization</span>
    <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gen_loss_tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">)</span>
    <span class="k">return</span>
<span class="n">test_gen_reasonable</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_gen_loss</span><span class="p">(</span><span class="n">num_images</span><span class="p">):</span>
    <span class="n">z_dim</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">(</span><span class="n">z_dim</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">gen_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>
    <span class="n">disc</span> <span class="o">=</span> <span class="n">Discriminator</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span> 
    <span class="n">disc_opt</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">disc</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">lr</span><span class="p">)</span>

    <span class="n">gen_loss</span> <span class="o">=</span> <span class="n">get_gen_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">num_images</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

    <span class="c1"># Check that the loss is reasonable</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">gen_loss</span> <span class="o">-</span> <span class="mf">0.7</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.1</span>
    <span class="n">gen_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">old_weight</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">gen_opt</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
    <span class="n">new_weight</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">old_weight</span><span class="p">,</span> <span class="n">new_weight</span><span class="p">))</span>
<span class="n">test_gen_loss</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org8c598fa">
<h4 id="org8c598fa">All Together</h4>
<div class="outline-text-4" id="text-org8c598fa">
<p>For each epoch, you will process the entire dataset in batches. For every batch, you will need to update the discriminator and generator using their loss. Batches are sets of images that will be predicted on before the loss functions are calculated (instead of calculating the loss function after each image). Note that you may see a loss to be greater than 1, this is okay since binary cross entropy loss can be any positive number for a sufficiently confident wrong guess.</p>
<p>It’s also often the case that the discriminator will outperform the generator, especially at the start, because its job is easier. It's important that neither one gets too good (that is, near-perfect accuracy), which would cause the entire model to stop learning. Balancing the two models is actually remarkably hard to do in a standard GAN and something you will see more of in later lectures and assignments.</p>
<p>After you've submitted a working version with the original architecture, feel free to play around with the architecture if you want to see how different architectural choices can lead to better or worse GANs. For example, consider changing the size of the hidden dimension, or making the networks shallower or deeper by changing the number of layers.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">gen</span><span class="p">:</span> <span class="n">Generator</span><span class="o">=</span><span class="n">gen</span><span class="p">,</span>
          <span class="n">gen_opt</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="o">=</span><span class="n">gen_opt</span><span class="p">,</span>
          <span class="n">disc</span><span class="p">:</span> <span class="n">Discriminator</span><span class="o">=</span><span class="n">disc</span><span class="p">,</span>
          <span class="n">disc_opt</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="o">=</span><span class="n">disc_opt</span><span class="p">,</span>
          <span class="n">start_step</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlotData</span><span class="p">:</span>
    <span class="n">cur_step</span> <span class="o">=</span> <span class="n">start_step</span>
    <span class="n">mean_generator_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mean_discriminator_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">test_generator</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Whether the generator should be tested</span>
    <span class="n">gen_loss</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">error</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">display_step</span> <span class="o">=</span> <span class="mi">4100</span>
    <span class="n">generator_losses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">discriminator_losses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">with</span> <span class="n">TIMER</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>

            <span class="c1"># Dataloader returns the batches</span>
            <span class="k">for</span> <span class="n">real</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
                <span class="n">cur_batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">real</span><span class="p">)</span>

                <span class="c1"># Flatten the batch of real images from the dataset</span>
                <span class="n">real</span> <span class="o">=</span> <span class="n">real</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cur_batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

                <span class="c1">### Update discriminator ###</span>
                <span class="c1"># Zero out the gradients before backpropagation</span>
                <span class="n">disc_opt</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

                <span class="c1"># Calculate discriminator loss</span>
                <span class="n">disc_loss</span> <span class="o">=</span> <span class="n">get_disc_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

                <span class="c1"># Update gradients</span>
                <span class="n">disc_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Update optimizer</span>
                <span class="n">disc_opt</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

                <span class="c1"># For testing purposes, to keep track of the generator weights</span>
                <span class="k">if</span> <span class="n">test_generator</span><span class="p">:</span>
                    <span class="n">old_generator_weights</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

                <span class="c1">### Update generator ###</span>
                <span class="n">gen_opt</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
                <span class="n">gen_loss</span> <span class="o">=</span> <span class="n">get_gen_loss</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">cur_batch_size</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
                <span class="n">gen_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">retain_graph</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">gen_opt</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

                <span class="c1"># For testing purposes, to check that your code changes the generator weights</span>
                <span class="k">if</span> <span class="n">test_generator</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">lr</span> <span class="o">&gt;</span> <span class="mf">0.0000002</span> <span class="ow">or</span> <span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.0005</span> <span class="ow">and</span> <span class="n">epoch</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="o">!=</span> <span class="n">old_generator_weights</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">error</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">"Runtime tests have failed"</span><span class="p">)</span>

                <span class="c1"># Keep track of the average discriminator loss</span>
                <span class="n">mean_discriminator_loss</span> <span class="o">+=</span> <span class="n">disc_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">display_step</span>

                <span class="c1"># Keep track of the average generator loss</span>
                <span class="n">mean_generator_loss</span> <span class="o">+=</span> <span class="n">gen_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">display_step</span>

                <span class="k">if</span> <span class="n">cur_step</span> <span class="o">%</span> <span class="n">display_step</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cur_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Epoch </span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s2">, step </span><span class="si">{</span><span class="n">cur_step</span><span class="si">}</span><span class="s2">: Generator loss:"</span>
                            <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">mean_generator_loss</span><span class="si">}</span><span class="s2">, discriminator loss:"</span>
                            <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">mean_discriminator_loss</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                    <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_step</span><span class="p">)</span>
                    <span class="n">generator_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_generator_loss</span><span class="p">)</span>
                    <span class="n">discriminator_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_discriminator_loss</span><span class="p">)</span>

                    <span class="n">mean_generator_loss</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">mean_discriminator_loss</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">cur_step</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">PlotData</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span> <span class="n">generator_losses</span><span class="o">=</span><span class="n">generator_losses</span><span class="p">,</span>
                    <span class="n">discriminator_losses</span><span class="o">=</span><span class="n">discriminator_losses</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">train</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
<pre class="example">
Started: 2021-12-11 00:33:13.638946
Epoch 8, step 4100: Generator loss: 2.0296122446438143, discriminator loss: 0.20560982278207462
Ended: 2021-12-11 00:34:27.772860
Elapsed: 0:01:14.133914
PlotData(steps=[4100], generator_losses=[2.0296122446438143], discriminator_losses=[0.20560982278207462])
</pre>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">run_batch</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="n">GANParts</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">:</span> <span class="n">PlotData</span><span class="p">,</span>
              <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PlotData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Run a smaller batch of epochs</span>

<span class="sd">    Args:</span>
<span class="sd">     parts: the GAN parts</span>
<span class="sd">     plot_data: the accumulated output of the training</span>

<span class="sd">    Returns:</span>
<span class="sd">     updated plot_data</span>
<span class="sd">    """</span>
    <span class="n">next_step</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">plot_data</span><span class="o">.</span><span class="n">steps</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">plot_data</span><span class="o">.</span><span class="n">steps</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">gen</span><span class="o">=</span><span class="n">parts</span><span class="o">.</span><span class="n">generator</span><span class="p">,</span>
                   <span class="n">gen_opt</span><span class="o">=</span><span class="n">parts</span><span class="o">.</span><span class="n">generator_optimizer</span><span class="p">,</span>
                   <span class="n">disc</span><span class="o">=</span><span class="n">parts</span><span class="o">.</span><span class="n">discriminator</span><span class="p">,</span>
                   <span class="n">disc_opt</span><span class="o">=</span><span class="n">parts</span><span class="o">.</span><span class="n">discriminator_optimizer</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                   <span class="n">start_step</span><span class="o">=</span><span class="n">next_step</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PlotData</span><span class="p">(</span>
        <span class="n">steps</span><span class="o">=</span><span class="n">plot_data</span><span class="o">.</span><span class="n">steps</span> <span class="o">+</span> <span class="n">output</span><span class="o">.</span><span class="n">steps</span><span class="p">,</span>
        <span class="n">generator_losses</span><span class="o">=</span><span class="n">plot_data</span><span class="o">.</span><span class="n">generator_losses</span> <span class="o">+</span> <span class="n">output</span><span class="o">.</span><span class="n">generator_losses</span><span class="p">,</span>
        <span class="n">discriminator_losses</span><span class="o">=</span><span class="p">(</span><span class="n">plot_data</span><span class="o">.</span><span class="n">discriminator_losses</span> <span class="o">+</span>
                              <span class="n">output</span><span class="o">.</span><span class="n">discriminator_losses</span><span class="p">))</span>
</pre></div>
<p>At about one epoch a minute, this should take about an hour and forty minutes or so.</p>
<div class="highlight">
<pre><span></span><span class="n">parts</span> <span class="o">=</span> <span class="n">build_parts</span><span class="p">()</span>
<span class="n">plot_data</span> <span class="o">=</span> <span class="n">run_batch</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">PlotData</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[]))</span>
</pre></div>
<pre class="example" id="orgb115b8b">
Started: 2021-12-11 00:47:14.931061
Epoch 8, step 4100: Generator loss: 1.934377251819866, discriminator loss: 0.2229057149607244
Epoch 17, step 8200: Generator loss: 3.4881149883386517, discriminator loss: 0.09036333611371311
Epoch 26, step 12300: Generator loss: 3.79820193645431, discriminator loss: 0.07907055546234283
Epoch 34, step 16400: Generator loss: 3.5352928067416753, discriminator loss: 0.12281120490646158
Epoch 43, step 20500: Generator loss: 3.21601489741629, discriminator loss: 0.1628626244387976
Epoch 52, step 24600: Generator loss: 2.989254439458613, discriminator loss: 0.18208623294786722
Epoch 61, step 28700: Generator loss: 2.7631628133901764, discriminator loss: 0.22777474837695708
Epoch 69, step 32800: Generator loss: 2.628327419728768, discriminator loss: 0.24390439436566586
Epoch 78, step 36900: Generator loss: 2.5670700825714463, discriminator loss: 0.24794671018676115
Epoch 87, step 41000: Generator loss: 2.472670504349029, discriminator loss: 0.26582738677539414
Epoch 96, step 45100: Generator loss: 2.3724955604134528, discriminator loss: 0.2780200535131669
Ended: 2021-12-11 00:59:33.404832
Elapsed: 0:12:18.473771
</pre>
<p>Twelve minutes… something's wrong with my math (or my code).</p>
<div class="highlight">
<pre><span></span><span class="n">plot_data</span> <span class="o">=</span> <span class="n">run_batch</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org9cfa5a5">
Started: 2021-12-11 01:13:48.089630
Epoch 8, step 49200: Generator loss: 2.2106766842923546, discriminator loss: 0.30767942854180547
Epoch 17, step 53300: Generator loss: 2.053519683320349, discriminator loss: 0.3469244217182084
Epoch 26, step 57400: Generator loss: 1.8833183762213095, discriminator loss: 0.3716685724476485
Epoch 34, step 61500: Generator loss: 1.7962335860147725, discriminator loss: 0.388955959706772
Epoch 43, step 65600: Generator loss: 1.7297733351079438, discriminator loss: 0.39347998913468357
Epoch 52, step 69700: Generator loss: 1.6756027169634629, discriminator loss: 0.40696758046382825
Epoch 61, step 73800: Generator loss: 1.7340464807719738, discriminator loss: 0.391147572165583
Epoch 69, step 77900: Generator loss: 1.6250884978945666, discriminator loss: 0.4112582277960894
Epoch 78, step 82000: Generator loss: 1.5282696703294425, discriminator loss: 0.4417608343828005
Epoch 87, step 86100: Generator loss: 1.551421322909793, discriminator loss: 0.4309799511621639
Epoch 96, step 90200: Generator loss: 1.502451353887236, discriminator loss: 0.43569522036284997
Epoch 104, step 94300: Generator loss: 1.5355568281034093, discriminator loss: 0.4274125394515864
Epoch 113, step 98400: Generator loss: 1.515106762124273, discriminator loss: 0.4361268874203291
Epoch 122, step 102500: Generator loss: 1.4262471299345922, discriminator loss: 0.4538826259389165
Epoch 131, step 106600: Generator loss: 1.3722852372541716, discriminator loss: 0.46847428283313336
Epoch 139, step 110700: Generator loss: 1.30627704975082, discriminator loss: 0.4916798695195014
Epoch 148, step 114800: Generator loss: 1.3066031820744994, discriminator loss: 0.48832398747525635
Epoch 157, step 118900: Generator loss: 1.2358002482972494, discriminator loss: 0.5049220843794864
Epoch 166, step 123000: Generator loss: 1.2148369922434428, discriminator loss: 0.5165507747632705
Epoch 174, step 127100: Generator loss: 1.1939138480802867, discriminator loss: 0.5140434620365866
Epoch 183, step 131200: Generator loss: 1.1655712901092137, discriminator loss: 0.5210341898333737
Epoch 192, step 135300: Generator loss: 1.0877681193119135, discriminator loss: 0.5537625885663968
Epoch 201, step 139400: Generator loss: 1.1292353331461187, discriminator loss: 0.5308915733782256
Epoch 209, step 143500: Generator loss: 1.097566315502655, discriminator loss: 0.5411388381806799
Epoch 218, step 147600: Generator loss: 1.0757532430131274, discriminator loss: 0.5517329544628548
Epoch 227, step 151700: Generator loss: 1.0799634633267818, discriminator loss: 0.5458411719668192
Epoch 236, step 155800: Generator loss: 1.0768744062068984, discriminator loss: 0.5462928909935603
Epoch 244, step 159900: Generator loss: 1.038065175501311, discriminator loss: 0.5608314768788278
Epoch 253, step 164000: Generator loss: 1.0237846635173, discriminator loss: 0.5654601171176611
Epoch 262, step 168100: Generator loss: 0.9991180751236483, discriminator loss: 0.5736101391184627
Epoch 271, step 172200: Generator loss: 1.0070789654516565, discriminator loss: 0.5714522401516029
Epoch 279, step 176300: Generator loss: 0.9614028337670539, discriminator loss: 0.5910174207425695
Epoch 288, step 180400: Generator loss: 0.9706563392499603, discriminator loss: 0.5850461383781773
Epoch 297, step 184500: Generator loss: 0.9717842458661009, discriminator loss: 0.5814466277055627
Epoch 305, step 188600: Generator loss: 0.9541865834084969, discriminator loss: 0.5840334389413279
Epoch 314, step 192700: Generator loss: 0.9712330036628544, discriminator loss: 0.5782463719932038
Epoch 323, step 196800: Generator loss: 0.9551204285098255, discriminator loss: 0.5880173592596538
Epoch 332, step 200900: Generator loss: 0.9226158920584665, discriminator loss: 0.5996578313373941
Epoch 340, step 205000: Generator loss: 0.9246665488074481, discriminator loss: 0.597404850198001
Epoch 349, step 209100: Generator loss: 0.9608930256744725, discriminator loss: 0.5801783614260392
Epoch 358, step 213200: Generator loss: 0.9612123412766118, discriminator loss: 0.5802033745152197
Epoch 367, step 217300: Generator loss: 0.9180114618307212, discriminator loss: 0.5937960715264811
Epoch 375, step 221400: Generator loss: 0.9368741252364194, discriminator loss: 0.5900343924106617
Epoch 384, step 225500: Generator loss: 0.9440083874725718, discriminator loss: 0.5846795598762786
Epoch 393, step 229600: Generator loss: 0.9536703778330882, discriminator loss: 0.5829839877384473
Epoch 402, step 233700: Generator loss: 0.9294257469729658, discriminator loss: 0.5916450903909986
Epoch 410, step 237800: Generator loss: 0.9466903525445554, discriminator loss: 0.5856489780472574
Epoch 419, step 241900: Generator loss: 0.9522996573477257, discriminator loss: 0.5799181649743058
Epoch 428, step 246000: Generator loss: 0.9839635591972143, discriminator loss: 0.5714024179156216
Epoch 437, step 250100: Generator loss: 0.9648611798373641, discriminator loss: 0.5808709646216277
Epoch 445, step 254200: Generator loss: 0.9566089589712128, discriminator loss: 0.5805564494249301
Epoch 454, step 258300: Generator loss: 0.9783696506226937, discriminator loss: 0.5709307750914155
Epoch 463, step 262400: Generator loss: 0.9719752054098166, discriminator loss: 0.5762244856866391
Epoch 472, step 266500: Generator loss: 0.999251530417581, discriminator loss: 0.5657230390717329
Epoch 480, step 270600: Generator loss: 0.9960989969387296, discriminator loss: 0.5667149156113943
Epoch 489, step 274700: Generator loss: 1.0056089845953926, discriminator loss: 0.5628991482534059
Epoch 498, step 278800: Generator loss: 0.9715120762295836, discriminator loss: 0.5786686657042022
Ended: 2021-12-11 02:15:09.581779
Elapsed: 1:01:21.492149
</pre>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">hook</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
    <span class="n">figure</span> <span class="o">=</span> <span class="n">plot</span><span class="o">.</span><span class="n">state</span>
    <span class="n">figure</span><span class="p">[</span><span class="s2">"layout"</span><span class="p">][</span><span class="s2">"sizing_mode"</span><span class="p">]</span> <span class="o">=</span> <span class="n">Plot</span><span class="o">.</span><span class="n">sizing_mode</span>
    <span class="k">return</span>

<span class="k">def</span> <span class="nf">plot_losses</span><span class="p">(</span><span class="n">plot_data</span><span class="p">:</span> <span class="n">PlotData</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">"losses"</span><span class="p">,</span>
                <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">"Training Loss"</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Plot the losses in Holoviews</span>

<span class="sd">    Args:</span>
<span class="sd">     plot_data: namedtuple with the losses over time</span>
<span class="sd">     file_name: name to save the plot (without extension)</span>
<span class="sd">     title: title for the plot</span>
<span class="sd">    """</span>
    <span class="n">plotting</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({</span>
        <span class="s2">"Step"</span><span class="p">:</span> <span class="n">plot_data</span><span class="o">.</span><span class="n">steps</span><span class="p">,</span>
        <span class="s2">"Generator Loss"</span><span class="p">:</span> <span class="n">plot_data</span><span class="o">.</span><span class="n">generator_losses</span><span class="p">,</span>
        <span class="s2">"Discriminator Loss"</span><span class="p">:</span> <span class="n">plot_data</span><span class="o">.</span><span class="n">discriminator_losses</span>
    <span class="p">})</span>

    <span class="n">gen_plot</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"Step"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"Generator Loss"</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">Plot</span><span class="o">.</span><span class="n">blue</span><span class="p">)</span>
    <span class="n">disc_plot</span> <span class="o">=</span> <span class="n">plotting</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"Step"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"Discriminator Loss"</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">Plot</span><span class="o">.</span><span class="n">red</span><span class="p">)</span>

    <span class="n">plot</span> <span class="o">=</span> <span class="p">(</span><span class="n">gen_plot</span> <span class="o">*</span> <span class="n">disc_plot</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                                       <span class="n">height</span><span class="o">=</span><span class="n">Plot</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
                                       <span class="n">width</span><span class="o">=</span><span class="n">Plot</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
                                       <span class="n">ylabel</span><span class="o">=</span><span class="s2">"Loss"</span><span class="p">,</span>
                                       <span class="n">hooks</span><span class="o">=</span><span class="p">[</span><span class="n">hook</span><span class="p">],</span>
                                       <span class="n">fontscale</span><span class="o">=</span><span class="n">Plot</span><span class="o">.</span><span class="n">fontscale</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Embed</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="n">file_name</span><span class="p">)()</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="n">plot_losses</span><span class="p">(</span><span class="n">plot_data</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
<object data="posts/gans/mnist-gan/losses.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<div class="highlight">
<pre><span></span><span class="n">plot_data</span> <span class="o">=</span> <span class="n">run_batch</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">plot_losses</span><span class="p">(</span><span class="n">plot_data</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">"losses_2"</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">"Training Loss 2"</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
<object data="posts/gans/mnist-gan/losses_2.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object></div>
</div>
</div>
<div class="outline-3" id="outline-container-orge873e41">
<h3 id="orge873e41">Looking at the Final model.</h3>
<div class="outline-text-3" id="text-orge873e41">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
                <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="n">title</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="n">num_images</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                <span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span>
                <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">"files/posts/gans/mnist-gan/"</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Plot the image and save it</span>

<span class="sd">    Args:</span>
<span class="sd">     image: the tensor with the image to plot</span>
<span class="sd">     filename: name for the final image file</span>
<span class="sd">     title: title to put on top of the image</span>
<span class="sd">     num_images: how many images to put in the composite image</span>
<span class="sd">     size: the size for the image</span>
<span class="sd">     folder: sub-folder to save the file in</span>
<span class="sd">    """</span>
    <span class="n">unflattened_image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">size</span><span class="p">)</span>
    <span class="n">image_grid</span> <span class="o">=</span> <span class="n">make_grid</span><span class="p">(</span><span class="n">unflattened_image</span><span class="p">[:</span><span class="n">num_images</span><span class="p">],</span> <span class="n">nrow</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="n">pyplot</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image_grid</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>

    <span class="n">pyplot</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelbottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelleft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">pyplot</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">folder</span> <span class="o">+</span> <span class="n">filename</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"[[file:</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">]]"</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">fake_noise</span> <span class="o">=</span> <span class="n">get_noise</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">z_dim</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
<span class="n">fake</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">generator</span><span class="p">(</span><span class="n">fake_noise</span><span class="p">)</span>
<span class="n">plot_image</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">fake</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">"fake_digits.png"</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">"Fake Digits"</span><span class="p">)</span>
</pre></div>
<div class="figure" id="org34abc60">
<p><img alt="fake_digits.png" src="posts/gans/mnist-gan/fake_digits.png"></p>
</div>
<p>I thought something was wrong with the losses, at first, since they seem to go up over time, but the loss is based on the Generator and the Discriminator being able to do their job, so as they get better, the loss goes up. The main one for us to note is the Discriminator loss, since this is how much it gets fooled by the Generator. Since it's still going up this likely means that the Generator can still improve.</p>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nlp/neural-machine-translation-helper-functions/index.html">Neural Machine Translation: Helper Functions</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nlp/neural-machine-translation-helper-functions/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-02-27T14:41:04-08:00" itemprop="datePublished" title="2021-02-27 14:41">2021-02-27 14:41</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/nlp/neural-machine-translation-helper-functions/index.html#org21f4874">Helper Functions</a>
<ul>
<li><a href="posts/nlp/neural-machine-translation-helper-functions/index.html#orgc71a4e0">Imports</a></li>
</ul>
</li>
<li><a href="posts/nlp/neural-machine-translation-helper-functions/index.html#org1b1f3da">Helper functions</a>
<ul>
<li><a href="posts/nlp/neural-machine-translation-helper-functions/index.html#org87961f2">Input encoder</a></li>
<li><a href="posts/nlp/neural-machine-translation-helper-functions/index.html#orgbf8a00e">Pre-attention decoder</a></li>
<li><a href="posts/nlp/neural-machine-translation-helper-functions/index.html#orgac2fdbc">Preparing the attention input</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org21f4874">
<h2 id="org21f4874">Helper Functions</h2>
<div class="outline-text-2" id="text-org21f4874">
<p>We will first implement a few functions that we will use later on. These will be for:</p>
<ul class="org-ul">
<li>the input encoder</li>
<li>the pre-attention decoder</li>
<li>preparation of the queries, keys, values, and mask.</li>
</ul>
</div>
<div class="outline-3" id="outline-container-orgc71a4e0">
<h3 id="orgc71a4e0">Imports</h3>
<div class="outline-text-3" id="text-orgc71a4e0">
<div class="highlight">
<pre><span></span><span class="c1"># from pypi</span>
<span class="kn">from</span> <span class="nn">trax</span> <span class="kn">import</span> <span class="n">layers</span>
<span class="kn">from</span> <span class="nn">trax.fastmath</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">fastmath_numpy</span>

<span class="kn">import</span> <span class="nn">trax</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org1b1f3da">
<h2 id="org1b1f3da">Helper functions</h2>
<div class="outline-text-2" id="text-org1b1f3da"></div>
<div class="outline-3" id="outline-container-org87961f2">
<h3 id="org87961f2">Input encoder</h3>
<div class="outline-text-3" id="text-org87961f2">
<p>The input encoder runs on the input tokens, creates its embeddings, and feeds it to an LSTM network. This outputs the activations that will be the keys and values for attention. It is a <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Serial">Serial</a> network which uses:</p>
<ul class="org-ul">
<li><a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.Embedding">tl.Embedding</a>: Converts each token to its vector representation. In this case, it is the the size of the vocabulary by the dimension of the model: <code>tl.Embedding(vocab_size, d_model)</code>. <code>vocab_size</code> is the number of entries in the given vocabulary. <code>d_model</code> is the number of elements in the word embedding.</li>
<li><a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.rnn.LSTM">tl.LSTM</a>: LSTM layer of size <code>d_model</code>. We want to be able to configure how many encoder layers we have so remember to create LSTM layers equal to the number of the <code>n_encoder_layers</code> parameter.</li>
</ul>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">input_encoder</span><span class="p">(</span><span class="n">input_vocab_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">d_model</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">n_encoder_layers</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">:</span>
<span class="w">    </span><span class="sd">""" Input encoder runs on the input sentence and creates</span>
<span class="sd">    activations that will be the keys and values for attention.</span>

<span class="sd">    Args:</span>
<span class="sd">       input_vocab_size: vocab size of the input</span>
<span class="sd">       d_model:  depth of embedding (n_units in the LSTM cell)</span>
<span class="sd">       n_encoder_layers: number of LSTM layers in the encoder</span>

<span class="sd">    Returns:</span>
<span class="sd">       tl.Serial: The input encoder</span>
<span class="sd">    """</span>
    <span class="n">input_encoder</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span> 
        <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">input_vocab_size</span><span class="p">,</span> <span class="n">d_model</span><span class="p">),</span>
        <span class="p">[</span><span class="n">layers</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">d_model</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_encoder_layers</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">input_encoder</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_input_encoder_fn</span><span class="p">(</span><span class="n">input_encoder_fn</span><span class="p">):</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">input_encoder_fn</span>
    <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fails</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">input_vocab_size</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">d_model</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n_encoder_layers</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="n">encoder</span> <span class="o">=</span> <span class="n">target</span><span class="p">(</span><span class="n">input_vocab_size</span><span class="p">,</span> <span class="n">d_model</span><span class="p">,</span> <span class="n">n_encoder_layers</span><span class="p">)</span>

    <span class="n">lstms</span> <span class="o">=</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">'  LSTM_</span><span class="si">{</span><span class="n">d_model</span><span class="si">}</span><span class="s1">'</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_encoder_layers</span><span class="p">)</span>

    <span class="n">expected</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"Serial[</span><span class="se">\n</span><span class="s2">  Embedding_</span><span class="si">{</span><span class="n">input_vocab_size</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">d_model</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">lstms</span><span class="si">}</span><span class="se">\n</span><span class="s2">]"</span>

    <span class="n">proposed</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">encoder</span><span class="p">)</span>

    <span class="c1"># Test all layers are in the expected sequence</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">proposed</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="s2">""</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Wrong model. </span><span class="se">\n</span><span class="s2">Proposed:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="n">proposed</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Expected:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="n">expected</span><span class="p">)</span>

    <span class="c1"># Test the output type</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">encoder</span><span class="p">,</span> <span class="n">trax</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">combinators</span><span class="o">.</span><span class="n">Serial</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Test the number of layers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Test </span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">encoder</span><span class="o">.</span><span class="n">sublayers</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">n_encoder_layers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'The number of sublayers does not match </span><span class="si">%s</span><span class="s1"> &lt;&gt;'</span> <span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">encoder</span><span class="o">.</span><span class="n">sublayers</span><span class="p">),</span> <span class="s2">" </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="p">(</span><span class="n">n_encoder_layers</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"The enconder is not an object of "</span><span class="p">,</span> <span class="n">trax</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">combinators</span><span class="o">.</span><span class="n">Serial</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">fails</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\033</span><span class="s2">[92m All tests passed"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[92m'</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span><span class="s2">" Tests passed"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[91m'</span><span class="p">,</span> <span class="n">fails</span><span class="p">,</span> <span class="s2">" Tests failed"</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_input_encoder_fn</span><span class="p">(</span><span class="n">input_encoder</span><span class="p">)</span>
</pre></div>
<pre class="example">
[92m All tests passed
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgbf8a00e">
<h3 id="orgbf8a00e">Pre-attention decoder</h3>
<div class="outline-text-3" id="text-orgbf8a00e">
<p>The pre-attention decoder runs on the targets and creates activations that are used as queries in attention. This is a Serial network which is composed of the following:</p>
<ul class="org-ul">
<li><a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.attention.ShiftRight">tl.ShiftRight</a>: This pads a token to the beginning of your target tokens (e.g. <code>[8, 34, 12]</code> shifted right is <code>[0, 8, 34, 12]</code>). This will act like a start-of-sentence token that will be the first input to the decoder. During training, this shift also allows the target tokens to be passed as input to do teacher forcing.</li>
<li><a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.Embedding">tl.Embedding</a>: Like in the previous function, this converts each token to its vector representation. In this case, it is the the size of the vocabulary by the dimension of the model: <code>tl.Embedding(vocab_size, d_model)</code>. <code>vocab_size</code> is the number of entries in the given vocabulary. <code>d_model</code> is the number of elements in the word embedding.</li>
<li><a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.rnn.LSTM">tl.LSTM</a>: LSTM layer of size <code>d_model</code>.</li>
</ul>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">pre_attention_decoder</span><span class="p">(</span><span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_vocab_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">d_model</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">:</span>
<span class="w">    </span><span class="sd">""" Pre-attention decoder runs on the targets and creates</span>
<span class="sd">    activations that are used as queries in attention.</span>

<span class="sd">    Args:</span>
<span class="sd">       mode: 'train' or 'eval'</span>
<span class="sd">       target_vocab_size: vocab size of the target</span>
<span class="sd">       d_model:  depth of embedding (n_units in the LSTM cell)</span>
<span class="sd">    Returns:</span>
<span class="sd">       tl.Serial: The pre-attention decoder</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">ShiftRight</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">),</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">target_vocab_size</span><span class="p">,</span> <span class="n">d_model</span><span class="p">),</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">d_model</span><span class="p">)</span>
    <span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_pre_attention_decoder_fn</span><span class="p">(</span><span class="n">pre_attention_decoder_fn</span><span class="p">):</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">pre_attention_decoder_fn</span>
    <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fails</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="s1">'train'</span>
    <span class="n">target_vocab_size</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">d_model</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">decoder</span> <span class="o">=</span> <span class="n">target</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">target_vocab_size</span><span class="p">,</span> <span class="n">d_model</span><span class="p">)</span>

    <span class="n">expected</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"Serial[</span><span class="se">\n</span><span class="s2">  ShiftRight(1)</span><span class="se">\n</span><span class="s2">  Embedding_</span><span class="si">{</span><span class="n">target_vocab_size</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">d_model</span><span class="si">}</span><span class="se">\n</span><span class="s2">  LSTM_</span><span class="si">{</span><span class="n">d_model</span><span class="si">}</span><span class="se">\n</span><span class="s2">]"</span>

    <span class="n">proposed</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">decoder</span><span class="p">)</span>

    <span class="c1"># Test all layers are in the expected sequence</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">proposed</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span> <span class="o">==</span> <span class="n">expected</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="s2">""</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Wrong model. </span><span class="se">\n</span><span class="s2">Proposed:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="n">proposed</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Expected:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="n">expected</span><span class="p">)</span>

    <span class="c1"># Test the output type</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">decoder</span><span class="p">,</span> <span class="n">trax</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">combinators</span><span class="o">.</span><span class="n">Serial</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Test the number of layers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Test </span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">sublayers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
            <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'The number of sublayers does not match </span><span class="si">%s</span><span class="s1"> &lt;&gt;'</span> <span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">decoder</span><span class="o">.</span><span class="n">sublayers</span><span class="p">),</span> <span class="s2">" </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"The enconder is not an object of "</span><span class="p">,</span> <span class="n">trax</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">combinators</span><span class="o">.</span><span class="n">Serial</span><span class="p">)</span>


    <span class="k">if</span> <span class="n">fails</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\033</span><span class="s2">[92m All tests passed"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[92m'</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span><span class="s2">" Tests passed"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[91m'</span><span class="p">,</span> <span class="n">fails</span><span class="p">,</span> <span class="s2">" Tests failed"</span><span class="p">)</span>
</pre></div>
<p>They changed the behavior of the <code>Fn</code> (or something in there) so that it always wraps the ShiftRight in a Serial layer, so it doesn't match the test anymore. Testing strings is kind of gimpy anyway…</p>
<p>It looks like they're using a decorator to check the shape which then wraps it in a Serial layer. See trax.layers.assert_shape.AssertFunction</p>
<div class="highlight">
<pre><span></span><span class="n">test_pre_attention_decoder_fn</span><span class="p">(</span><span class="n">pre_attention_decoder</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org8a7ca8c">
Wrong model. 
Proposed:
Serial[
  Serial[
    ShiftRight(1)
  ]
  Embedding_10_2
  LSTM_2
] 
Expected:
Serial[
  ShiftRight(1)
  Embedding_10_2
  LSTM_2
]
[92m 2  Tests passed
[91m 1  Tests failed
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgac2fdbc">
<h3 id="orgac2fdbc">Preparing the attention input</h3>
<div class="outline-text-3" id="text-orgac2fdbc">
<p>This function will prepare the inputs to the attention layer. We want to take in the encoder and pre-attention decoder activations and assign it to the queries, keys, and values. In addition, another output here will be the mask to distinguish real tokens from padding tokens. This mask will be used internally by Trax when computing the softmax so padding tokens will not have an effect on the computated probabilities. From the data preparation steps in Section 1 of this assignment, you should know which tokens in the input correspond to padding.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">prepare_attention_input</span><span class="p">(</span><span class="n">encoder_activations</span><span class="p">:</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                            <span class="n">decoder_activations</span><span class="p">:</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
                            <span class="n">inputs</span><span class="p">:</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Prepare queries, keys, values and mask for attention.</span>

<span class="sd">    Args:</span>
<span class="sd">       encoder_activations fastnp.array(batch_size, padded_input_length, d_model): output from the input encoder</span>
<span class="sd">       decoder_activations fastnp.array(batch_size, padded_input_length, d_model): output from the pre-attention decoder</span>
<span class="sd">       inputs fastnp.array(batch_size, padded_input_length): padded input tokens</span>

<span class="sd">    Returns:</span>
<span class="sd">       queries, keys, values and mask for attention.</span>
<span class="sd">    """</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">encoder_activations</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">encoder_activations</span>
    <span class="n">queries</span> <span class="o">=</span> <span class="n">decoder_activations</span>    
    <span class="n">mask</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">mask</span> <span class="o">+=</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">decoder_activations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">queries</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mask</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_prepare_attention_input</span><span class="p">(</span><span class="n">prepare_attention_input</span><span class="p">):</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">prepare_attention_input</span>
    <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fails</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1">#This unit test consider a batch size = 2, number_of_tokens = 3 and embedding_size = 4</span>

    <span class="n">enc_act</span> <span class="o">=</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
               <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]])</span>
    <span class="n">dec_act</span> <span class="o">=</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> 
               <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]])</span>
    <span class="n">inputs</span> <span class="o">=</span>  <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

    <span class="n">exp_mask</span> <span class="o">=</span> <span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]],</span> 
                             <span class="p">[[[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]]]])</span>

    <span class="n">exp_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">enc_act</span><span class="p">)</span>

    <span class="n">queries</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">target</span><span class="p">(</span><span class="n">enc_act</span><span class="p">,</span> <span class="n">dec_act</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">dec_act</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Queries does not match the decoder activations"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">enc_act</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Keys does not match the encoder activations"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">enc_act</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Values does not match the encoder activations"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">fastmath_numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">exp_mask</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Mask does not match expected tensor. </span><span class="se">\n</span><span class="s2">Expected:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="n">exp_mask</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">Output:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># Test the output type</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">queries</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">))</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">))</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">))</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"One of the output object are not of type "</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">interpreters</span><span class="o">.</span><span class="n">xla</span><span class="o">.</span><span class="n">DeviceArray</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fails</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\033</span><span class="s2">[92m All tests passed"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[92m'</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span><span class="s2">" Tests passed"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[91m'</span><span class="p">,</span> <span class="n">fails</span><span class="p">,</span> <span class="s2">" Tests failed"</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_prepare_attention_input</span><span class="p">(</span><span class="n">prepare_attention_input</span><span class="p">)</span>
</pre></div>
<pre class="example">
[92m All tests passed
</pre></div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/first-course/logistic-regression-with-neural-networks/index.html">Logistic Regression With Neural Networks</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/first-course/logistic-regression-with-neural-networks/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-02-23T18:22:52-08:00" itemprop="datePublished" title="2021-02-23 18:22">2021-02-23 18:22</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#org2da4b2e">Beginning</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#orgf04e208">Instructions</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#org339548e">1 - Packages</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#orgdf7d954">2 - Overview of the Problem set</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#org04578dc">3 - General Architecture of the learning algorithm</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#org4dbda3f">4 - Building the parts of our algorithm</a>
<ul>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#orgddcdc2c">4.1 - Helper functions</a></li>
</ul>
</li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#org433865a">4.2 - Initializing parameters</a>
<ul>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#orgc631bc6">4.3 - Forward and Backward propagation</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#orgf48c44e">d) Optimization</a></li>
</ul>
</li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#orgc70b780">5 - Merge all functions into a model</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#org567e79b">6 - Further analysis (optional/ungraded exercise)</a></li>
<li><a href="posts/first-course/logistic-regression-with-neural-networks/index.html#org74057d6">7 - Test with your own image (optional/ungraded exercise)</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org2da4b2e">
<h2 id="org2da4b2e">Beginning</h2>
<div class="outline-text-2" id="text-org2da4b2e">
<p>In this post we will build a logistic regression classifier to recognize cats.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgf04e208">
<h2 id="orgf04e208">Instructions</h2>
<div class="outline-text-2" id="text-orgf04e208">
<ul class="org-ul">
<li>Do not use loops (for/while) in your code, unless the instructions explicitly ask you to do so.</li>
</ul>
<p><b>You will learn to:</b></p>
<ul class="org-ul">
<li>Build the general architecture of a learning algorithm, including:
<ul class="org-ul">
<li>Initializing parameters</li>
<li>Calculating the cost function and its gradient</li>
<li>Using an optimization algorithm (gradient descent)</li>
</ul>
</li>
<li>Gather all three functions above into a main model function, in the right order.</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org339548e">
<h2 id="org339548e">1 - Packages</h2>
<div class="outline-text-2" id="text-org339548e">
<p>First, let's run the cell below to import all the packages that you will need during this assignment.</p>
<ul class="org-ul">
<li><a href="http://www.numpy.org">numpy</a> is the fundamental package for scientific computing with Python.</li>
<li><a href="http://www.h5py.org">h5py</a> is a common package to interact with a dataset that is stored on an H5 file.</li>
<li><a href="http://matplotlib.org">matplotlib</a> is a famous library to plot graphs in Python.</li>
<li><a href="http://www.pythonware.com/products/pil/">PIL</a> and <a href="https://www.scipy.org/">scipy</a> are used here to test your model with your own picture at the end.</li>
</ul>
<div class="highlight">
<pre><span></span>import numpy as np
import matplotlib.pyplot as plt
import h5py
import scipy
from PIL import Image
from scipy import ndimage
from lr_utils import load_dataset
</pre></div>
<div class="highlight">
<pre><span></span>get_ipython().run_line_magic('matplotlib', 'inline')
</pre></div>
<div class="highlight">
<pre><span></span>TOLERANCE = (0.1)**5
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgdf7d954">
<h2 id="orgdf7d954">2 - Overview of the Problem set</h2>
<div class="outline-text-2" id="text-orgdf7d954">
<p><b>Problem Statement</b>: You are given a dataset ("data.h5") containing:</p>
<ul class="org-ul">
<li>a training set of m_train images labeled as cat (y=1) or non-cat (y=0)</li>
<li>a test set of m_test images labeled as cat or non-cat</li>
<li>each image is of shape (num_px, num_px, 3) where 3 is for the 3 channels (RGB). Thus, each image is square (height = num_px) and (width = num_px).</li>
</ul>
<p>You will build a simple image-recognition algorithm that can correctly classify pictures as cat or non-cat.</p>
<p>Let's get more familiar with the dataset. Load the data by running the following code.</p>
<div class="highlight">
<pre><span></span># Loading the data (cat/non-cat)
train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()
</pre></div>
<p>We added "_orig" at the end of image datasets (train and test) because we are going to preprocess them. After preprocessing, we will end up with train_set_x and test_set_x (the labels train_set_y and test_set_y don't need any preprocessing).</p>
<p>Each line of your train_set_x_orig and test_set_x_orig is an array representing an image. You can visualize an example by running the following code. Feel free also to change the `index` value and re-run to see other images.</p>
<div class="highlight">
<pre><span></span># Example of a picture
index = 25
image = plt.imshow(train_set_x_orig[index])
</pre></div>
<div class="figure" id="orgc93b5e9">
<p><img alt="picture_example.png" src="file:///tmp/picture_example.png"></p>
</div>
<div class="highlight">
<pre><span></span>print ("y = " + str(train_set_y[:, index]) + ", it's a '" + classes[np.squeeze(train_set_y[:, index])].decode("utf-8") +  "' picture.")
</pre></div>
<p>Many software bugs in deep learning come from having matrix/vector dimensions that don't fit. If you can keep your matrix/vector dimensions straight you will go a long way toward eliminating many bugs.</p>
<p><b>Exercise:</b> Find the values for:</p>
<ul class="org-ul">
<li>m_train (number of training examples)</li>
<li>m_test (number of test examples)</li>
<li>num_px (= height = width of a training image)</li>
</ul>
<p>Remember that `train_set_x_orig` is a numpy-array of shape (m_train, num_px, num_px, 3). For instance, you can access `m_train` by writing `train_set_x_orig.shape[0]`.</p>
<div class="highlight">
<pre><span></span>### START CODE HERE ### (≈ 3 lines of code)
m_train, num_px, num_px, dimensions = train_set_x_orig.shape
m_test, num_px, num_px, dimensions = test_set_x_orig.shape
m_train = m_train
m_test = m_test
num_px = num_px
### END CODE HERE ###
</pre></div>
<div class="highlight">
<pre><span></span>assert m_train == 209
assert m_test == 50
assert num_px == 64
</pre></div>
<div class="highlight">
<pre><span></span>print ("Number of training examples: m_train = " + str(m_train))
print ("Number of testing examples: m_test = " + str(m_test))
print ("Height/Width of each image: num_px = " + str(num_px))
print ("Each image is of size: (" + str(num_px) + ", " + str(num_px) + ", 3)")
print ("train_set_x shape: " + str(train_set_x_orig.shape))
print ("train_set_y shape: " + str(train_set_y.shape))
print ("test_set_x shape: " + str(test_set_x_orig.shape))
print ("test_set_y shape: " + str(test_set_y.shape))
</pre></div>
<p>For convenience, you should now reshape images of shape (num_px, num_px, 3) in a numpy-array of shape (num_px \(*\) num_px \(*\) 3, 1). After this, our training (and test) dataset is a numpy-array where each column represents a flattened image. There should be m_train (respectively m_test) columns.</p>
<p><b>Exercise:</b> Reshape the training and test data sets so that images of size (num_px, num_px, 3) are flattened into single vectors of shape (num\_px \(*\) num\_px \(*\) 3, 1).</p>
<p>A trick when you want to flatten a matrix X of shape (a,b,c,d) to a matrix X_flatten of shape (b$*$c$*$d, a) is to use:</p>
<pre class="example" id="org01342e1">
X_flatten = X.reshape(X.shape[0], -1).T      # X.T is the transpose of X
</pre>
<p>Reshape the training and test examples</p>
<div class="highlight">
<pre><span></span>### START CODE HERE ### (≈ 2 lines of code)
train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[0], -1).T
test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T
### END CODE HERE ###
</pre></div>
<div class="highlight">
<pre><span></span>assert train_set_x_flatten.shape == (12288, 209)
assert train_set_y.shape == (1, 209)
assert test_set_x_flatten.shape == (12288, 50)
assert test_set_y.shape == (1, 50)
assert (train_set_x_flatten[0:5, 0] == np.array([17, 31, 56, 22, 33])).all()
</pre></div>
<div class="highlight">
<pre><span></span>print ("train_set_x_flatten shape: " + str(train_set_x_flatten.shape))
print ("train_set_y shape: " + str(train_set_y.shape))
print ("test_set_x_flatten shape: " + str(test_set_x_flatten.shape))
print ("test_set_y shape: " + str(test_set_y.shape))
print ("sanity check after reshaping: " + str(train_set_x_flatten[0:5,0]))
</pre></div>
<p>To represent color images, the red, green and blue channels (RGB) must be specified for each pixel, and so the pixel value is actually a vector of three numbers ranging from 0 to 255.</p>
<p>One common preprocessing step in machine learning is to center and standardize your dataset, meaning that you substract the mean of the whole numpy array from each example, and then divide each example by the standard deviation of the whole numpy array. But for picture datasets, it is simpler and more convenient and works almost as well to just divide every row of the dataset by 255 (the maximum value of a pixel channel).</p>
<p>&lt;!– During the training of your model, you're going to multiply weights and add biases to some initial inputs in order to observe neuron activations. Then you backpropogate with the gradients to train the model. But, it is extremely important for each feature to have a similar range such that our gradients don't explode. You will see that more in detail later in the lectures. !–&gt;</p>
<p>Let's standardize our dataset.</p>
<div class="highlight">
<pre><span></span>train_set_x = train_set_x_flatten/255.
test_set_x = test_set_x_flatten/255.
</pre></div>
<p><b>What you need to remember:</b></p>
<p>Common steps for pre-processing a new dataset are:</p>
<ul class="org-ul">
<li>Figure out the dimensions and shapes of the problem (m_train, m_test, num_px, …)</li>
<li>Reshape the datasets such that each example is now a vector of size (num_px \* num_px \* 3, 1)</li>
<li>"Standardize" the data</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org04578dc">
<h2 id="org04578dc">3 - General Architecture of the learning algorithm</h2>
<div class="outline-text-2" id="text-org04578dc">
<p>It's time to design a simple algorithm to distinguish cat images from non-cat images.</p>
<p>You will build a Logistic Regression, using a Neural Network mindset. The following Figure explains why <b>Logistic Regression is actually a very simple Neural Network!</b></p>
<p>&lt;img src="images/LogReg_kiank.png" style="width:650px;height:400px;"&gt;</p>
<p><b>Mathematical expression of the algorithm</b>:</p>
<p><b>Key steps</b>: In this exercise, you will carry out the following steps:</p>
<ul class="org-ul">
<li>Initialize the parameters of the model</li>
<li>Learn the parameters for the model by minimizing the cost</li>
<li>Use the learned parameters to make predictions (on the test set)</li>
<li>Analyse the results and conclude</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org4dbda3f">
<h2 id="org4dbda3f">4 - Building the parts of our algorithm</h2>
<div class="outline-text-2" id="text-org4dbda3f">
<p>The main steps for building a Neural Network are:</p>
<ol class="org-ol">
<li>Define the model structure (such as number of input features)</li>
<li>Initialize the model's parameters</li>
<li>Loop:
<ul class="org-ul">
<li>Calculate current loss (forward propagation)</li>
<li>Calculate current gradient (backward propagation)</li>
<li>Update parameters (gradient descent)</li>
</ul>
</li>
</ol>
<p>You often build 1-3 separately and integrate them into one function we call `model()`.</p>
</div>
<div class="outline-3" id="outline-container-orgddcdc2c">
<h3 id="orgddcdc2c">4.1 - Helper functions</h3>
<div class="outline-text-3" id="text-orgddcdc2c">
<p><b>Exercise</b>: Using your code from "Python Basics", implement `sigmoid()`. As you've seen in the figure above, you need to compute \(sigmoid( w^T x + b) = \frac{1}{1 + e^{-(w^T x + b)}}\) to make predictions. Use np.exp().</p>
<div class="highlight">
<pre><span></span># GRADED FUNCTION: sigmoid

def sigmoid(z):
    """
    Compute the sigmoid of z

    Arguments:
    z -- A scalar or numpy array of any size.

    Return:
    s -- sigmoid(z)
    """

    ### START CODE HERE ### (≈ 1 line of code)
    s = 1/(1 + np.exp(-z))
    ### END CODE HERE ###

    return s
</pre></div>
<div class="highlight">
<pre><span></span>expected = np.array([0.5, 0.88079708])
actual = sigmoid(np.array([0,2]))
print ("sigmoid([0, 2]) = " + str(actual))
assert (expected - actual &lt; TOLERANCE).all()
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org433865a">
<h2 id="org433865a">4.2 - Initializing parameters</h2>
<div class="outline-text-2" id="text-org433865a">
<p><b>Exercise:</b> Implement parameter initialization in the cell below. You have to initialize w as a vector of zeros. If you don't know what numpy function to use, look up np.zeros() in the Numpy library's documentation.</p>
<div class="highlight">
<pre><span></span># GRADED FUNCTION: initialize_with_zeros

def initialize_with_zeros(dim):
    """
    This function creates a vector of zeros of shape (dim, 1) for w and initializes b to 0.

    Argument:
    dim -- size of the w vector we want (or number of parameters in this case)

    Returns:
    w -- initialized vector of shape (dim, 1)
    b -- initialized scalar (corresponds to the bias)
    """

    ### START CODE HERE ### (≈ 1 line of code)
    w = np.zeros((dim, 1))
    b = 0
    ### END CODE HERE ###

    assert(w.shape == (dim, 1))
    assert(isinstance(b, float) or isinstance(b, int))

    return w, b
</pre></div>
<div class="highlight">
<pre><span></span>dim = 2
w, b = initialize_with_zeros(dim)
print ("w = " + str(w))
print ("b = " + str(b))
</pre></div>
<p>For image inputs, w will be of shape (num_px \(\times\) num_px \(\times\) 3, 1).</p>
</div>
<div class="outline-3" id="outline-container-orgc631bc6">
<h3 id="orgc631bc6">4.3 - Forward and Backward propagation</h3>
<div class="outline-text-3" id="text-orgc631bc6">
<p>Now that your parameters are initialized, you can do the "forward" and "backward" propagation steps for learning the parameters.</p>
<p><b>Exercise:</b> Implement a function `propagate()` that computes the cost function and its gradient.</p>
<p><b>Hints</b>:</p>
<p>Forward Propagation:</p>
<ul class="org-ul">
<li>You get X</li>
<li>You compute \(A = \sigma(w^T X + b) = (a^{(0)}, a^{(1)}, ..., a^{(m-1)}, a^{(m)})\)</li>
<li>You calculate the cost function: \(J = -\frac{1}{m}\sum_{i=1}^{m}y^{(i)}\log(a^{(i)})+(1-y^{(i)})\log(1-a^{(i)})\)</li>
</ul>
<p>Here are the two formulas you will be using:</p>
<p>\[ \frac{\partial J}{\partial w} = \frac{1}{m}X(A-Y)^T\tag{7}\] \[ \frac{\partial J}{\partial b} = \frac{1}{m} \sum_{i=1}^m (a^{(i)}-y^{(i)})\tag{8}\]</p>
<div class="highlight">
<pre><span></span># GRADED FUNCTION: propagate

def propagate(w, b, X, Y):
    """
    Implement the cost function and its gradient for the propagation explained above

    Arguments:
    w -- weights, a numpy array of size (num_px * num_px * 3, 1)
    b -- bias, a scalar
    X -- data of size (num_px * num_px * 3, number of examples)
    Y -- true "label" vector (containing 0 if non-cat, 1 if cat) of size (1, number of examples)

    Return:
    cost -- negative log-likelihood cost for logistic regression
    dw -- gradient of the loss with respect to w, thus same shape as w
    db -- gradient of the loss with respect to b, thus same shape as b

    Tips:
    - Write your code step by step for the propagation. np.log(), np.dot()
    """

    m = X.shape[1]

    # FORWARD PROPAGATION (FROM X TO COST)
    ### START CODE HERE ### (≈ 2 lines of code)
    A = sigmoid(np.dot(w.T, X) + b)                                    # compute activation
    cost = -(Y * np.log(A) + (1 - Y) * np.log(1 - A)).mean()
    ### END CODE HERE ###

    # BACKWARD PROPAGATION (TO FIND GRAD)
    ### START CODE HERE ### (≈ 2 lines of code)
    dz = A - Y
    dw = np.dot(X, dz.T)/m
    db = dz.mean()
    ### END CODE HERE ###

    assert(dw.shape == w.shape)
    assert(db.dtype == float)
    cost = np.squeeze(cost)
    assert(cost.shape == ())

    grads = {"dw": dw,
             "db": db}

    return grads, cost
</pre></div>
<div class="highlight">
<pre><span></span>w, b, X, Y = np.array([[1.],[2.]]), 2., np.array([[1.,2.,-1.],[3.,4.,-3.2]]), np.array([[1,0,1]])
grads, cost = propagate(w, b, X, Y)
print ("dw = " + str(grads["dw"]))
print ("db = " + str(grads["db"]))
print ("cost = " + str(cost))
</pre></div>
<div class="highlight">
<pre><span></span>assert (grads["dw"] - np.abs(np.array([[0.99845601], [2.39507239]])) &lt; TOLERANCE).all()
assert np.abs(grads["db"] - 0.00145557813678) &lt; TOLERANCE
assert abs(cost - 5.801545319394553) &lt; TOLERANCE
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgf48c44e">
<h3 id="orgf48c44e">d) Optimization</h3>
<div class="outline-text-3" id="text-orgf48c44e">
<ul class="org-ul">
<li>You have initialized your parameters.</li>
<li>You are also able to compute a cost function and its gradient.</li>
<li>Now, you want to update the parameters using gradient descent.</li>
</ul>
<p><b>Exercise:</b> Write down the optimization function. The goal is to learn \(w\) and \(b\) by minimizing the cost function \(J\). For a parameter \(\theta\), the update rule is $ θ = θ - α \text{ } dθ$, where \(\alpha\) is the learning rate.</p>
<div class="highlight">
<pre><span></span># GRADED FUNCTION: optimize

def optimize(w, b, X, Y, num_iterations, learning_rate, print_cost = False):
    """
    This function optimizes w and b by running a gradient descent algorithm

    Arguments:
    w -- weights, a numpy array of size (num_px * num_px * 3, 1)
    b -- bias, a scalar
    X -- data of shape (num_px * num_px * 3, number of examples)
    Y -- true "label" vector (containing 0 if non-cat, 1 if cat), of shape (1, number of examples)
    num_iterations -- number of iterations of the optimization loop
    learning_rate -- learning rate of the gradient descent update rule
    print_cost -- True to print the loss every 100 steps

    Returns:
    params -- dictionary containing the weights w and bias b
    grads -- dictionary containing the gradients of the weights and bias with respect to the cost function
    costs -- list of all the costs computed during the optimization, this will be used to plot the learning curve.

    Tips:
    You basically need to write down two steps and iterate through them:
        1) Calculate the cost and the gradient for the current parameters. Use propagate().
        2) Update the parameters using gradient descent rule for w and b.
    """

    costs = []

    for i in range(num_iterations):


        # Cost and gradient calculation (≈ 1-4 lines of code)
        ### START CODE HERE ### 
        grads, cost = propagate(w, b, X, Y)
        ### END CODE HERE ###

        # Retrieve derivatives from grads
        dw = grads["dw"]
        db = grads["db"]

        # update rule (≈ 2 lines of code)
        ### START CODE HERE ###
        w = w - learning_rate * dw
        b = b - learning_rate * db
        ### END CODE HERE ###

        # Record the costs
        if i % 100 == 0:
            costs.append(cost)

        # Print the cost every 100 training examples
        if print_cost and i % 100 == 0:
            print ("Cost after iteration %i: %f" %(i, cost))

    params = {"w": w,
              "b": b}

    grads = {"dw": dw,
             "db": db}

    return params, grads, costs
</pre></div>
<div class="highlight">
<pre><span></span>params, grads, costs = optimize(w, b, X, Y, num_iterations= 100, learning_rate = 0.009, print_cost = False)
</pre></div>
<div class="highlight">
<pre><span></span>print ("w = " + str(params["w"]))
print ("b = " + str(params["b"]))
print ("dw = " + str(grads["dw"]))
print ("db = " + str(grads["db"]))
</pre></div>
<div class="highlight">
<pre><span></span>assert (np.abs(params["w"] - np.array([[ 0.19033591], [ 0.12259159]])) &lt; TOLERANCE).all()
assert abs(params["b"] - 1.92535983008) &lt; TOLERANCE
assert (np.abs(grads['dw'] - np.array([[ 0.67752042], [ 1.41625495]])) &lt; TOLERANCE).all()
assert abs(grads["db"] - 0.219194504541) &lt; TOLERANCE
</pre></div>
<p><b>Exercise:</b> The previous function will output the learned w and b. We are able to use w and b to predict the labels for a dataset X. Implement the `predict()` function. There is two steps to computing predictions:</p>
<ol class="org-ol">
<li>Calculate \(\hat{Y} = A = \sigma(w^T X + b)\)</li>
<li>Convert the entries of a into 0 (if activation &lt;= 0.5) or 1 (if activation &gt; 0.5), stores the predictions in a vector `Y_prediction`. If you wish, you can use an `if`/`else` statement in a `for` loop (though there is also a way to vectorize this).</li>
</ol>
<div class="highlight">
<pre><span></span># GRADED FUNCTION: predict

def predict(w, b, X):
    '''
    Predict whether the label is 0 or 1 using learned logistic regression parameters (w, b)

    Arguments:
    w -- weights, a numpy array of size (num_px * num_px * 3, 1)
    b -- bias, a scalar
    X -- data of size (num_px * num_px * 3, number of examples)

    Returns:
    Y_prediction -- a numpy array (vector) containing all predictions (0/1) for the examples in X
    '''

    m = X.shape[1]
    Y_prediction = np.zeros((1,m))
    w = w.reshape(X.shape[0], 1)

    # Compute vector "A" predicting the probabilities of a cat being present in the picture
    ### START CODE HERE ### (≈ 1 line of code)
    A = sigmoid(np.dot(w.T, X) + b)
    ### END CODE HERE ###

    for i in range(A.shape[1]):

        # Convert probabilities A[0,i] to actual predictions p[0,i]
        ### START CODE HERE ### (≈ 4 lines of code)
        Y_prediction[0, i] = 1 if A[0, i] &gt; 0.5 else 0
        ### END CODE HERE ###

    assert(Y_prediction.shape == (1, m))

    return Y_prediction
</pre></div>
<div class="highlight">
<pre><span></span>w = np.array([[0.1124579],[0.23106775]])
b = -0.3
X = np.array([[1.,-1.1,-3.2],[1.2,2.,0.1]])
predictions = predict(w, b, X)
print ("predictions = " + str(predictions))
</pre></div>
<div class="highlight">
<pre><span></span>assert (np.abs(predictions - np.array([1., 1., 0.])) &lt; TOLERANCE).all()
</pre></div>
<p><b>What to remember:</b> You've implemented several functions that:</p>
<ul class="org-ul">
<li>Initialize (w,b)</li>
<li>Optimize the loss iteratively to learn parameters (w,b):
<ul class="org-ul">
<li>computing the cost and its gradient</li>
<li>updating the parameters using gradient descent</li>
</ul>
</li>
<li>Use the learned (w,b) to predict the labels for a given set of examples</li>
</ul>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgc70b780">
<h2 id="orgc70b780">5 - Merge all functions into a model</h2>
<div class="outline-text-2" id="text-orgc70b780">
<p>You will now see how the overall model is structured by putting together all the building blocks (functions implemented in the previous parts) together, in the right order.</p>
<p><b>Exercise:</b> Implement the model function. Use the following notation:</p>
<ul class="org-ul">
<li>Y_prediction for your predictions on the test set</li>
<li>Y_prediction_train for your predictions on the train set</li>
<li>w, costs, grads for the outputs of optimize()</li>
</ul>
<div class="highlight">
<pre><span></span># GRADED FUNCTION: model

def model(X_train, Y_train, X_test, Y_test, num_iterations = 2000, learning_rate = 0.5, print_cost = False):
    """
    Builds the logistic regression model by calling the function you've implemented previously

    Arguments:
    X_train -- training set represented by a numpy array of shape (num_px * num_px * 3, m_train)
    Y_train -- training labels represented by a numpy array (vector) of shape (1, m_train)
    X_test -- test set represented by a numpy array of shape (num_px * num_px * 3, m_test)
    Y_test -- test labels represented by a numpy array (vector) of shape (1, m_test)
    num_iterations -- hyperparameter representing the number of iterations to optimize the parameters
    learning_rate -- hyperparameter representing the learning rate used in the update rule of optimize()
    print_cost -- Set to true to print the cost every 100 iterations

    Returns:
    d -- dictionary containing information about the model.
    """

    ### START CODE HERE ###

    # initialize parameters with zeros (≈ 1 line of code)
    w, b = initialize_with_zeros(X_train.shape[0])

    # Gradient descent (≈ 1 line of code)
    parameters, grads, costs = optimize(w, b, X_train, Y_train, num_iterations, learning_rate, print_cost)

    # Retrieve parameters w and b from dictionary "parameters"
    w = parameters["w"]
    b = parameters["b"]

    # Predict test/train set examples (≈ 2 lines of code)
    Y_prediction_test = predict(w, b, X_test)
    Y_prediction_train = predict(w, b, X_train)

    ### END CODE HERE ###

    # Print train/test Errors
    print("train accuracy: {} %".format(100 - np.mean(np.abs(Y_prediction_train - Y_train)) * 100))
    print("test accuracy: {} %".format(100 - np.mean(np.abs(Y_prediction_test - Y_test)) * 100))


    d = {"costs": costs,
         "Y_prediction_test": Y_prediction_test, 
         "Y_prediction_train" : Y_prediction_train, 
         "w" : w, 
         "b" : b,
         "learning_rate" : learning_rate,
         "num_iterations": num_iterations}

    return d
</pre></div>
<div class="highlight">
<pre><span></span>d = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = 2000, learning_rate = 0.005, print_cost = True)
</pre></div>
<p><b>Comment</b>: Training accuracy is close to 100%. This is a good sanity check: your model is working and has high enough capacity to fit the training data. Test error is 68%. It is actually not bad for this simple model, given the small dataset we used and that logistic regression is a linear classifier. But no worries, you'll build an even better classifier next week!</p>
<p>Also, you see that the model is clearly overfitting the training data. Later in this specialization you will learn how to reduce overfitting, for example by using regularization. Using the code below (and changing the `index` variable) you can look at predictions on pictures of the test set.</p>
<div class="highlight">
<pre><span></span># Example of a picture that was wrongly classified.
index = 1
plt.imshow(test_set_x[:,index].reshape((num_px, num_px, 3)))
</pre></div>
<pre class="example">
&lt;matplotlib.image.AxesImage at 0x7f02ff4aaa90&gt;
</pre>
<div class="figure" id="org6301d1d">
<p><img alt="wrong_classification.png" src="file:///tmp/wrong_classification.png"></p>
</div>
<div class="highlight">
<pre><span></span>y_actual = test_set_y[0,index]
y_prediction_test = d["Y_prediction_test"]
prediction = classes[int(y_prediction_test[0,index])].decode("utf-8")
print ("y = " + str(y_actual) + ", you predicted that it is a \"" + prediction +  "\" picture.")
</pre></div>
<div class="highlight">
<pre><span></span># Plot learning curve (with costs)
costs = np.squeeze(d['costs'])
plt.plot(costs)
plt.ylabel('cost')
plt.xlabel('iterations (per hundreds)')
plt.title("Learning rate =" + str(d["learning_rate"]))
plt.show()
</pre></div>
<div class="figure" id="org4811ae0">
<p><img alt="learning_curve.png" src="file:///tmp/learning_curve.png"></p>
</div>
<p><b>Interpretation</b>: You can see the cost decreasing. It shows that the parameters are being learned. However, you see that you could train the model even more on the training set. Try to increase the number of iterations in the cell above and rerun the cells. You might see that the training set accuracy goes up, but the test set accuracy goes down. This is called overfitting.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org567e79b">
<h2 id="org567e79b">6 - Further analysis (optional/ungraded exercise)</h2>
<div class="outline-text-2" id="text-org567e79b">
<p>Congratulations on building your first image classification model. Let's analyze it further, and examine possible choices for the learning rate \(\alpha\).</p>
<p>#### Choice of learning rate ####</p>
<p><b>Reminder</b>: In order for Gradient Descent to work you must choose the learning rate wisely. The learning rate \(\alpha\) determines how rapidly we update the parameters. If the learning rate is too large we may "overshoot" the optimal value. Similarly, if it is too small we will need too many iterations to converge to the best values. That's why it is crucial to use a well-tuned learning rate.</p>
<p>Let's compare the learning curve of our model with several choices of learning rates. Run the cell below. This should take about 1 minute. Feel free also to try different values than the three we have initialized the `learning_rates` variable to contain, and see what happens.</p>
<div class="highlight">
<pre><span></span>learning_rates = [0.01, 0.001, 0.0001]
models = {}
for i in learning_rates:
    print ("learning rate is: " + str(i))
    models[str(i)] = model(train_set_x, train_set_y, test_set_x, test_set_y, num_iterations = 1500, learning_rate = i, print_cost = False)
    print ('\n' + "-------------------------------------------------------" + '\n')
</pre></div>
<div class="highlight">
<pre><span></span>for i in learning_rates:
    plt.plot(np.squeeze(models[str(i)]["costs"]), label= str(models[str(i)]["learning_rate"]))

plt.ylabel('cost')
plt.xlabel('iterations')

legend = plt.legend(loc='upper center', shadow=True)
frame = legend.get_frame()
frame.set_facecolor('0.90')
plt.show()
</pre></div>
<div class="figure" id="org16c57e3">
<p><img alt="tuning_alpha.png" src="file:///tmp/tuning_alpha.png"></p>
</div>
<p><b>Interpretation</b>:</p>
<ul class="org-ul">
<li>Different learning rates give different costs and thus different predictions results.</li>
<li>If the learning rate is too large (0.01), the cost may oscillate up and down. It may even diverge (though in this example, using 0.01 still eventually ends up at a good value for the cost).</li>
<li>A lower cost doesn't mean a better model. You have to check if there is possibly overfitting. It happens when the training accuracy is a lot higher than the test accuracy.</li>
<li>In deep learning, we usually recommend that you:
<ul class="org-ul">
<li>Choose the learning rate that better minimizes the cost function.</li>
<li>If your model overfits, use other techniques to reduce overfitting. (We'll talk about this in later videos.)</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org74057d6">
<h2 id="org74057d6">7 - Test with your own image (optional/ungraded exercise)</h2>
<div class="outline-text-2" id="text-org74057d6">
<p>Congratulations on finishing this assignment. You can use your own image and see the output of your model. To do that:</p>
<ol class="org-ol">
<li>Click on "File" in the upper bar of this notebook, then click "Open" to go on your Coursera Hub.</li>
<li>Add your image to this Jupyter Notebook's directory, in the "images" folder</li>
<li>Change your image's name in the following code</li>
<li>Run the code and check if the algorithm is right (1 = cat, 0 = non-cat)!</li>
</ol>
<div class="highlight">
<pre><span></span>## START CODE HERE ## (PUT YOUR IMAGE NAME) 
my_image = "my_image.jpg"   # change this to the name of your image file 
## END CODE HERE ##
</pre></div>
<div class="highlight">
<pre><span></span># We preprocess the image to fit your algorithm.
fname = "images/" + my_image
image = np.array(ndimage.imread(fname, flatten=False))
my_image = scipy.misc.imresize(image, size=(num_px,num_px)).reshape((1, num_px*num_px*3)).T
my_predicted_image = predict(d["w"], d["b"], my_image)
</pre></div>
<div class="highlight">
<pre><span></span>plt.imshow(image)
</pre></div>
<div class="highlight">
<pre><span></span>print("y = " + str(np.squeeze(my_predicted_image)) + ", your algorithm predicts a \"" + classes[int(np.squeeze(my_predicted_image)),].decode("utf-8") +  "\" picture.")
</pre></div>
<p><b>What to remember from this assignment:</b></p>
<ol class="org-ol">
<li>Preprocessing the dataset is important.</li>
<li>You implemented each function separately: initialize(), propagate(), optimize(). Then you built a model().</li>
<li>Tuning the learning rate (which is an example of a "hyperparameter") can make a big difference to the algorithm. You will see more examples of this later in this course!</li>
</ol>
<p>Finally, if you'd like, we invite you to try different things on this Notebook. Make sure you submit before trying anything. Once you submit, things you can play with include:</p>
<ul class="org-ul">
<li>Play with the learning rate and the number of iterations</li>
<li>Try different initialization methods and compare the results</li>
<li>Test other preprocessings (center the data, or divide each row by its standard deviation)</li>
</ul>
<p>Bibliography:</p>
<ul class="org-ul">
<li><a href="http://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch/">http://www.wildml.com/2015/09/implementing-a-neural-network-from-scratch/</a></li>
<li><a href="https://stats.stackexchange.com/questions/211436/why-do-we-normalize-images-by-subtracting-the-datasets-image-mean-and-not-the-c">https://stats.stackexchange.com/questions/211436/why-do-we-normalize-images-by-subtracting-the-datasets-image-mean-and-not-the-c</a></li>
</ul>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/first-course/basic-numpy-for-neural-networks/index.html">Basic Numpy for Neural Networks</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/first-course/basic-numpy-for-neural-networks/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-02-18T12:55:15-08:00" itemprop="datePublished" title="2021-02-18 12:55">2021-02-18 12:55</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org5e62a72">Beginning</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org6e36281">Imports</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org53d75c8">Set Up</a></li>
</ul>
</li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgd71ab5c">Building basic functions with numpy</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org6d0fa0a">sigmoid function, np.exp()</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org2aa93db">Build a function that returns the sigmoid of a real number x using math.exp(x) for the exponential function.</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org183c5d5">One reason why we use "numpy" instead of "math" in Deep Learning</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgcc9887c">Implement the sigmoid function using numpy.</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgd68f494">Sigmoid gradient</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org3f5a8e1">Plotting The Sigmoid and Its Derivative</a></li>
</ul>
</li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgb8d6acf">Reshaping arrays</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgaa41371">Normalizing rows</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org66f441b">Broadcasting and the softmax function</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org6b7aa16">Vectorization</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgac973fe">Classic (Non-Vectorized)</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org4b227d6">Dot Product Of Vectors Implementation</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org7e751a2">Outer Product Implementation</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgc73bbe3">Elementwise Implementation</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org597cda9">General Dot Product Implementation</a></li>
</ul>
</li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgd943bcd">Vectorized</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org0bb2425">Dot Product Of Vectors</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org1095a74">Outer Product</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgb8c2b8f">Elementwise Multiplication</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orge185fcf">General Dot Product</a></li>
</ul>
</li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgbc4e118">The L1 and L2 loss functions</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#org15fc19d">L1</a></li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orga732a93">L2 Loss</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orgd56f7ec">End</a>
<ul>
<li><a href="posts/first-course/basic-numpy-for-neural-networks/index.html#orga328a8c">Source</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org5e62a72">
<h2 id="org5e62a72">Beginning</h2>
<div class="outline-text-2" id="text-org5e62a72">
<p>Numpy is the main package for scientific computing in Python. It is maintained by a large community (www.numpy.org). In this exercise you will learn several key numpy functions such as np.exp, np.log, and np.reshape.</p>
</div>
<div class="outline-3" id="outline-container-org6e36281">
<h3 id="org6e36281">Imports</h3>
<div class="outline-text-3" id="text-org6e36281">
<div class="highlight">
<pre><span></span><span class="c1"># python</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># pypi</span>
<span class="kn">from</span> <span class="nn">expects</span> <span class="kn">import</span> <span class="n">be_true</span><span class="p">,</span> <span class="n">equal</span><span class="p">,</span> <span class="n">expect</span>

<span class="kn">import</span> <span class="nn">hvplot.pandas</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="c1"># my stuff</span>
<span class="kn">from</span> <span class="nn">graeae</span> <span class="kn">import</span> <span class="n">EmbedHoloviews</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org53d75c8">
<h3 id="org53d75c8">Set Up</h3>
<div class="outline-text-3" id="text-org53d75c8">
<div class="highlight">
<pre><span></span><span class="n">slug</span> <span class="o">=</span> <span class="s2">"basic-numpy-for-neural-networks"</span>
<span class="n">Embed</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="sa">f</span><span class="s2">"files/posts/first-course/</span><span class="si">{</span><span class="n">slug</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">Plot</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"Plot"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"width"</span><span class="p">,</span> <span class="s2">"height"</span><span class="p">,</span> <span class="s2">"fontscale"</span><span class="p">,</span> <span class="s2">"tan"</span><span class="p">,</span> <span class="s2">"blue"</span><span class="p">,</span> <span class="s2">"red"</span><span class="p">])</span>
<span class="n">PLOT</span> <span class="o">=</span> <span class="n">Plot</span><span class="p">(</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">900</span><span class="p">,</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">750</span><span class="p">,</span>
    <span class="n">fontscale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">tan</span><span class="o">=</span><span class="s2">"#ddb377"</span><span class="p">,</span>
    <span class="n">blue</span><span class="o">=</span><span class="s2">"#4687b7"</span><span class="p">,</span>
    <span class="n">red</span><span class="o">=</span><span class="s2">"#ce7b6d"</span><span class="p">,</span>
 <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgd71ab5c">
<h2 id="orgd71ab5c">Building basic functions with numpy</h2>
<div class="outline-text-2" id="text-orgd71ab5c"></div>
<div class="outline-3" id="outline-container-org6d0fa0a">
<h3 id="org6d0fa0a">sigmoid function, np.exp()</h3>
<div class="outline-text-3" id="text-org6d0fa0a">
<p>Before using np.exp(), you will use math.exp() to implement the sigmoid function. You will then see why np.exp() is preferable to math.exp(). (see <a href="https://docs.python.org/3/library/math.html#power-and-logarithmic-functions">python's power and logarithmic functions</a>)</p>
</div>
</div>
<div class="outline-3" id="outline-container-org2aa93db">
<h3 id="org2aa93db">Build a function that returns the sigmoid of a real number x using math.exp(x) for the exponential function.</h3>
<div class="outline-text-3" id="text-org2aa93db">
<p>\(sigmoid(x) = \frac{1}{1+e^{-x}}\) is sometimes also known as the <i>logistic function</i>. It is a non-linear function used not only in Machine Learning (Logistic Regression), but also in Deep Learning.</p>
<div class="highlight">
<pre><span></span><span class="n">TOLERANCE</span> <span class="o">=</span> <span class="mf">0.000001</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">basic_sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Compute sigmoid of x.</span>

<span class="sd">    Args:</span>
<span class="sd">     x: A scalar</span>

<span class="sd">    Returns:</span>
<span class="sd">     s: sigmoid(x)</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">expected</span> <span class="o">=</span> <span class="mf">0.9525741268224334</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">basic_sigmoid</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">expect</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span><span class="n">TOLERANCE</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">be_true</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"sigmoid of 3: </span><span class="si">{</span><span class="n">actual</span><span class="si">:</span><span class="s2">0.3f</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<p>Actually, we rarely use the "math" library in deep learning because the inputs of the functions are real numbers. In deep learning we mostly use matrices and vectors. This is why numpy is more useful.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org183c5d5">
<h3 id="org183c5d5">One reason why we use "numpy" instead of "math" in Deep Learning</h3>
<div class="outline-text-3" id="text-org183c5d5">
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">basic_sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># you will see this give an error when you run it, because x is a vector.</span>
<span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
</pre></div>
<p>In fact, if \(x = (x_1, x_2, ..., x_n)\) is a row vector then \(np.exp(x)\) will apply the exponential function to every element of x. The output will thus be: \(np.exp(x) = (e^{x_1}, e^{x_2}, ..., e^{x_n})\). (see <a href="https://numpy.org/doc/stable/reference/generated/numpy.exp.html">numpy.exp</a>).</p>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
<pre class="example">
[ 2.71828183  7.3890561  20.08553692]
</pre>
<p>Furthermore, if x is a vector, then a Python operation such as \(s = x + 3\) or \(s = \frac{1}{x}\) will output s as a vector of the same size as x.</p>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
<pre class="example">
[4 5 6]
</pre>
<p>Any time you need more info on a numpy function, we encourage you to look at <a href="https://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.exp.html">the official documentation</a>.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgcc9887c">
<h3 id="orgcc9887c">Implement the sigmoid function using numpy.</h3>
<div class="outline-text-3" id="text-orgcc9887c">
<p><b>Instructions</b>: x could now be either a real number, a vector, or a matrix. The data structures we use in numpy to represent these shapes (vectors, matrices…) are called numpy arrays. You don't need to know more for now.</p>
<p>\[ \text{For } x \in \mathbb{R}^n \text{, } sigmoid(x) = sigmoid\begin{pmatrix} x_1 \\ x_2 \\ ... \\ x_n \\ \end{pmatrix} = \begin{pmatrix} \frac{1}{1+e^{-x_1}} \\ \frac{1}{1+e^{-x_2}} \\ ... \\ \frac{1}{1+e^{-x_n}} \\ \end{pmatrix}\tag{1} \]</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Compute the sigmoid of x</span>

<span class="sd">    Args:</span>
<span class="sd">     x: A scalar or numpy array of any size</span>

<span class="sd">    Returns:</span>
<span class="sd">     s: sigmoid(x)</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">expected</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="mf">0.73105858</span><span class="p">,</span>  <span class="mf">0.88079708</span><span class="p">,</span>  <span class="mf">0.95257413</span><span class="p">])</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">be_true</span><span class="p">)</span>
</pre></div>
<pre class="example">
[0.73105858 0.88079708 0.95257413]
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgd68f494">
<h3 id="orgd68f494">Sigmoid gradient</h3>
<div class="outline-text-3" id="text-orgd68f494">
<p>You will need to compute gradients to optimize loss functions using backpropagation. Let's code your first gradient function.</p>
<p>The formula is:</p>
<p>\[ sigmoid\_derivative(x) = \sigma'(x) = \sigma(x) (1 - \sigma(x))\tag{2} \]</p>
<p>You often code this function in two steps:</p>
<ol class="org-ol">
<li>Set s to be the sigmoid of x. You might find your sigmoid(x) function useful.</li>
<li>Compute \(\sigma'(x) = s(1-s)\)</li>
</ol>
<p><a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.randn.html">numpy.random.randn</a> generates a sample from the standard normal distribution.</p>
<div class="highlight">
<pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">sigmoid_derivative</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Compute the gradient (also called the slope or derivative) of the sigmoid</span>
<span class="sd">    function with respect to its input x.</span>

<span class="sd">    Args:</span>
<span class="sd">     x: A scalar or numpy array</span>

<span class="sd">    Returns:</span>
<span class="sd">     ds: Your computed gradient.</span>
<span class="sd">    """</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">expected</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.19661193</span><span class="p">,</span> <span class="mf">0.10499359</span><span class="p">,</span> <span class="mf">0.04517666</span><span class="p">])</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">sigmoid_derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"sigmoid_derivative(x) = </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">be_true</span><span class="p">)</span>
</pre></div>
<pre class="example">
sigmoid_derivative(x) = [0.19661193 0.10499359 0.04517666]
</pre></div>
<div class="outline-4" id="outline-container-org3f5a8e1">
<h4 id="org3f5a8e1">Plotting The Sigmoid and Its Derivative</h4>
<div class="outline-text-4" id="text-org3f5a8e1">
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">siggy</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">siggy_slope</span> <span class="o">=</span> <span class="n">sigmoid_derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">Sigmoid</span><span class="o">=</span><span class="n">siggy</span><span class="p">,</span> <span class="n">Slope</span><span class="o">=</span><span class="n">siggy_slope</span><span class="p">))</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">plot</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">"Sigmoid and Derivative"</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
    <span class="n">height</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
    <span class="n">width</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">width</span><span class="p">,</span>
    <span class="n">fontscale</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">fontscale</span><span class="p">,</span>
    <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">Embed</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">"sigmoid"</span><span class="p">)()</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
<object data="posts/first-course/basic-numpy-for-neural-networks/sigmoid.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgb8d6acf">
<h3 id="orgb8d6acf">Reshaping arrays</h3>
<div class="outline-text-3" id="text-orgb8d6acf">
<p>Two common numpy functions used in deep learning are <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html">np.shape</a> and <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html">np.reshape()</a>.</p>
<ul class="org-ul">
<li>X.shape is used to get the shape (dimension) of a matrix/vector X.</li>
<li>X.reshape(…) is used to reshape X into some other dimension.</li>
</ul>
<p>For example, in computer science, an image is represented by a 3D array of shape \((length, height, depth = 3)\). However, when you read an image as the input of an algorithm you convert it to a vector of shape \((length \times height \times 3, 1)\). In other words, you "unroll", or reshape, the 3D array into a 1D vector.</p>
<p>We'll implemnt <code>image2vector()</code>, a function that takes an input of shape (length, height, 3) and returns a vector of shape \((length\times height\times 3, 1)\). For example, if you would like to reshape an array v of shape (a, b, c) into a vector of shape (\(a \times b, c\)) you would do:</p>
<pre class="example" id="org0a29ba0">
v = v.reshape((v.shape[0] * v.shape[1], v.shape[2]))
</pre>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">image2vector</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Unroll the image</span>

<span class="sd">    Args:</span>
<span class="sd">     image: array of shape (length, height, depth)</span>

<span class="sd">    Returns:</span>
<span class="sd">     v: vector of shape (length*height*depth, 1)</span>
<span class="sd">    """</span>
    <span class="n">length</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">length</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">depth</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
<p>Our image will a 3 by 3 by 2 array, typically images will be \((\textrm{number of pixels}_x, \textrm{number of pixels}_y,3)\) where 3 represents the RGB values</p>
<div class="highlight">
<pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span> <span class="mf">0.67826139</span><span class="p">,</span>  <span class="mf">0.29380381</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.90714982</span><span class="p">,</span>  <span class="mf">0.52835647</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.4215251</span> <span class="p">,</span>  <span class="mf">0.45017551</span><span class="p">]],</span>

                     <span class="p">[[</span> <span class="mf">0.92814219</span><span class="p">,</span>  <span class="mf">0.96677647</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.85304703</span><span class="p">,</span>  <span class="mf">0.52351845</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.19981397</span><span class="p">,</span>  <span class="mf">0.27417313</span><span class="p">]],</span>

                     <span class="p">[[</span> <span class="mf">0.60659855</span><span class="p">,</span>  <span class="mf">0.00533165</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.10820313</span><span class="p">,</span>  <span class="mf">0.49978937</span><span class="p">],</span>
                      <span class="p">[</span> <span class="mf">0.34144279</span><span class="p">,</span>  <span class="mf">0.94630077</span><span class="p">]]])</span>

<span class="n">expected</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">0.67826139</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.29380381</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.90714982</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.52835647</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.4215251</span> <span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.45017551</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.92814219</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.96677647</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.85304703</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.52351845</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.19981397</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.27417313</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.60659855</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.00533165</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.10820313</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.49978937</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.34144279</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.94630077</span><span class="p">]])</span>

<span class="n">actual</span> <span class="o">=</span> <span class="n">image2vector</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"image2vector(image) = </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">length</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span>
<span class="n">expect</span><span class="p">(</span><span class="n">actual</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">length</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">depth</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">be_true</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">be_true</span><span class="p">)</span>
</pre></div>
<pre class="example" id="orgaba1c94">
image2vector(image) = [[0.67826139]
 [0.29380381]
 [0.90714982]
 [0.52835647]
 [0.4215251 ]
 [0.45017551]
 [0.92814219]
 [0.96677647]
 [0.85304703]
 [0.52351845]
 [0.19981397]
 [0.27417313]
 [0.60659855]
 [0.00533165]
 [0.10820313]
 [0.49978937]
 [0.34144279]
 [0.94630077]]
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgaa41371">
<h3 id="orgaa41371">Normalizing rows</h3>
<div class="outline-text-3" id="text-orgaa41371">
<p>Another common technique we use in Machine Learning and Deep Learning is to normalize our data. It often leads to a better performance because gradient descent converges faster after normalization. Here, by normalization we mean changing x to \) \frac{x}{\| x\|} \) (dividing each row vector of x by its norm).</p>
<p>For example, if \[ x = \begin{bmatrix} 0 & 3 & 4 \\ 2 & 6 & 4 \\ \end{bmatrix}\tag{3} \]</p>
<p>then</p>
<p>\[ \| x\| = np.linalg.norm(x, axis = 1, keepdims = True) = \begin{bmatrix} 5 \\ \sqrt{56} \\ \end{bmatrix}\tag{4} \] and</p>
<p>\[ x\_normalized = \frac{x}{\| x\|} = \begin{bmatrix} 0 & \frac{3}{5} & \frac{4}{5} \\ \frac{2}{\sqrt{56}} & \frac{6}{\sqrt{56}} & \frac{4}{\sqrt{56}} \\ \end{bmatrix}\tag{5} \]</p>
<p>Note that you can divide matrices of different sizes and it works fine: this is called broadcasting and you're going to learn about it further down.</p>
<p>Now we'll implement <code>normalizeRows()</code> to normalize the rows of a matrix. After applying this function to an input matrix x, each row of x should be a vector of unit length (meaning length 1).</p>
<p>See: <a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html">numpy.linalg.norm</a></p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">normalizeRows</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Implement a function that normalizes each row of the matrix x </span>
<span class="sd">    (to have unit length).</span>

<span class="sd">    Args:</span>
<span class="sd">     x: A numpy matrix of shape (n, m)</span>

<span class="sd">    Returns:</span>
<span class="sd">     x: The normalized (by row) numpy matrix.</span>
<span class="sd">    """</span>
    <span class="n">x_norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>    
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">x_norm</span>
    <span class="k">return</span> <span class="n">x</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>

<span class="n">expected</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">0.13736056</span><span class="p">,</span>  <span class="mf">0.82416338</span><span class="p">,</span>  <span class="mf">0.54944226</span><span class="p">]])</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">normalizeRows</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"normalizeRows(x) = </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">be_true</span><span class="p">)</span>
</pre></div>
<pre class="example">
normalizeRows(x) = [[0.         0.6        0.8       ]
 [0.13736056 0.82416338 0.54944226]]
</pre>
<p>We can check that each row is a unit vector by calculating the Euclidean distance.</p>
<p>\[ Euclidean = \sqrt{\sum X^2} \]</p>
<div class="highlight">
<pre><span></span><span class="n">SUM_ROWS</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">actual</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">SUM_ROWS</span><span class="p">)))</span>
</pre></div>
<pre class="example">
[1. 1.]
</pre>
<p><b>Note</b>: <code>x_norm</code> and <code>x</code> have different shapes. This is normal given that <code>x_norm</code> takes the norm of each row of <code>x</code>. So <code>x_norm</code> has the same number of rows but only 1 column. As a consequence you can't use <code>x /= x_norm</code> instead of <code>x = x/x_norm</code>. So how did it work when you divided <code>x</code> by <code>x_norm</code>? This is called broadcasting and we'll talk about it next.</p>
</div>
<div class="outline-4" id="outline-container-org66f441b">
<h4 id="org66f441b">Broadcasting and the softmax function</h4>
<div class="outline-text-4" id="text-org66f441b">
<p>A very important concept to understand in numpy is "broadcasting". It is very useful for performing mathematical operations between arrays of different shapes. For the full details on broadcasting, you can read the official <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcasting documentation</a>.</p>
<p>We'll implement a <a href="https://en.wikipedia.org/wiki/Softmax_function">softmax</a> function using numpy. You can think of softmax as a normalizing function used when your algorithm needs to classify two or more classes.</p>
<p><b>The Mathy Definitions</b>: \[ \text{for } x \in \mathbb{R}^{1\times n} \text{, } softmax(x) = softmax(\begin{bmatrix} x_1 &amp;& x_2 &amp;& \ldots &amp;& x_n \end{bmatrix}) = \begin{bmatrix} \frac{e^{x_1}}{\sum_{j}e^{x_j}} &amp;& \frac{e^{x_2}}{\sum_{j}e^{x_j}} &amp;& \ldots &amp;& \frac{e^{x_n}}{\sum_{j}e^{x_j}} \end{bmatrix} \]</p>
<p>\(\text{for a matrix } x \in \mathbb{R}^{m \times n} \text{, x_{ij}}\) maps to the element in the \(i^{th}\) row and \(j^{th}\) column of <i>x</i>, thus we have: \[ softmax(x) = softmax\begin{bmatrix} x_{11} & x_{12} & x_{13} & \dots & x_{1n} \\ x_{21} & x_{22} & x_{23} & \dots & x_{2n} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ x_{m1} & x_{m2} & x_{m3} & \dots & x_{mn} \end{bmatrix} = \begin{bmatrix} \frac{e^{x_{11}}}{\sum_{j}e^{x_{1j}}} & \frac{e^{x_{12}}}{\sum_{j}e^{x_{1j}}} & \frac{e^{x_{13}}}{\sum_{j}e^{x_{1j}}} & \dots & \frac{e^{x_{1n}}}{\sum_{j}e^{x_{1j}}} \\ \frac{e^{x_{21}}}{\sum_{j}e^{x_{2j}}} & \frac{e^{x_{22}}}{\sum_{j}e^{x_{2j}}} & \frac{e^{x_{23}}}{\sum_{j}e^{x_{2j}}} & \dots & \frac{e^{x_{2n}}}{\sum_{j}e^{x_{2j}}} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ \frac{e^{x_{m1}}}{\sum_{j}e^{x_{mj}}} & \frac{e^{x_{m2}}}{\sum_{j}e^{x_{mj}}} & \frac{e^{x_{m3}}}{\sum_{j}e^{x_{mj}}} & \dots & \frac{e^{x_{mn}}}{\sum_{j}e^{x_{mj}}} \end{bmatrix} = \begin{pmatrix} softmax\text{(first row of x)} \\ softmax\text{(second row of x)} \\ \ldots \\ softmax\text{(last row of x)} \\ \end{pmatrix} \]</p>
<p>See also: <a href="https://numpy.org/doc/stable/reference/generated/numpy.sum.html">numpy.sum</a></p>
<div class="highlight">
<pre><span></span><span class="n">ROW_SUMS</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Calculates the softmax for each row of the input x.</span>

<span class="sd">    Args:</span>
<span class="sd">     x: A numpy matrix of shape (n,m)</span>

<span class="sd">    Returns:</span>
<span class="sd">     s: A numpy matrix equal to the softmax of x, of shape (n,m)</span>
<span class="sd">    """</span>
    <span class="n">x_exp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_sum</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x_exp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ROW_SUMS</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x_exp</span><span class="o">/</span><span class="n">x_sum</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">expected</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">9.80897665e-01</span><span class="p">,</span> <span class="mf">8.94462891e-04</span><span class="p">,</span> <span class="mf">1.79657674e-02</span><span class="p">,</span>
                          <span class="mf">1.21052389e-04</span><span class="p">,</span> <span class="mf">1.21052389e-04</span><span class="p">],</span>
                        <span class="p">[</span> <span class="mf">8.78679856e-01</span><span class="p">,</span> <span class="mf">1.18916387e-01</span><span class="p">,</span> <span class="mf">8.01252314e-04</span><span class="p">,</span>
                          <span class="mf">8.01252314e-04</span><span class="p">,</span> <span class="mf">8.01252314e-04</span><span class="p">]])</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="n">actual</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"softmax(x) = </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">actual</span><span class="p">,</span> <span class="n">TOLERANCE</span><span class="p">))</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">be_true</span><span class="p">)</span>
</pre></div>
<pre class="example">
softmax(x) = [[9.80897665e-01 8.94462891e-04 1.79657674e-02 1.21052389e-04
  1.21052389e-04]
 [8.78679856e-01 1.18916387e-01 8.01252314e-04 8.01252314e-04
  8.01252314e-04]]
</pre>
<p><b>Note</b>:</p>
<ul class="org-ul">
<li>If you print the shapes of x_exp, x_sum and s above and rerun the assessment cell, you will see that x_sum is of shape (2,1) while x_exp and s are of shape (2,5). <b>x_exp/x_sum</b> works due to python broadcasting.</li>
</ul>
<p><b>What you need to remember:</b></p>
<ul class="org-ul">
<li>np.exp(x) works for any np.array x and applies the exponential function to every coordinate</li>
<li>the sigmoid function and its gradient</li>
<li>Some equivalent of <code>image2vector</code> is commonly used in deep learning</li>
<li>np.reshape is widely used. In the future, you'll see that keeping your matrix/vector dimensions straight will go toward eliminating a lot of bugs.</li>
<li>numpy has efficient built-in functions</li>
<li>broadcasting is extremely useful</li>
</ul>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org6b7aa16">
<h2 id="org6b7aa16">Vectorization</h2>
<div class="outline-text-2" id="text-org6b7aa16">
<p>In deep learning, you deal with very large datasets. Hence, a non-computationally-optimal function can become a huge bottleneck in your algorithm and can result in a model that takes ages to run. To make sure that your code is computationally efficient, you will use vectorization. For example, try to tell the difference between the following implementations of the dot/outer/elementwise product.</p>
<div class="highlight">
<pre><span></span><span class="n">x1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">CLASSIC</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgac973fe">
<h3 id="orgac973fe">Classic (Non-Vectorized)</h3>
<div class="outline-text-3" id="text-orgac973fe"></div>
<div class="outline-4" id="outline-container-org4b227d6">
<h4 id="org4b227d6">Dot Product Of Vectors Implementation</h4>
<div class="outline-text-4" id="text-org4b227d6">
<div class="highlight">
<pre><span></span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">dot</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)):</span>
    <span class="n">dot</span><span class="o">+=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">CLASSIC</span><span class="p">[</span><span class="s2">"dot"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"dot = </span><span class="si">{</span><span class="n">dot</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'dot'</span><span class="p">]</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example">
dot = 278 
 ----- Computation time = 0.09222100000005895 ms
</pre></div>
</div>
<div class="outline-4" id="outline-container-org7e751a2">
<h4 id="org7e751a2">Outer Product Implementation</h4>
<div class="outline-text-4" id="text-org7e751a2">
<div class="highlight">
<pre><span></span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">outer</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)):</span>
        <span class="n">outer</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">CLASSIC</span><span class="p">[</span><span class="s2">"outer"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"outer = </span><span class="si">{</span><span class="n">outer</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'outer'</span><span class="p">]</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org706491b">
outer = [[81. 18. 18. 81.  0. 81. 18. 45.  0.  0. 81. 18. 45.  0.  0.]
 [18.  4.  4. 18.  0. 18.  4. 10.  0.  0. 18.  4. 10.  0.  0.]
 [45. 10. 10. 45.  0. 45. 10. 25.  0.  0. 45. 10. 25.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
 [63. 14. 14. 63.  0. 63. 14. 35.  0.  0. 63. 14. 35.  0.  0.]
 [45. 10. 10. 45.  0. 45. 10. 25.  0.  0. 45. 10. 25.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
 [81. 18. 18. 81.  0. 81. 18. 45.  0.  0. 81. 18. 45.  0.  0.]
 [18.  4.  4. 18.  0. 18.  4. 10.  0.  0. 18.  4. 10.  0.  0.]
 [45. 10. 10. 45.  0. 45. 10. 25.  0.  0. 45. 10. 25.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]]
 ----- Computation time = 0.2285300000002266 ms
</pre></div>
</div>
<div class="outline-4" id="outline-container-orgc73bbe3">
<h4 id="orgc73bbe3">Elementwise Implementation</h4>
<div class="outline-text-4" id="text-orgc73bbe3">
<div class="highlight">
<pre><span></span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">mul</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)):</span>
    <span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">CLASSIC</span><span class="p">[</span><span class="s2">"elementwise"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"elementwise multiplication = </span><span class="si">{</span><span class="n">mul</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'elementwise'</span><span class="p">]</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example">
elementwise multiplication = [81.  4. 10.  0.  0. 63. 10.  0.  0.  0. 81.  4. 25.  0.  0.]
 ----- Computation time = 0.10630600000016699 ms
</pre></div>
</div>
<div class="outline-4" id="outline-container-org597cda9">
<h4 id="org597cda9">General Dot Product Implementation</h4>
<div class="outline-text-4" id="text-org597cda9">
<div class="highlight">
<pre><span></span><span class="n">W</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
<span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">gdot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)):</span>
        <span class="n">gdot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">x1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">CLASSIC</span><span class="p">[</span><span class="s2">"general_dot"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"gdot = </span><span class="si">{</span><span class="n">gdot</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'general_dot'</span><span class="p">]</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example">
gdot = [26.7997887  21.98533453 17.23427487]
 ----- Computation time = 0.14043400000041117 ms
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgd943bcd">
<h3 id="orgd943bcd">Vectorized</h3>
<div class="outline-text-3" id="text-orgd943bcd"></div>
<div class="outline-4" id="outline-container-org0bb2425">
<h4 id="org0bb2425">Dot Product Of Vectors</h4>
<div class="outline-text-4" id="text-org0bb2425">
<div class="highlight">
<pre><span></span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">dot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">DOT</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"dot = </span><span class="si">{</span><span class="n">dot</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">DOT</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Difference: </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'dot'</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DOT</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example">
dot = 278
 ----- Computation time = 0.11425399999964725 ms
Difference: -0.0220329999995883 ms
</pre>
<p>So for this small set, the pure python is faster.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org1095a74">
<h4 id="org1095a74">Outer Product</h4>
<div class="outline-text-4" id="text-org1095a74">
<div class="highlight">
<pre><span></span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">outer</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">OUTER</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"outer = </span><span class="si">{</span><span class="n">outer</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">OUTER</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Difference: </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'outer'</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">OUTER</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example" id="orgdfc6dab">
outer = [[81 18 18 81  0 81 18 45  0  0 81 18 45  0  0]
 [18  4  4 18  0 18  4 10  0  0 18  4 10  0  0]
 [45 10 10 45  0 45 10 25  0  0 45 10 25  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [63 14 14 63  0 63 14 35  0  0 63 14 35  0  0]
 [45 10 10 45  0 45 10 25  0  0 45 10 25  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [81 18 18 81  0 81 18 45  0  0 81 18 45  0  0]
 [18  4  4 18  0 18  4 10  0  0 18  4 10  0  0]
 [45 10 10 45  0 45 10 25  0  0 45 10 25  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]
 [ 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]]
 ----- Computation time = 0.09857899999943243 ms
Difference: 0.12995100000079418 ms
</pre>
<p>Now numpy is a little faster.</p>
</div>
</div>
<div class="outline-4" id="outline-container-orgb8c2b8f">
<h4 id="orgb8c2b8f">Elementwise Multiplication</h4>
<div class="outline-text-4" id="text-orgb8c2b8f">
<div class="highlight">
<pre><span></span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">mul</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">ELEMENTWISE</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"elementwise multiplication = </span><span class="si">{</span><span class="n">mul</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">ELEMENTWISE</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Difference: </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'elementwise'</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ELEMENTWISE</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example">
elementwise multiplication = [81  4 10  0  0 63 10  0  0  0 81  4 25  0  0]
 ----- Computation time = 0.07506199999962604 ms
Difference: 0.03124400000054095 ms
</pre></div>
</div>
<div class="outline-4" id="outline-container-orge185fcf">
<h4 id="orge185fcf">General Dot Product</h4>
<div class="outline-text-4" id="text-orge185fcf">
<div class="highlight">
<pre><span></span><span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">dot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">x1</span><span class="p">)</span>
<span class="n">toc</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
<span class="n">GENERAL</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">toc</span> <span class="o">-</span> <span class="n">tic</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"gdot = </span><span class="si">{</span><span class="n">dot</span><span class="si">}</span><span class="se">\n</span><span class="s2"> ----- Computation time = </span><span class="si">{</span><span class="n">GENERAL</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Difference: </span><span class="si">{</span><span class="n">CLASSIC</span><span class="p">[</span><span class="s1">'general_dot'</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">GENERAL</span><span class="si">}</span><span class="s2"> ms"</span><span class="p">)</span>
</pre></div>
<pre class="example">
gdot = [26.7997887  21.98533453 17.23427487]
 ----- Computation time = 0.10962399999936423 ms
Difference: 0.030810000001046944 ms
</pre>
<p>As you may have noticed, the vectorized implementation is much cleaner and somewhat more efficient. For bigger vectors/matrices, the differences in running time become even bigger.</p>
<p><b>Note</b> that <code>np.dot()</code> performs a matrix-matrix or matrix-vector multiplication. This is different from <code>np.multiply()</code> and the <code>*</code> operator (which is equivalent to <code>.*</code> in Matlab/Octave), which performs an element-wise multiplication.</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgbc4e118">
<h3 id="orgbc4e118">The L1 and L2 loss functions</h3>
<div class="outline-text-3" id="text-orgbc4e118"></div>
<div class="outline-4" id="outline-container-org15fc19d">
<h4 id="org15fc19d">L1</h4>
<div class="outline-text-4" id="text-org15fc19d">
<p>Now we'll implement the numpy vectorized version of the L1 loss.</p>
<p><b>Reminder</b>: The loss is used to evaluate the performance of your model. The bigger your loss is, the more different your predictions (\( \hat{y} \)) are from the true values (<i>y</i>). In deep learning, you use optimization algorithms like Gradient Descent to train your model and to minimize the cost. L1 loss is defined as:</p>
<p>\[ \begin{align*} & L_1(\hat{y}, y) = \sum_{i=0}^m \left|y^{(i)} - \hat{y}^{(i)}\right| \end{align*}\tag{6} \]</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">L1</span><span class="p">(</span><span class="n">yhat</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""L1 Loss</span>

<span class="sd">    Args:</span>
<span class="sd">     yhat: vector of size m (predicted labels)</span>
<span class="sd">     y: vector of size m (true labels)</span>

<span class="sd">    Returns:</span>
<span class="sd">     loss: the value of the L1 loss function defined above</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yhat</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">yhat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.9</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">.4</span><span class="p">,</span> <span class="mf">.9</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">expected</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">L1</span><span class="p">(</span><span class="n">yhat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"L1 = </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">expected</span><span class="p">))</span>
</pre></div>
<pre class="example">
L1 = 1.1
</pre></div>
</div>
<div class="outline-4" id="outline-container-orga732a93">
<h4 id="orga732a93">L2 Loss</h4>
<div class="outline-text-4" id="text-orga732a93">
<p>Next we'll implement the numpy vectorized version of the L2 loss. There are several ways of implementing the L2 loss but we'll use the function np.dot(). As a reminder, if \(x = [x_1, x_2, \ldots, x_n]\), then <code>np.dot(x,x)</code> = \(\sum_{j=0}^n x_j^{2}\).</p>
<p>L2 loss is defined as \[ L_2(\hat{y},y) = \sum_{i=0}^m\left(y^{(i)} - \hat{y}^{(i)}\right)^2\tag{7} \]</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">L2</span><span class="p">(</span><span class="n">yhat</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Calculate the L2 Loss</span>

<span class="sd">    Args:</span>
<span class="sd">     yhat: vector of size m (predicted labels)</span>
<span class="sd">     y: vector of size m (true labels)</span>

<span class="sd">    Returns:</span>
<span class="sd">     loss: the value of the L2 loss function defined above</span>
<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">yhat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">yhat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.9</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">.4</span><span class="p">,</span> <span class="mf">.9</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">expected</span> <span class="o">=</span> <span class="mf">0.43</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">L2</span><span class="p">(</span><span class="n">yhat</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"L2 = </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">expect</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">expected</span><span class="p">))</span>
</pre></div>
<pre class="example">
L2 = 0.43
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgd56f7ec">
<h2 id="orgd56f7ec">End</h2>
<div class="outline-text-2" id="text-orgd56f7ec">
<p><b>What to remember:</b></p>
<ul class="org-ul">
<li>Vectorization is very important in deep learning. It provides computational efficiency and clarity.</li>
<li>You have reviewed the L1 and L2 loss.</li>
<li>You are familiar with many numpy functions such as np.sum, np.dot, np.multiply, np.maximum, etc…</li>
</ul>
</div>
<div class="outline-3" id="outline-container-orga328a8c">
<h3 id="orga328a8c">Source</h3>
<div class="outline-text-3" id="text-orga328a8c">
<p>This was an exercise from DeepLearning.ai's first Coursera course. (link to come)</p>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nlp/neural-machine-translation-testing-the-model/index.html">Neural Machine Translation: Testing the Model</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nlp/neural-machine-translation-testing-the-model/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-02-14T14:54:56-08:00" itemprop="datePublished" title="2021-02-14 14:54">2021-02-14 14:54</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/nlp/neural-machine-translation-testing-the-model/index.html#orgb5b9746">Testing the Model</a></li>
<li><a href="posts/nlp/neural-machine-translation-testing-the-model/index.html#orgb73b577">End</a></li>
<li><a href="posts/nlp/neural-machine-translation-testing-the-model/index.html#orgbf76e59">Raw</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgb5b9746">
<h2 id="orgb5b9746">Testing the Model</h2>
<div class="outline-text-2" id="text-orgb5b9746">
<p>In the <a href="posts/nlp/neural-machine-translation-training-the-model/index.html">previous post</a> we trained our machine translation model so now it's time to test it and see how well it does.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgb73b577">
<h2 id="orgb73b577">End</h2>
<div class="outline-text-2" id="text-orgb73b577">
<p>The overview post with links to all the posts in this series is <a href="posts/nlp/neural-machine-translation/index.html">here</a>.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgbf76e59">
<h2 id="orgbf76e59">Raw</h2>
<div class="outline-text-2" id="text-orgbf76e59">
<pre class="example" id="org57c9f66">
# # Part 4:  Testing
# 
# We will now be using the model you just trained to translate English sentences to German. We will implement this with two functions: The first allows you to identify the next symbol (i.e. output token). The second one takes care of combining the entire translated string.
# 
# We will start by first loading in a pre-trained copy of the model you just coded. Please run the cell below to do just that.

# In[ ]:


# instantiate the model we built in eval mode
model = NMTAttn(mode='eval')

# initialize weights from a pre-trained model
model.init_from_file("model.pkl.gz", weights_only=True)
model = tl.Accelerate(model)


# &lt;a name="4.1"&gt;&lt;/a&gt;
# ## 4.1  Decoding
# 
# As discussed in the lectures, there are several ways to get the next token when translating a sentence. For instance, we can just get the most probable token at each step (i.e. greedy decoding) or get a sample from a distribution. We can generalize the implementation of these two approaches by using the `tl.logsoftmax_sample()` method. Let's briefly look at its implementation:
# 
# ```python
# def logsoftmax_sample(log_probs, temperature=1.0):  # pylint: disable=invalid-name
#   """Returns a sample from a log-softmax output, with temperature.
# 
#   Args:
#     log_probs: Logarithms of probabilities (often coming from LogSofmax)
#     temperature: For scaling before sampling (1.0 = default, 0.0 = pick argmax)
#   """
#   # This is equivalent to sampling from a softmax with temperature.
#   u = np.random.uniform(low=1e-6, high=1.0 - 1e-6, size=log_probs.shape)
#   g = -np.log(-np.log(u))
#   return np.argmax(log_probs + g * temperature, axis=-1)
# ```
# 
# The key things to take away here are: 1. it gets random samples with the same shape as your input (i.e. `log_probs`), and 2. the amount of "noise" added to the input by these random samples is scaled by a `temperature` setting. You'll notice that setting it to `0` will just make the return statement equal to getting the argmax of `log_probs`. This will come in handy later. 
# 
# &lt;a name="ex06"&gt;&lt;/a&gt;
# ### Exercise 06
# 
# **Instructions:** Implement the `next_symbol()` function that takes in the `input_tokens` and the `cur_output_tokens`, then return the index of the next word. You can click below for hints in completing this exercise.
# 
# &lt;details&gt;    
# &lt;summary&gt;
#     &lt;font size="3" color="darkgreen"&gt;&lt;b&gt;Click Here for Hints&lt;/b&gt;&lt;/font&gt;
# &lt;/summary&gt;
# &lt;p&gt;
# &lt;ul&gt;
#     &lt;li&gt;To get the next power of two, you can compute &lt;i&gt;2^log_2(token_length + 1)&lt;/i&gt; . We add 1 to avoid &lt;i&gt;log(0).&lt;/i&gt;&lt;/li&gt;
#     &lt;li&gt;You can use &lt;i&gt;np.ceil()&lt;/i&gt; to get the ceiling of a float.&lt;/li&gt;
#     &lt;li&gt;&lt;i&gt;np.log2()&lt;/i&gt; will get the logarithm base 2 of a value&lt;/li&gt;
#     &lt;li&gt;&lt;i&gt;int()&lt;/i&gt; will cast a value into an integer type&lt;/li&gt;
#     &lt;li&gt;From the model diagram in part 2, you know that it takes two inputs. You can feed these with this syntax to get the model outputs: &lt;i&gt;model((input1, input2))&lt;/i&gt;. It's up to you to determine which variables below to substitute for input1 and input2. Remember also from the diagram that the output has two elements: [log probabilities, target tokens]. You won't need the target tokens so we assigned it to _ below for you. &lt;/li&gt;
#     &lt;li&gt; The log probabilities output will have the shape: (batch size, decoder length, vocab size). It will contain log probabilities for each token in the &lt;i&gt;cur_output_tokens&lt;/i&gt; plus 1 for the start symbol introduced by the ShiftRight in the preattention decoder. For example, if cur_output_tokens is [1, 2, 5], the model will output an array of log probabilities each for tokens 0 (start symbol), 1, 2, and 5. To generate the next symbol, you just want to get the log probabilities associated with the last token (i.e. token 5 at index 3). You can slice the model output at [0, 3, :] to get this. It will be up to you to generalize this for any length of cur_output_tokens &lt;/li&gt;
# &lt;/ul&gt;
# 

# In[ ]:


# UNQ_C6
# GRADED FUNCTION
def next_symbol(NMTAttn, input_tokens, cur_output_tokens, temperature):
    """Returns the index of the next token.

    Args:
        NMTAttn (tl.Serial): An LSTM sequence-to-sequence model with attention.
        input_tokens (np.ndarray 1 x n_tokens): tokenized representation of the input sentence
        cur_output_tokens (list): tokenized representation of previously translated words
        temperature (float): parameter for sampling ranging from 0.0 to 1.0.
            0.0: same as argmax, always pick the most probable token
            1.0: sampling from the distribution (can sometimes say random things)

    Returns:
        int: index of the next token in the translated sentence
        float: log probability of the next symbol
    """

    ### START CODE HERE (REPLACE INSTANCES OF `None` WITH YOUR CODE) ###

    # set the length of the current output tokens
    token_length = None

    # calculate next power of 2 for padding length 
    padded_length = None

    # pad cur_output_tokens up to the padded_length
    padded = cur_output_tokens + None
    
    # model expects the output to have an axis for the batch size in front so
    # convert `padded` list to a numpy array with shape (x, &lt;padded_length&gt;) where the
    # x position is the batch axis. (hint: you can use np.expand_dims() with axis=0 to insert a new axis)
    padded_with_batch = None

    # get the model prediction. remember to use the `NMTAttn` argument defined above.
    # hint: the model accepts a tuple as input (e.g. `my_model((input1, input2))`)
    output, _ = None
    
    # get log probabilities from the last token output
    log_probs = output[None]

    # get the next symbol by getting a logsoftmax sample (*hint: cast to an int)
    symbol = None
    
    ### END CODE HERE ###

    return symbol, float(log_probs[symbol])


# In[ ]:


# BEGIN UNIT TEST
w1_unittest.test_next_symbol(next_symbol, model)
# END UNIT TEST


# Now you will implement the `sampling_decode()` function. This will call the `next_symbol()` function above several times until the next output is the end-of-sentence token (i.e. `EOS`). It takes in an input string and returns the translated version of that string.
# 
# &lt;a name="ex07"&gt;&lt;/a&gt;
# ### Exercise 07
# 
# **Instructions**: Implement the `sampling_decode()` function.

# In[ ]:


# UNQ_C7
# GRADED FUNCTION
def sampling_decode(input_sentence, NMTAttn = None, temperature=0.0, vocab_file=None, vocab_dir=None):
    """Returns the translated sentence.

    Args:
        input_sentence (str): sentence to translate.
        NMTAttn (tl.Serial): An LSTM sequence-to-sequence model with attention.
        temperature (float): parameter for sampling ranging from 0.0 to 1.0.
            0.0: same as argmax, always pick the most probable token
            1.0: sampling from the distribution (can sometimes say random things)
        vocab_file (str): filename of the vocabulary
        vocab_dir (str): path to the vocabulary file

    Returns:
        tuple: (list, str, float)
            list of int: tokenized version of the translated sentence
            float: log probability of the translated sentence
            str: the translated sentence
    """
    
    ### START CODE HERE (REPLACE INSTANCES OF `None` WITH YOUR CODE) ###
    
    # encode the input sentence
    input_tokens = None
    
    # initialize the list of output tokens
    cur_output_tokens = None
    
    # initialize an integer that represents the current output index
    cur_output = None
    
    # Set the encoding of the "end of sentence" as 1
    EOS = None
    
    # check that the current output is not the end of sentence token
    while cur_output != EOS:
        
        # update the current output token by getting the index of the next word (hint: use next_symbol)
        cur_output, log_prob = None
        
        # append the current output token to the list of output tokens
        cur_output_tokens.append(cur_output)
    
    # detokenize the output tokens
    sentence = None
    
    ### END CODE HERE ###
    
    return cur_output_tokens, log_prob, sentence


# In[ ]:


# Test the function above. Try varying the temperature setting with values from 0 to 1.
# Run it several times with each setting and see how often the output changes.
sampling_decode("I love languages.", model, temperature=0.0, vocab_file=VOCAB_FILE, vocab_dir=VOCAB_DIR)


# In[ ]:


# BEGIN UNIT TEST
w1_unittest.test_sampling_decode(sampling_decode, model)
# END UNIT TEST


# We have set a default value of `0` to the temperature setting in our implementation of `sampling_decode()` above. As you may have noticed in the `logsoftmax_sample()` method, this setting will ultimately result in greedy decoding. As mentioned in the lectures, this algorithm generates the translation by getting the most probable word at each step. It gets the argmax of the output array of your model and then returns that index. See the testing function and sample inputs below. You'll notice that the output will remain the same each time you run it.

# In[ ]:


def greedy_decode_test(sentence, NMTAttn=None, vocab_file=None, vocab_dir=None):
    """Prints the input and output of our NMTAttn model using greedy decode

    Args:
        sentence (str): a custom string.
        NMTAttn (tl.Serial): An LSTM sequence-to-sequence model with attention.
        vocab_file (str): filename of the vocabulary
        vocab_dir (str): path to the vocabulary file

    Returns:
        str: the translated sentence
    """
    
    _,_, translated_sentence = sampling_decode(sentence, NMTAttn, vocab_file=vocab_file, vocab_dir=vocab_dir)
    
    print("English: ", sentence)
    print("German: ", translated_sentence)
    
    return translated_sentence


# In[ ]:


# put a custom string here
your_sentence = 'I love languages.'

greedy_decode_test(your_sentence, model, vocab_file=VOCAB_FILE, vocab_dir=VOCAB_DIR);


# In[ ]:


greedy_decode_test('You are almost done with the assignment!', model, vocab_file=VOCAB_FILE, vocab_dir=VOCAB_DIR);


# &lt;a name="4.2"&gt;&lt;/a&gt;
# ## 4.2  Minimum Bayes-Risk Decoding
# 
# As mentioned in the lectures, getting the most probable token at each step may not necessarily produce the best results. Another approach is to do Minimum Bayes Risk Decoding or MBR. The general steps to implement this are:
# 
# 1. take several random samples
# 2. score each sample against all other samples
# 3. select the one with the highest score
# 
# You will be building helper functions for these steps in the following sections.

# &lt;a name='4.2.1'&gt;&lt;/a&gt;
# ### 4.2.1 Generating samples
# 
# First, let's build a function to generate several samples. You can use the `sampling_decode()` function you developed earlier to do this easily. We want to record the token list and log probability for each sample as these will be needed in the next step.

# In[ ]:


def generate_samples(sentence, n_samples, NMTAttn=None, temperature=0.6, vocab_file=None, vocab_dir=None):
    """Generates samples using sampling_decode()

    Args:
        sentence (str): sentence to translate.
        n_samples (int): number of samples to generate
        NMTAttn (tl.Serial): An LSTM sequence-to-sequence model with attention.
        temperature (float): parameter for sampling ranging from 0.0 to 1.0.
            0.0: same as argmax, always pick the most probable token
            1.0: sampling from the distribution (can sometimes say random things)
        vocab_file (str): filename of the vocabulary
        vocab_dir (str): path to the vocabulary file
        
    Returns:
        tuple: (list, list)
            list of lists: token list per sample
            list of floats: log probability per sample
    """
    # define lists to contain samples and probabilities
    samples, log_probs = [], []

    # run a for loop to generate n samples
    for _ in range(n_samples):
        
        # get a sample using the sampling_decode() function
        sample, logp, _ = sampling_decode(sentence, NMTAttn, temperature, vocab_file=vocab_file, vocab_dir=vocab_dir)
        
        # append the token list to the samples list
        samples.append(sample)
        
        # append the log probability to the log_probs list
        log_probs.append(logp)
                
    return samples, log_probs


# In[ ]:


# generate 4 samples with the default temperature (0.6)
generate_samples('I love languages.', 4, model, vocab_file=VOCAB_FILE, vocab_dir=VOCAB_DIR)


# ### 4.2.2 Comparing overlaps
# 
# Let us now build our functions to compare a sample against another. There are several metrics available as shown in the lectures and you can try experimenting with any one of these. For this assignment, we will be calculating scores for unigram overlaps. One of the more simple metrics is the [Jaccard similarity](https://en.wikipedia.org/wiki/Jaccard_index) which gets the intersection over union of two sets. We've already implemented it below for your perusal.

# In[ ]:


def jaccard_similarity(candidate, reference):
    """Returns the Jaccard similarity between two token lists

    Args:
        candidate (list of int): tokenized version of the candidate translation
        reference (list of int): tokenized version of the reference translation

    Returns:
        float: overlap between the two token lists
    """
    
    # convert the lists to a set to get the unique tokens
    can_unigram_set, ref_unigram_set = set(candidate), set(reference)  
    
    # get the set of tokens common to both candidate and reference
    joint_elems = can_unigram_set.intersection(ref_unigram_set)
    
    # get the set of all tokens found in either candidate or reference
    all_elems = can_unigram_set.union(ref_unigram_set)
    
    # divide the number of joint elements by the number of all elements
    overlap = len(joint_elems) / len(all_elems)
    
    return overlap


# In[ ]:


# let's try using the function. remember the result here and compare with the next function below.
jaccard_similarity([1, 2, 3], [1, 2, 3, 4])


# One of the more commonly used metrics in machine translation is the ROUGE score. For unigrams, this is called ROUGE-1 and as shown in class, you can output the scores for both precision and recall when comparing two samples. To get the final score, you will want to compute the F1-score as given by:
# 
# $$score = 2* \frac{(precision * recall)}{(precision + recall)}$$
# 
# &lt;a name="ex08"&gt;&lt;/a&gt;
# ### Exercise 08
# 
# **Instructions**: Implement the `rouge1_similarity()` function.

# In[ ]:


# UNQ_C8
# GRADED FUNCTION

# for making a frequency table easily
from collections import Counter

def rouge1_similarity(system, reference):
    """Returns the ROUGE-1 score between two token lists

    Args:
        system (list of int): tokenized version of the system translation
        reference (list of int): tokenized version of the reference translation

    Returns:
        float: overlap between the two token lists
    """    
    
    ### START CODE HERE (REPLACE INSTANCES OF `None` WITH YOUR CODE) ###
    
    # make a frequency table of the system tokens (hint: use the Counter class)
    sys_counter = None
    
    # make a frequency table of the reference tokens (hint: use the Counter class)
    ref_counter = None
    
    # initialize overlap to 0
    overlap = None
    
    # run a for loop over the sys_counter object (can be treated as a dictionary)
    for token in sys_counter:
        
        # lookup the value of the token in the sys_counter dictionary (hint: use the get() method)
        token_count_sys = None
        
        # lookup the value of the token in the ref_counter dictionary (hint: use the get() method)
        token_count_ref = None
        
        # update the overlap by getting the smaller number between the two token counts above
        overlap += None
    
    # get the precision (i.e. number of overlapping tokens / number of system tokens)
    precision = None
    
    # get the recall (i.e. number of overlapping tokens / number of reference tokens)
    recall = None
    
    if precision + recall != 0:
        # compute the f1-score
        rouge1_score = None
    else:
        rouge1_score = 0 
    ### END CODE HERE ###
    
    return rouge1_score
    


# In[ ]:


# notice that this produces a different value from the jaccard similarity earlier
rouge1_similarity([1, 2, 3], [1, 2, 3, 4])


# In[ ]:


# BEGIN UNIT TEST
w1_unittest.test_rouge1_similarity(rouge1_similarity)
# END UNIT TEST


# ### 4.2.3 Overall score
# 
# We will now build a function to generate the overall score for a particular sample. As mentioned earlier, we need to compare each sample with all other samples. For instance, if we generated 30 sentences, we will need to compare sentence 1 to sentences 2 to 30. Then, we compare sentence 2 to sentences 1 and 3 to 30, and so forth. At each step, we get the average score of all comparisons to get the overall score for a particular sample. To illustrate, these will be the steps to generate the scores of a 4-sample list.
# 
# 1. Get similarity score between sample 1 and sample 2
# 2. Get similarity score between sample 1 and sample 3
# 3. Get similarity score between sample 1 and sample 4
# 4. Get average score of the first 3 steps. This will be the overall score of sample 1.
# 5. Iterate and repeat until samples 1 to 4 have overall scores.
# 
# We will be storing the results in a dictionary for easy lookups.
# 
# &lt;a name="ex09"&gt;&lt;/a&gt;
# ### Exercise 09
# 
# **Instructions**: Implement the `average_overlap()` function.

# In[ ]:


# UNQ_C9
# GRADED FUNCTION
def average_overlap(similarity_fn, samples, *ignore_params):
    """Returns the arithmetic mean of each candidate sentence in the samples

    Args:
        similarity_fn (function): similarity function used to compute the overlap
        samples (list of lists): tokenized version of the translated sentences
        *ignore_params: additional parameters will be ignored

    Returns:
        dict: scores of each sample
            key: index of the sample
            value: score of the sample
    """  
    
    # initialize dictionary
    scores = {}
    
    # run a for loop for each sample
    for index_candidate, candidate in enumerate(samples):    
        
        ### START CODE HERE (REPLACE INSTANCES OF `None` WITH YOUR CODE) ###
        
        # initialize overlap to 0.0
        overlap = None
        
        # run a for loop for each sample
        for index_sample, sample in enumerate(samples): 

            # skip if the candidate index is the same as the sample index
            if index_candidate == index_sample:
                continue
                
            # get the overlap between candidate and sample using the similarity function
            sample_overlap = None
            
            # add the sample overlap to the total overlap
            overlap += None
            
        # get the score for the candidate by computing the average
        score = None
        
        # save the score in the dictionary. use index as the key.
        scores[index_candidate] = None
        
        ### END CODE HERE ###
    return scores


# In[ ]:


average_overlap(jaccard_similarity, [[1, 2, 3], [1, 2, 4], [1, 2, 4, 5]], [0.4, 0.2, 0.5])


# In[ ]:


# BEGIN UNIT TEST
w1_unittest.test_average_overlap(average_overlap)
# END UNIT TEST


# In practice, it is also common to see the weighted mean being used to calculate the overall score instead of just the arithmetic mean. We have implemented it below and you can use it in your experiements to see which one will give better results.

# In[ ]:


def weighted_avg_overlap(similarity_fn, samples, log_probs):
    """Returns the weighted mean of each candidate sentence in the samples

    Args:
        samples (list of lists): tokenized version of the translated sentences
        log_probs (list of float): log probability of the translated sentences

    Returns:
        dict: scores of each sample
            key: index of the sample
            value: score of the sample
    """
    
    # initialize dictionary
    scores = {}
    
    # run a for loop for each sample
    for index_candidate, candidate in enumerate(samples):    
        
        # initialize overlap and weighted sum
        overlap, weight_sum = 0.0, 0.0
        
        # run a for loop for each sample
        for index_sample, (sample, logp) in enumerate(zip(samples, log_probs)):

            # skip if the candidate index is the same as the sample index            
            if index_candidate == index_sample:
                continue
                
            # convert log probability to linear scale
            sample_p = float(np.exp(logp))

            # update the weighted sum
            weight_sum += sample_p

            # get the unigram overlap between candidate and sample
            sample_overlap = similarity_fn(candidate, sample)
            
            # update the overlap
            overlap += sample_p * sample_overlap
            
        # get the score for the candidate
        score = overlap / weight_sum
        
        # save the score in the dictionary. use index as the key.
        scores[index_candidate] = score
    
    return scores


# In[ ]:


weighted_avg_overlap(jaccard_similarity, [[1, 2, 3], [1, 2, 4], [1, 2, 4, 5]], [0.4, 0.2, 0.5])


# ### 4.2.4 Putting it all together
# 
# We will now put everything together and develop the `mbr_decode()` function. Please use the helper functions you just developed to complete this. You will want to generate samples, get the score for each sample, get the highest score among all samples, then detokenize this sample to get the translated sentence.
# 
# &lt;a name="ex10"&gt;&lt;/a&gt;
# ### Exercise 10
# 
# **Instructions**: Implement the `mbr_overlap()` function.

# In[ ]:


# UNQ_C10
# GRADED FUNCTION
def mbr_decode(sentence, n_samples, score_fn, similarity_fn, NMTAttn=None, temperature=0.6, vocab_file=None, vocab_dir=None):
    """Returns the translated sentence using Minimum Bayes Risk decoding

    Args:
        sentence (str): sentence to translate.
        n_samples (int): number of samples to generate
        score_fn (function): function that generates the score for each sample
        similarity_fn (function): function used to compute the overlap between a pair of samples
        NMTAttn (tl.Serial): An LSTM sequence-to-sequence model with attention.
        temperature (float): parameter for sampling ranging from 0.0 to 1.0.
            0.0: same as argmax, always pick the most probable token
            1.0: sampling from the distribution (can sometimes say random things)
        vocab_file (str): filename of the vocabulary
        vocab_dir (str): path to the vocabulary file

    Returns:
        str: the translated sentence
    """
    
    ### START CODE HERE (REPLACE INSTANCES OF `None` WITH YOUR CODE) ###
    # generate samples
    samples, log_probs = None
    
    # use the scoring function to get a dictionary of scores
    # pass in the relevant parameters as shown in the function definition of 
    # the mean methods you developed earlier
    scores = None
    
    # find the key with the highest score
    max_index = None
    
    # detokenize the token list associated with the max_index
    translated_sentence = None
    
    ### END CODE HERE ###
    return (translated_sentence, max_index, scores)


# In[ ]:


TEMPERATURE = 1.0

# put a custom string here
your_sentence = 'She speaks English and German.'


# In[ ]:


mbr_decode(your_sentence, 4, weighted_avg_overlap, jaccard_similarity, model, TEMPERATURE, vocab_file=VOCAB_FILE, vocab_dir=VOCAB_DIR)[0]


# In[ ]:


mbr_decode('Congratulations!', 4, average_overlap, rouge1_similarity, model, TEMPERATURE, vocab_file=VOCAB_FILE, vocab_dir=VOCAB_DIR)[0]


# In[ ]:


mbr_decode('You have completed the assignment!', 4, average_overlap, rouge1_similarity, model, TEMPERATURE, vocab_file=VOCAB_FILE, vocab_dir=VOCAB_DIR)[0]


# **This unit test take a while to run. Please be patient**

# In[ ]:


# BEGIN UNIT TEST
w1_unittest.test_mbr_decode(mbr_decode, model)
# END UNIT TEST


# #### Congratulations! Next week, you'll dive deeper into attention models and study the Transformer architecture. You will build another network but without the recurrent part. It will show that attention is all you need! It should be fun!


</pre></div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nlp/neural-machine-translation-training-the-model/index.html">Neural Machine Translation: Training the Model</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nlp/neural-machine-translation-training-the-model/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-02-14T14:54:34-08:00" itemprop="datePublished" title="2021-02-14 14:54">2021-02-14 14:54</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#org647547e">Training Our Model</a>
<ul>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#orgc16e3f4">Imports</a></li>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#org82f8ed0">Set Up</a></li>
</ul>
</li>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#orgc47767d">Training</a>
<ul>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#orgc029fbe">TrainTask</a></li>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#orged412cd">EvalTask</a></li>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#org0226065">Loop</a></li>
</ul>
</li>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#org3b5f4c3">End</a></li>
<li><a href="posts/nlp/neural-machine-translation-training-the-model/index.html#org561dc74">Raw</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org647547e">
<h2 id="org647547e">Training Our Model</h2>
<div class="outline-text-2" id="text-org647547e">
<p>In the <a href="posts/nlp/neural-machine-translation-the-attention-model/index.html">previous post</a> we defined our model for machine translation. In this post we'll train the model on our data.</p>
<p>Doing supervised training in Trax is pretty straightforward (short example <a href="https://trax-ml.readthedocs.io/en/latest/notebooks/trax_intro.html#Supervised-training">here</a>). We will be instantiating three classes for this: <code>TrainTask</code>, <code>EvalTask</code>, and <code>Loop</code>. Let's take a closer look at each of these in the sections below.</p>
</div>
<div class="outline-3" id="outline-container-orgc16e3f4">
<h3 id="orgc16e3f4">Imports</h3>
<div class="outline-text-3" id="text-orgc16e3f4">
<div class="highlight">
<pre><span></span><span class="c1"># python</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">redirect_stdout</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="c1"># pypi</span>
<span class="kn">from</span> <span class="nn">holoviews</span> <span class="kn">import</span> <span class="n">opts</span>
<span class="kn">from</span> <span class="nn">trax</span> <span class="kn">import</span> <span class="n">layers</span><span class="p">,</span> <span class="n">optimizers</span>
<span class="kn">from</span> <span class="nn">trax.supervised</span> <span class="kn">import</span> <span class="n">lr_schedules</span><span class="p">,</span> <span class="n">training</span>

<span class="kn">import</span> <span class="nn">holoviews</span>
<span class="kn">import</span> <span class="nn">hvplot.pandas</span>
<span class="kn">import</span> <span class="nn">pandas</span>

<span class="c1"># this project</span>
<span class="kn">from</span> <span class="nn">neurotic.nlp.machine_translation</span> <span class="kn">import</span> <span class="n">DataGenerator</span><span class="p">,</span> <span class="n">NMTAttn</span>

<span class="c1"># related</span>
<span class="kn">from</span> <span class="nn">graeae</span> <span class="kn">import</span> <span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">Timer</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org82f8ed0">
<h3 id="org82f8ed0">Set Up</h3>
<div class="outline-text-3" id="text-org82f8ed0">
<div class="highlight">
<pre><span></span><span class="n">train_batch_stream</span> <span class="o">=</span> <span class="n">DataGenerator</span><span class="p">()</span><span class="o">.</span><span class="n">batch_generator</span>
<span class="n">eval_batch_stream</span> <span class="o">=</span> <span class="n">DataGenerator</span><span class="p">(</span><span class="n">training</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">batch_generator</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">SLUG</span> <span class="o">=</span> <span class="s2">"neural-machine-translation-training-the-model"</span>
<span class="n">Embed</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="sa">f</span><span class="s2">"files/posts/nlp/</span><span class="si">{</span><span class="n">SLUG</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">Plot</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">"Plot"</span><span class="p">,</span> <span class="p">[</span><span class="s2">"width"</span><span class="p">,</span> <span class="s2">"height"</span><span class="p">,</span> <span class="s2">"fontscale"</span><span class="p">,</span> <span class="s2">"tan"</span><span class="p">,</span> <span class="s2">"blue"</span><span class="p">,</span> <span class="s2">"red"</span><span class="p">])</span>
<span class="n">PLOT</span> <span class="o">=</span> <span class="n">Plot</span><span class="p">(</span>
    <span class="n">width</span><span class="o">=</span><span class="mi">900</span><span class="p">,</span>
    <span class="n">height</span><span class="o">=</span><span class="mi">750</span><span class="p">,</span>
    <span class="n">fontscale</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">tan</span><span class="o">=</span><span class="s2">"#ddb377"</span><span class="p">,</span>
    <span class="n">blue</span><span class="o">=</span><span class="s2">"#4687b7"</span><span class="p">,</span>
    <span class="n">red</span><span class="o">=</span><span class="s2">"#ce7b6d"</span><span class="p">,</span>
 <span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">TIMER</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgc47767d">
<h2 id="orgc47767d">Training</h2>
<div class="outline-text-2" id="text-orgc47767d"></div>
<div class="outline-3" id="outline-container-orgc029fbe">
<h3 id="orgc029fbe">TrainTask</h3>
<div class="outline-text-3" id="text-orgc029fbe">
<p>The <a href="https://trax-ml.readthedocs.io/en/latest/trax.supervised.html#trax.supervised.training.TrainTask">TrainTask</a> class allows us to define the labeled data to use for training and the feedback mechanisms to compute the loss and update the weights.</p>
<div class="highlight">
<pre><span></span><span class="n">train_task</span> <span class="o">=</span> <span class="n">training</span><span class="o">.</span><span class="n">TrainTask</span><span class="p">(</span>

    <span class="c1"># use the train batch stream as labeled data</span>
    <span class="n">labeled_data</span> <span class="o">=</span> <span class="n">train_batch_stream</span><span class="p">,</span>

    <span class="c1"># use the cross entropy loss</span>
    <span class="n">loss_layer</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">WeightedCategoryCrossEntropy</span><span class="p">(),</span>

    <span class="c1"># use the Adam optimizer with learning rate of 0.01</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="mf">0.01</span><span class="p">),</span>

    <span class="c1"># use the `trax.lr.warmup_and_rsqrt_decay` as the learning rate schedule</span>
    <span class="c1"># have 1000 warmup steps with a max value of 0.01</span>
    <span class="n">lr_schedule</span> <span class="o">=</span> <span class="n">lr_schedules</span><span class="o">.</span><span class="n">warmup_and_rsqrt_decay</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">),</span>

    <span class="c1"># have a checkpoint every 10 steps</span>
    <span class="n">n_steps_per_checkpoint</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_train_task</span><span class="p">(</span><span class="n">train_task</span><span class="p">):</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">train_task</span>
    <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fails</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Test the labeled data parameter</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">strlabel</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_labeled_data</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">strlabel</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">"generator"</span><span class="p">)</span> <span class="ow">and</span> <span class="n">strlabel</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">'add_loss_weights'</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Wrong labeled data parameter"</span><span class="p">)</span>

    <span class="c1"># Test the cross entropy loss data parameter</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">strlabel</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_loss_layer</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">strlabel</span> <span class="o">==</span> <span class="s2">"CrossEntropyLoss_in3"</span><span class="p">)</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Wrong loss functions. CrossEntropyLoss_in3 was expected"</span><span class="p">)</span>

     <span class="c1"># Test the optimizer parameter</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">trax</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">adam</span><span class="o">.</span><span class="n">Adam</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Wrong optimizer"</span><span class="p">)</span>

    <span class="c1"># Test the schedule parameter</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_lr_schedule</span><span class="p">,</span><span class="n">trax</span><span class="o">.</span><span class="n">supervised</span><span class="o">.</span><span class="n">lr_schedules</span><span class="o">.</span><span class="n">_BodyAndTail</span><span class="p">))</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Wrong learning rate schedule type"</span><span class="p">)</span>

    <span class="c1"># Test the _n_steps_per_checkpoint parameter</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">_n_steps_per_checkpoint</span><span class="o">==</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"Wrong checkpoint step frequency"</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fails</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\033</span><span class="s2">[92m All tests passed"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[92m'</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span><span class="s2">" Tests passed"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[91m'</span><span class="p">,</span> <span class="n">fails</span><span class="p">,</span> <span class="s2">" Tests failed"</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_train_task</span><span class="p">(</span><span class="n">train_task</span><span class="p">)</span>
</pre></div>
<pre class="example">
Wrong loss functions. CrossEntropyLoss_in3 was expected
Wrong optimizer
Wrong learning rate schedule type
[92m 2  Tests passed
[91m 3  Tests failed
</pre>
<p>The code has changed a bit since the test was written so it won't pass without updates.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orged412cd">
<h3 id="orged412cd">EvalTask</h3>
<div class="outline-text-3" id="text-orged412cd">
<p>The <a href="https://trax-ml.readthedocs.io/en/latest/trax.supervised.html#trax.supervised.training.EvalTask">EvalTask</a> on the other hand allows us to see how the model is doing while training. For our application, we want it to report the cross entropy loss and accuracy.</p>
<div class="highlight">
<pre><span></span><span class="n">eval_task</span> <span class="o">=</span> <span class="n">training</span><span class="o">.</span><span class="n">EvalTask</span><span class="p">(</span>

    <span class="c1">## use the eval batch stream as labeled data</span>
    <span class="n">labeled_data</span><span class="o">=</span><span class="n">eval_batch_stream</span><span class="p">,</span>

    <span class="c1">## use the cross entropy loss and accuracy as metrics</span>
    <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="n">layers</span><span class="o">.</span><span class="n">WeightedCategoryCrossEntropy</span><span class="p">(),</span> <span class="n">layers</span><span class="o">.</span><span class="n">Accuracy</span><span class="p">()],</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org0226065">
<h3 id="org0226065">Loop</h3>
<div class="outline-text-3" id="text-org0226065">
<p>The <a href="https://trax-ml.readthedocs.io/en/latest/trax.supervised.html#trax.supervised.training.Loop">Loop</a> class defines the model we will train as well as the train and eval tasks to execute. Its <code>run()</code> method allows us to execute the training for a specified number of steps.</p>
<div class="highlight">
<pre><span></span><span class="n">output_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">"~/models/machine_translation/"</span><span class="p">)</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>
</pre></div>
<p>Define the training loop.</p>
<div class="highlight">
<pre><span></span><span class="n">training_loop</span> <span class="o">=</span> <span class="n">training</span><span class="o">.</span><span class="n">Loop</span><span class="p">(</span><span class="n">NMTAttn</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">'train'</span><span class="p">),</span>
                              <span class="n">train_task</span><span class="p">,</span>
                              <span class="n">eval_tasks</span><span class="o">=</span><span class="p">[</span><span class="n">eval_task</span><span class="p">],</span>
                              <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">train_steps</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="k">with</span> <span class="n">TIMER</span><span class="p">,</span> \
     <span class="nb">open</span><span class="p">(</span><span class="s2">"/tmp/machine_translation_training.log"</span><span class="p">,</span> <span class="s2">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="n">temp_file</span><span class="p">,</span> \
     <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">temp_file</span><span class="p">):</span>
            <span class="n">training_loop</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">train_steps</span><span class="p">)</span>
</pre></div>
<pre class="example">
Started: 2021-03-09 18:31:58.844878
Ended: 2021-03-09 20:14:43.090358
Elapsed: 1:42:44.245480
</pre>
<div class="highlight">
<pre><span></span><span class="n">frame</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="n">training_loop</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"eval"</span><span class="p">,</span> <span class="s2">"metrics/WeightedCategoryCrossEntropy"</span><span class="p">),</span>
    <span class="n">columns</span><span class="o">=</span><span class="s2">"Batch CrossEntropy"</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="n">minimum</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">CrossEntropy</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()]</span>
<span class="n">vline</span> <span class="o">=</span> <span class="n">holoviews</span><span class="o">.</span><span class="n">VLine</span><span class="p">(</span><span class="n">minimum</span><span class="o">.</span><span class="n">Batch</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">VLine</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">red</span><span class="p">))</span>
<span class="n">hline</span> <span class="o">=</span> <span class="n">holoviews</span><span class="o">.</span><span class="n">HLine</span><span class="p">(</span><span class="n">minimum</span><span class="o">.</span><span class="n">CrossEntropy</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">HLine</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">red</span><span class="p">))</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"Batch"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"CrossEntropy"</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">blue</span><span class="p">))</span>

<span class="n">plot</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span> <span class="o">*</span> <span class="n">hline</span> <span class="o">*</span> <span class="n">vline</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
    <span class="n">width</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="s2">"Evaluation Batch Cross Entropy Loss"</span><span class="p">,</span>
                                   <span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">Embed</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">"evaluation_cross_entropy"</span><span class="p">)()</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
<object data="posts/nlp/neural-machine-translation-training-the-model/evaluation_cross_entropy.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<div class="highlight">
<pre><span></span><span class="n">frame</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
    <span class="n">training_loop</span><span class="o">.</span><span class="n">history</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"eval"</span><span class="p">,</span> <span class="s2">"metrics/Accuracy"</span><span class="p">),</span>
    <span class="n">columns</span><span class="o">=</span><span class="s2">"Batch Accuracy"</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

<span class="n">minimum</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">Accuracy</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()]</span>
<span class="n">vline</span> <span class="o">=</span> <span class="n">holoviews</span><span class="o">.</span><span class="n">VLine</span><span class="p">(</span><span class="n">minimum</span><span class="o">.</span><span class="n">Batch</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">VLine</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">red</span><span class="p">))</span>
<span class="n">hline</span> <span class="o">=</span> <span class="n">holoviews</span><span class="o">.</span><span class="n">HLine</span><span class="p">(</span><span class="n">minimum</span><span class="o">.</span><span class="n">Accuracy</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">HLine</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">red</span><span class="p">))</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">hvplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">"Batch"</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">"Accuracy"</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">blue</span><span class="p">))</span>

<span class="n">plot</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span> <span class="o">*</span> <span class="n">hline</span> <span class="o">*</span> <span class="n">vline</span><span class="p">)</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span>
    <span class="n">width</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">PLOT</span><span class="o">.</span><span class="n">height</span><span class="p">,</span>
    <span class="n">title</span><span class="o">=</span><span class="s2">"Evaluation Batch Accuracy"</span><span class="p">,</span>
                                   <span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">Embed</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">"evaluation_accuracy"</span><span class="p">)()</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
<object data="posts/nlp/neural-machine-translation-training-the-model/evaluation_accuracy.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<p>It seems to be stuck…</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org3b5f4c3">
<h2 id="org3b5f4c3">End</h2>
<div class="outline-text-2" id="text-org3b5f4c3">
<p>Now that we've trained the model in the <a href="posts/nlp/neural-machine-translation-testing-the-model/index.html">next post</a> we'll test our model to see how well it does. The overview post with links to all the posts in this series is <a href="posts/nlp/neural-machine-translation/index.html">here</a>.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org561dc74">
<h2 id="org561dc74">Raw</h2>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nlp/neural-machine-translation-the-attention-model/index.html">Neural Machine Translation: The Attention Model</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html" rel="bookmark"><time class="published dt-published" datetime="2021-02-14T14:54:08-08:00" itemprop="datePublished" title="2021-02-14 14:54">2021-02-14 14:54</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html#org669dc3a">Defining the Model</a>
<ul>
<li><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html#org78aa421">Attention Overview</a></li>
<li><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html#org05f0832">Imports</a></li>
</ul>
</li>
<li><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html#org6278bde">Implementation</a>
<ul>
<li><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html#org540ce07">Overview</a></li>
<li><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html#org4923625">The Implementation</a></li>
</ul>
</li>
<li><a href="posts/nlp/neural-machine-translation-the-attention-model/index.html#orgbf0c13a">End</a></li>
</ul>
</div>
</div>
<div class="highlight">
<pre><span></span><span class="o">&lt;&lt;</span><span class="n">imports</span><span class="o">&gt;&gt;</span>

<span class="o">&lt;&lt;</span><span class="n">attention</span><span class="o">-</span><span class="n">model</span><span class="o">&gt;&gt;</span>
</pre></div>
<div class="outline-2" id="outline-container-org669dc3a">
<h2 id="org669dc3a">Defining the Model</h2>
<div class="outline-text-2" id="text-org669dc3a">
<p>In the <a href="posts/nlp/neural-machine-translation-helper-functions/index.html">previous post</a> we made some helper functions to prepare inputs for some of the layers in the model. In this post we'll define the model itself.</p>
</div>
<div class="outline-3" id="outline-container-org78aa421">
<h3 id="org78aa421">Attention Overview</h3>
<div class="outline-text-3" id="text-org78aa421">
<p>The model we will be building uses an encoder-decoder architecture. This Recurrent Neural Network (RNN) will take in a tokenized version of a sentence in its encoder, then passes it on to the decoder for translation. Just using a a regular sequence-to-sequence model with LSTMs will work effectively for short to medium sentences but will start to degrade for longer ones. You can picture it like the figure below where all of the context of the input sentence is compressed into one vector that is passed into the decoder block. You can see how this will be an issue for very long sentences (e.g. 100 tokens or more) because the context of the first parts of the input will have very little effect on the final vector passed to the decoder.</p>
<p>Adding an attention layer to this model avoids this problem by giving the decoder access to all parts of the input sentence. To illustrate, let's just use a 4-word input sentence as shown below. Remember that a hidden state is produced at each timestep of the encoder (represented by the orange rectangles). These are all passed to the attention layer and each are given a score given the current activation (i.e. hidden state) of the decoder. For instance, let's consider the figure below where the first prediction "Wie" is already made. To produce the next prediction, the attention layer will first receive all the encoder hidden states (i.e. orange rectangles) as well as the decoder hidden state when producing the word "Wie" (i.e. first green rectangle). Given this information, it will score each of the encoder hidden states to know which one the decoder should focus on to produce the next word. The result of the model training might have learned that it should align to the second encoder hidden state and subsequently assigns a high probability to the word "geht". If we are using greedy decoding, we will output the said word as the next symbol, then restart the process to produce the next word until we reach an end-of-sentence prediction.</p>
<p>There are different ways to implement attention and the one we'll use is the Scaled Dot Product Attention which has the form:</p>
<p>\[ Attention(Q, K, V) = softmax \left(\frac{QK^T}{\sqrt{d_k}} \right)V \]</p>
<p>You can think of it as computing scores using queries (Q) and keys (K), followed by a multiplication of values (V) to get a context vector at a particular timestep of the decoder. This context vector is fed to the decoder RNN to get a set of probabilities for the next predicted word. The division by square root of the keys dimensionality (\(\sqrt{d_k}\)) is for improving model performance and you'll also learn more about it next week. For our machine translation application, the encoder activations (i.e. encoder hidden states) will be the keys and values, while the decoder activations (i.e. decoder hidden states) will be the queries.</p>
<p>You will see in the upcoming sections that this complex architecture and mechanism can be implemented with just a few lines of code.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org05f0832">
<h3 id="org05f0832">Imports</h3>
<div class="outline-text-3" id="text-org05f0832">
<div class="highlight">
<pre><span></span><span class="c1"># pypi</span>
<span class="kn">from</span> <span class="nn">trax</span> <span class="kn">import</span> <span class="n">layers</span>

<span class="kn">import</span> <span class="nn">trax</span>

<span class="c1"># this project</span>
<span class="kn">from</span> <span class="nn">neurotic.nlp.machine_translation</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NMTAttn</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org6278bde">
<h2 id="org6278bde">Implementation</h2>
<div class="outline-text-2" id="text-org6278bde"></div>
<div class="outline-3" id="outline-container-org540ce07">
<h3 id="org540ce07">Overview</h3>
<div class="outline-text-3" id="text-org540ce07">
<p>We are now ready to implement our sequence-to-sequence model with attention. This will be a Serial network and is illustrated in the diagram below. It shows the layers you'll be using in Trax and you'll see that each step can be implemented quite easily with one line commands. We've placed several links to the documentation for each relevant layer in the discussion after the figure below.</p>
<ul class="org-ul">
<li><b>Step 0:</b> Prepare the input encoder and pre-attention decoder branches. We've already defined this earlier as helper functions so it's just a matter of calling those functions and assigning it to variables.</li>
<li><b>Step 1:</b> Create a Serial network. This will stack the layers in the next steps one after the other. As before, we'll use <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Serial">tl.Serial</a>.</li>
<li><b>Step 2:</b> Make a copy of the input and target tokens. As you see in the diagram above, the input and target tokens will be fed into different layers of the model. We'll use <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Select">tl.Select</a> layer to create copies of these tokens, arranging them as <code>[input tokens, target tokens, input tokens, target tokens]</code>.</li>
<li><b>Step 3:</b> Create a parallel branch to feed the input tokens to the <code>input_encoder</code> and the target tokens to the <code>pre_attention_decoder</code>. We'll use <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Parallel">tl.Parallel</a> to create these sublayers in parallel, remembering to pass the variables defined in Step 0 as parameters to this layer.</li>
<li><b>Step 4:</b> Next, call the `prepare_attention_input` function to convert the encoder and pre-attention decoder activations to a format that the attention layer will accept. You can use <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.base.Fn">tl.Fn</a> to call this function. Note: Pass the <code>prepare_attention_input</code> function as the <code>f</code> parameter in <code>tl.Fn</code> without any arguments or parenthesis.</li>
<li><b>Step 5:</b> We will now feed the (queries, keys, values, and mask) to the <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.attention.AttentionQKV">tl.AttentionQKV</a> layer. This computes the scaled dot product attention and outputs the attention weights and mask. Take note that although it is a one liner, this layer is actually composed of a deep network made up of several branches. We'll show the implementation show <a href="https://github.com/google/trax/blob/master/trax/layers/attention.py#L61">here</a> (on github) to see the different layers used.</li>
</ul>
<pre class="example" id="org81b9476">
def AttentionQKV(d_feature, n_heads=1, dropout=0.0, mode='train'):
  """Returns a layer that maps (q, k, v, mask) to (activations, mask).

  See `Attention` above for further context/details.

  Args:
    d_feature: Depth/dimensionality of feature embedding.
    n_heads: Number of attention heads.
    dropout: Probababilistic rate for internal dropout applied to attention
        activations (based on query-key pairs) before dotting them with values.
    mode: Either 'train' or 'eval'.
  """
  return cb.Serial(
      cb.Parallel(
          core.Dense(d_feature),
          core.Dense(d_feature),
          core.Dense(d_feature),
      ),
      PureAttention(  # pylint: disable=no-value-for-parameter
          n_heads=n_heads, dropout=dropout, mode=mode),
      core.Dense(d_feature),
  )
</pre>
<p>Having deep layers poses the risk of vanishing gradients during training and we would want to mitigate that. To improve the ability of the network to learn, we can insert a <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Residual">tl.Residual</a> layer to add the output of AttentionQKV with the <code>queries</code> input. You can do this in trax by simply nesting the <code>AttentionQKV</code> layer inside the <code>Residual</code> layer. The library will take care of branching and adding for you.</p>
<ul class="org-ul">
<li><b>Step 6:</b> We will not need the mask for the model we're building so we can safely drop it. At this point in the network, the signal stack currently has <code>[attention activations, mask, target tokens]</code> and you can use <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.combinators.Select">tl.Select</a> to output just <code>[attention activations, target tokens]</code>.</li>
<li><b>Step 7:</b> We can now feed the attention weighted output to the LSTM decoder. We can stack multiple <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.rnn.LSTM">tl.LSTM</a> layers to improve the output so remember to append LSTMs equal to the number defined by <code>n_decoder_layers</code> parameter to the model.</li>
<li><b>Step 8:</b> We want to determine the probabilities of each subword in the vocabulary and you can set this up easily with a <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.Dense">tl.Dense</a> layer by making its size equal to the size of our vocabulary.</li>
<li><b>Step 9:</b> Normalize the output to log probabilities by passing the activations in Step 8 to a <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html#trax.layers.core.LogSoftmax">tl.LogSoftmax</a> layer.</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org4923625">
<h3 id="org4923625">The Implementation</h3>
<div class="outline-text-3" id="text-org4923625">
<div class="highlight">
<pre><span></span><span class="c1"># pypi</span>
<span class="kn">from</span> <span class="nn">trax</span> <span class="kn">import</span> <span class="n">layers</span>

<span class="c1"># this project</span>
<span class="kn">from</span> <span class="nn">.help_me</span> <span class="kn">import</span> <span class="n">input_encoder</span> <span class="k">as</span> <span class="n">input_encoder_fn</span>
<span class="kn">from</span> <span class="nn">.help_me</span> <span class="kn">import</span> <span class="n">pre_attention_decoder</span> <span class="k">as</span> <span class="n">pre_attention_decoder_fn</span>
<span class="kn">from</span> <span class="nn">.help_me</span> <span class="kn">import</span> <span class="n">prepare_attention_input</span> <span class="k">as</span> <span class="n">prepare_attention_input_fn</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">NMTAttn</span><span class="p">(</span><span class="n">input_vocab_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">33300</span><span class="p">,</span>
            <span class="n">target_vocab_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">33300</span><span class="p">,</span>
            <span class="n">d_model</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span>
            <span class="n">n_encoder_layers</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">n_decoder_layers</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">n_attention_heads</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">attention_dropout</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">'train'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Returns an LSTM sequence-to-sequence model with attention.</span>

<span class="sd">    The input to the model is a pair (input tokens, target tokens), e.g.,</span>
<span class="sd">    an English sentence (tokenized) and its translation into German (tokenized).</span>

<span class="sd">    Args:</span>
<span class="sd">    input_vocab_size: int: vocab size of the input</span>
<span class="sd">    target_vocab_size: int: vocab size of the target</span>
<span class="sd">    d_model: int:  depth of embedding (n_units in the LSTM cell)</span>
<span class="sd">    n_encoder_layers: int: number of LSTM layers in the encoder</span>
<span class="sd">    n_decoder_layers: int: number of LSTM layers in the decoder after attention</span>
<span class="sd">    n_attention_heads: int: number of attention heads</span>
<span class="sd">    attention_dropout: float, dropout for the attention layer</span>
<span class="sd">    mode: str: 'train', 'eval' or 'predict', predict mode is for fast inference</span>

<span class="sd">    Returns:</span>
<span class="sd">    A LSTM sequence-to-sequence model with attention.</span>
<span class="sd">    """</span>
    <span class="c1"># Step 0: call the helper function to create layers for the input encoder</span>
    <span class="n">input_encoder</span> <span class="o">=</span> <span class="n">input_encoder_fn</span><span class="p">(</span><span class="n">input_vocab_size</span><span class="p">,</span> <span class="n">d_model</span><span class="p">,</span> <span class="n">n_encoder_layers</span><span class="p">)</span>

    <span class="c1"># Step 0: call the helper function to create layers for the pre-attention decoder</span>
    <span class="n">pre_attention_decoder</span> <span class="o">=</span> <span class="n">pre_attention_decoder_fn</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">target_vocab_size</span><span class="p">,</span> <span class="n">d_model</span><span class="p">)</span>

    <span class="c1"># Step 1: create a serial network</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span> 

      <span class="c1"># Step 2: copy input tokens and target tokens as they will be needed later.</span>
      <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>

      <span class="c1"># Step 3: run input encoder on the input and pre-attention decoder on the target.</span>
      <span class="n">layers</span><span class="o">.</span><span class="n">Parallel</span><span class="p">(</span><span class="n">input_encoder</span><span class="p">,</span> <span class="n">pre_attention_decoder</span><span class="p">),</span>

      <span class="c1"># Step 4: prepare queries, keys, values and mask for attention.</span>
      <span class="n">layers</span><span class="o">.</span><span class="n">Fn</span><span class="p">(</span><span class="s1">'PrepareAttentionInput'</span><span class="p">,</span> <span class="n">prepare_attention_input_fn</span><span class="p">,</span> <span class="n">n_out</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span>

      <span class="c1"># Step 5: run the AttentionQKV layer</span>
      <span class="c1"># nest it inside a Residual layer to add to the pre-attention decoder activations(i.e. queries)</span>
      <span class="n">layers</span><span class="o">.</span><span class="n">Residual</span><span class="p">(</span><span class="n">layers</span><span class="o">.</span><span class="n">AttentionQKV</span><span class="p">(</span><span class="n">d_model</span><span class="p">,</span>
                                          <span class="n">n_heads</span><span class="o">=</span><span class="n">n_attention_heads</span><span class="p">,</span>
                                          <span class="n">dropout</span><span class="o">=</span><span class="n">attention_dropout</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)),</span>

      <span class="c1"># Step 6: drop attention mask (i.e. index = None</span>
      <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>

      <span class="c1"># Step 7: run the rest of the RNN decoder</span>
      <span class="p">[</span><span class="n">layers</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="n">d_model</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_decoder_layers</span><span class="p">)],</span>

      <span class="c1"># Step 8: prepare output by making it the right size</span>
      <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">target_vocab_size</span><span class="p">),</span>

      <span class="c1"># Step 9: Log-softmax for output</span>
      <span class="n">layers</span><span class="o">.</span><span class="n">LogSoftmax</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">test_NMTAttn</span><span class="p">(</span><span class="n">NMTAttn</span><span class="p">):</span>
    <span class="n">test_cases</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">"name"</span><span class="p">:</span><span class="s2">"simple_test_check"</span><span class="p">,</span>
                    <span class="s2">"expected"</span><span class="p">:</span><span class="s2">"Serial_in2_out2[</span><span class="se">\n</span><span class="s2">  Select[0,1,0,1]_in2_out4</span><span class="se">\n</span><span class="s2">  Parallel_in2_out2[</span><span class="se">\n</span><span class="s2">    Serial[</span><span class="se">\n</span><span class="s2">      Embedding_33300_1024</span><span class="se">\n</span><span class="s2">      LSTM_1024</span><span class="se">\n</span><span class="s2">      LSTM_1024</span><span class="se">\n</span><span class="s2">    ]</span><span class="se">\n</span><span class="s2">    Serial[</span><span class="se">\n</span><span class="s2">      ShiftRight(1)</span><span class="se">\n</span><span class="s2">      Embedding_33300_1024</span><span class="se">\n</span><span class="s2">      LSTM_1024</span><span class="se">\n</span><span class="s2">    ]</span><span class="se">\n</span><span class="s2">  ]</span><span class="se">\n</span><span class="s2">  PrepareAttentionInput_in3_out4</span><span class="se">\n</span><span class="s2">  Serial_in4_out2[</span><span class="se">\n</span><span class="s2">    Branch_in4_out3[</span><span class="se">\n</span><span class="s2">      None</span><span class="se">\n</span><span class="s2">      Serial_in4_out2[</span><span class="se">\n</span><span class="s2">        Parallel_in3_out3[</span><span class="se">\n</span><span class="s2">          Dense_1024</span><span class="se">\n</span><span class="s2">          Dense_1024</span><span class="se">\n</span><span class="s2">          Dense_1024</span><span class="se">\n</span><span class="s2">        ]</span><span class="se">\n</span><span class="s2">        PureAttention_in4_out2</span><span class="se">\n</span><span class="s2">        Dense_1024</span><span class="se">\n</span><span class="s2">      ]</span><span class="se">\n</span><span class="s2">    ]</span><span class="se">\n</span><span class="s2">    Add_in2</span><span class="se">\n</span><span class="s2">  ]</span><span class="se">\n</span><span class="s2">  Select[0,2]_in3_out2</span><span class="se">\n</span><span class="s2">  LSTM_1024</span><span class="se">\n</span><span class="s2">  LSTM_1024</span><span class="se">\n</span><span class="s2">  Dense_33300</span><span class="se">\n</span><span class="s2">  LogSoftmax</span><span class="se">\n</span><span class="s2">]"</span><span class="p">,</span>
                    <span class="s2">"error"</span><span class="p">:</span><span class="s2">"The NMTAttn is not defined properly."</span>
                <span class="p">},</span>
                <span class="p">{</span>
                    <span class="s2">"name"</span><span class="p">:</span><span class="s2">"layer_len_check"</span><span class="p">,</span>
                    <span class="s2">"expected"</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span>
                    <span class="s2">"error"</span><span class="p">:</span><span class="s2">"We found </span><span class="si">{}</span><span class="s2"> layers in your model. It should be 9.</span><span class="se">\n</span><span class="s2">Check the LSTM stack before the dense layer"</span>
                <span class="p">},</span>
                <span class="p">{</span>
                    <span class="s2">"name"</span><span class="p">:</span><span class="s2">"selection_layer_check"</span><span class="p">,</span>
                    <span class="s2">"expected"</span><span class="p">:[</span><span class="s2">"Select[0,1,0,1]_in2_out4"</span><span class="p">,</span> <span class="s2">"Select[0,2]_in3_out2"</span><span class="p">],</span>
                    <span class="s2">"error"</span><span class="p">:</span><span class="s2">"Look at your selection layers."</span>
                <span class="p">}</span>
            <span class="p">]</span>

    <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">fails</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">test_case</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">test_case</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"simple_test_check"</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">test_case</span><span class="p">[</span><span class="s2">"expected"</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">NMTAttn</span><span class="p">())</span>
                <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">test_case</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"layer_len_check"</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">test_case</span><span class="p">[</span><span class="s2">"expected"</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">NMTAttn</span><span class="p">()</span><span class="o">.</span><span class="n">sublayers</span><span class="p">):</span>
                    <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">test_case</span><span class="p">[</span><span class="s2">"error"</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">NMTAttn</span><span class="p">()</span><span class="o">.</span><span class="n">sublayers</span><span class="p">)))</span> 
                    <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">test_case</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"selection_layer_check"</span><span class="p">:</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">NMTAttn</span><span class="p">()</span>
                <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">sublayers</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">sublayers</span><span class="p">[</span><span class="mi">4</span><span class="p">])]</span>
                <span class="n">check_count</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">test_case</span><span class="p">[</span><span class="s2">"expected"</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">test_case</span><span class="p">[</span><span class="s2">"error"</span><span class="p">])</span>
                        <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">check_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">check_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">success</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">test_case</span><span class="p">[</span><span class="s1">'error'</span><span class="p">])</span>
            <span class="n">fails</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">fails</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\033</span><span class="s2">[92m All tests passed"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[92m'</span><span class="p">,</span> <span class="n">success</span><span class="p">,</span><span class="s2">" Tests passed"</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\033</span><span class="s1">[91m'</span><span class="p">,</span> <span class="n">fails</span><span class="p">,</span> <span class="s2">" Tests failed"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">test_cases</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_cases</span> <span class="o">=</span> <span class="n">test_NMTAttn</span><span class="p">(</span><span class="n">NMTAttn</span><span class="p">)</span>
</pre></div>
<pre class="example">
The NMTAttn is not defined properly.
[92m 2  Tests passed
[91m 1  Tests failed
</pre>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">NMTAttn</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org7494d1a">
Serial_in2_out2[
  Select[0,1,0,1]_in2_out4
  Parallel_in2_out2[
    Serial[
      Embedding_33300_1024
      LSTM_1024
      LSTM_1024
    ]
    Serial[
      Serial[
        ShiftRight(1)
      ]
      Embedding_33300_1024
      LSTM_1024
    ]
  ]
  PrepareAttentionInput_in3_out4
  Serial_in4_out2[
    Branch_in4_out3[
      None
      Serial_in4_out2[
        _in4_out4
        Serial_in4_out2[
          Parallel_in3_out3[
            Dense_1024
            Dense_1024
            Dense_1024
          ]
          PureAttention_in4_out2
          Dense_1024
        ]
        _in2_out2
      ]
    ]
    Add_in2
  ]
  Select[0,2]_in3_out2
  LSTM_1024
  LSTM_1024
  Dense_33300
  LogSoftmax
]
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgbf0c13a">
<h2 id="orgbf0c13a">End</h2>
<div class="outline-text-2" id="text-orgbf0c13a">
<p>Now that we have the model defined, in the <a href="posts/nlp/neural-machine-translation-training-the-model/index.html">next post</a> we'll train the model. The overview post with links to all the posts in this series is <a href="posts/nlp/neural-machine-translation/index.html">here</a>.</p>
</div>
</div>
</div>
</article>
</div>
<ul class="pager postindexpager clearfix">
<li class="previous"><a href="index-22.html" rel="prev">Newer posts</a></li>
<li class="next"><a href="index-20.html" rel="next">Older posts</a></li>
</ul>
<script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">

        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']],},

        });
</script>
<link href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"></script>
<script>

    MathJax = {
        tex: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [['$$','$$'], ['\\[','\\]']],
            processEscapes: true,
            processEnvironments: true,
        }
    }
</script>
<link href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"></script><!--End of body content-->
<footer id="footer">Scribbles by <a href="mailto:cloisteredmonkey.jmark@slmail.me">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a>
<div id="license" xmlns:cc="http://creativecommons.org/ns#">This work is licensed under <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" rel="license noopener noreferrer" style="display:inline-block;" target="_blank">CC BY 4.0 <img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a></div>
</footer>
</div>
</div>
<script src="assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
</script>
</body>
</html>
