<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="Walking through pytorch's Chatbot Tutorial." name="description">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Chatbot Tutorial | Neurotic Networking</title>
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="../../../../rss.xml" hreflang="en" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/Neurotic-Networking/posts/pytorch/text/chatbot-tutorial/" rel="canonical"><!--[if lt IE 9]><script src="../../../../assets/js/html5.js"></script><![endif]-->
<link href="../../../../apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="../../../../favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="../../../../favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="../../../../site.webmanifest" rel="manifest">
<meta content="Cloistered Monkey" name="author">
<link href="../../../nano/tv-script-generation/tv-script-generation/" rel="prev" title="TV Script Generation" type="text/html">
<link href="../../pytorch-60-minute-blitz/" rel="next" title="Pytorch 60 Minute Blitz" type="text/html">
<meta content="Neurotic Networking" property="og:site_name">
<meta content="Chatbot Tutorial" property="og:title">
<meta content="https://necromuralist.github.io/Neurotic-Networking/posts/pytorch/text/chatbot-tutorial/" property="og:url">
<meta content="Walking through pytorch's Chatbot Tutorial." property="og:description">
<meta content="article" property="og:type">
<meta content="2019-02-10T15:02:29-08:00" property="article:published_time">
<meta content="rnn" property="article:tag">
<meta content="text" property="article:tag">
<meta content="tutorial" property="article:tag">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="../../../../"><span id="blog-title">Neurotic Networking</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../../../archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="../../../../categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="../../../../rss.xml">RSS feed</a></li>
<li class="nav-item"><a class="nav-link" href="https://necromuralist.github.io/">Cloistered Monkey</a></li>
</ul>
<!-- Google custom search -->
<form action="https://www.google.com/search" class="navbar-form navbar-right" method="get" role="search">
<div class="form-group"><input class="form-control" name="q" placeholder="Search" type="text"></div>
<!-- 
<button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
</button>
-->
<input name="sitesearch" type="hidden" value="https://necromuralist.github.io/Neurotic-Networking/"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right">
<li class="nav-item"><a class="nav-link" href="index.org" id="sourcelink">Source</a></li>
</ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title" itemprop="headline name"><a class="u-url" href=".">Chatbot Tutorial</a></h1>
<div class="metadata">
<p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2019-02-10T15:02:29-08:00" itemprop="datePublished" title="2019-02-10 15:02">2019-02-10 15:02</time></a></p>
<p class="sourceline"><a class="sourcelink" href="index.org">Source</a></p>
</div>
</header>
<div class="e-content entry-content" itemprop="articleBody text">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb9f2f74">Introduction</a></li>
<li><a href="#org5c23c9b">Set Up</a>
<ul>
<li><a href="#orgdef50c2">Imports</a></li>
<li><a href="#orgdae57d8">Setup the Timer</a></li>
<li><a href="#org284e7c2">Load Dotenv</a></li>
<li><a href="#org6ffc640">Check CUDA</a></li>
<li><a href="#org07b1012">Some Type Hints</a></li>
<li><a href="#orgb344d83">Some Constants</a></li>
</ul>
</li>
<li><a href="#orgb349a34">The Data</a>
<ul>
<li><a href="#org1c257ef">Download</a></li>
<li><a href="#org31b0c39">Movie Lines</a></li>
<li><a href="#orga41afb3">Conversations</a></li>
<li><a href="#orgc997abd">Store the Processed Lines</a></li>
<li><a href="#orgdeb98c8">Check Our Stored File</a></li>
</ul>
</li>
<li><a href="#orge65bb5c">A Vocabulary</a></li>
<li><a href="#org231e46f">Preparing the Data For Model-Training</a></li>
<li><a href="#org2a7a025">Related Repositories To Check Out</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgb9f2f74">
<h2 id="orgb9f2f74">Introduction</h2>
<div class="outline-text-2" id="text-orgb9f2f74">
<p>This is a walk-through the <a href="https://pytorch.org/tutorials/beginner/chatbot_tutorial.html">pytorch Chatbot Tutorial</a> which builds a chatbot using a recurrent Sequence-to-Sequence model trained on the <a href="https://www.cs.cornell.edu/~cristian/Cornell_Movie-Dialogs_Corpus.html">Cornell Movie-Dialogs Corpus</a>.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org5c23c9b">
<h2 id="org5c23c9b">Set Up</h2>
<div class="outline-text-2" id="text-org5c23c9b"></div>
<div class="outline-3" id="outline-container-orgdef50c2">
<h3 id="orgdef50c2">Imports</h3>
<div class="outline-text-3" id="text-orgdef50c2"></div>
<div class="outline-4" id="outline-container-orgfbc3afc">
<h4 id="orgfbc3afc">Python</h4>
<div class="outline-text-4" id="text-orgfbc3afc">
<div class="highlight">
<pre><span></span>from collections import defaultdict, namedtuple
import codecs
from pathlib import Path
from typing import Dict, List, Union
from zipfile import ZipFile
import csv
import os
import subprocess
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgf86330d">
<h4 id="orgf86330d">PyPi</h4>
<div class="outline-text-4" id="text-orgf86330d">
<div class="highlight">
<pre><span></span>from dotenv import load_dotenv
import requests
import torch
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org57014bd">
<h4 id="org57014bd">This Project</h4>
<div class="outline-text-4" id="text-org57014bd">
<div class="highlight">
<pre><span></span>from neurotic.tangles.timer import Timer
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgdae57d8">
<h3 id="orgdae57d8">Setup the Timer</h3>
<div class="outline-text-3" id="text-orgdae57d8">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org284e7c2">
<h3 id="org284e7c2">Load Dotenv</h3>
<div class="outline-text-3" id="text-org284e7c2">
<div class="highlight">
<pre><span></span>load_dotenv("../../.env")
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org6ffc640">
<h3 id="org6ffc640">Check CUDA</h3>
<div class="outline-text-3" id="text-org6ffc640">
<div class="highlight">
<pre><span></span>device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("Using {}".format(device))
</pre></div>
<pre class="example">
Using cuda
</pre></div>
</div>
<div class="outline-3" id="outline-container-org07b1012">
<h3 id="org07b1012">Some Type Hints</h3>
<div class="outline-text-3" id="text-org07b1012">
<div class="highlight">
<pre><span></span>OptionalList = Union[list, None]
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgb344d83">
<h3 id="orgb344d83">Some Constants</h3>
<div class="outline-text-3" id="text-orgb344d83">
<div class="highlight">
<pre><span></span>ENCODING = "iso-8859-1"
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgb349a34">
<h2 id="orgb349a34">The Data</h2>
<div class="outline-text-2" id="text-orgb349a34"></div>
<div class="outline-3" id="outline-container-org1c257ef">
<h3 id="org1c257ef">Download</h3>
<div class="outline-text-3" id="text-org1c257ef">
<div class="highlight">
<pre><span></span>class MovieData:
    """Dowload and ready the movie data
    Args:
     download_path: Path to the folder to store the data
     url: download url for the zip file
     chunk_size: bytes to read from stream during download
     clean_up: remove the extra downloaded files
    """
    def __init__(self,
                 download_path: Path,
                 url: str=("http://www.cs.cornell.edu/~cristian/data/"
                           "cornell_movie_dialogs_corpus.zip"),
                 chunk_size=1024,
                 clean_up: bool=True) -&gt; None:
        self.download_path = download_path
        self.url = url
        self.chunk_size = chunk_size
        self.clean_up = clean_up
        self._zip_path = None
        self._data_path = None
        self._zip_file = None
        return

    @property
    def zip_path(self) -&gt; Path:
        """Path to the downloaded zip file"""
        if self._zip_path is None:
            self._zip_path = self.download_path.joinpath(Path(self.url).name)
        return self._zip_path

    @property
    def data_path(self) -&gt; Path:
        """Path to the unzipped file"""
        if self._data_path is None:
            self._data_path = self.download_path.joinpath(
                Path(self.zip_path).stem)
        return self._data_path

    @property
    def zip_file(self) -&gt; ZipFile:
        """the Zip file for the zipped data"""
        if self._zip_file is None:
            self._zip_file = ZipFile(self.zip_path)
        return self._zip_file

    def clean(self) -&gt; None:
        """remove the extra downloaded files"""
        os.remove(self.zip_path)
        return

    def __call__(self) -&gt; None:
        """downloads and prepares the file if needed"""
        if not self.data_path.is_dir():
            if not self.zip_path.is_file():
                response = requests.get(self.url, stream=True)
                with self.zip_path.open("wb") as writer:
                    for chunk in response.iter_content(chunk_size=self.chunk_size):
                        if chunk:
                            writer.write(chunk)
            unpacked = []
            for name in self.zip_file.namelist():
                name = Path(name)
                # there's extra folders and hidden files in there that I'll avoid
                if name.suffix in (".pdf", ".txt") and not name.name.startswith("."):
                    self.zip_file.extract(str(name), path=self.data_path)
                    unpacked.append(name)
            assert self.data_path.is_dir()
            if self.clean_up:
                # there is a sub-folder in the unzipped folder so move the
                # the files up one
                for to_move in unpacked:
                    self.data_path.joinpath(to_move).rename(
                        self.data_path.joinpath(to_move.name))

                # now delete the temporary file
                os.remove(self.zip_path)
                if unpacked:
                    # now remove the sub-folder
                    self.data_path.joinpath(unpacked[0].parent).rmdir()
        return
</pre></div>
<p>Now let's download and unpack the data.</p>
<div class="highlight">
<pre><span></span>datasets = Path(os.environ.get("DATASETS")).expanduser()
assert datasets.is_dir()
movie_data = MovieData(datasets, clean_up=True)
movie_data()
for name in movie_data.data_path.iterdir():
    print(" - {}".format(name.name))
</pre></div>
<ul class="org-ul">
<li>chameleons.pdf</li>
<li>conversation_line_pairs.tsv</li>
<li>movie_conversations.txt</li>
<li>movie_characters_metadata.txt</li>
<li>movie_lines.txt</li>
<li>movie_titles_metadata.txt</li>
<li>raw_script_urls.txt</li>
<li>README.txt</li>
</ul>
<div class="highlight">
<pre><span></span>class MovieFile:
    urls = "raw_script_urls.txt"
    readme = "README.txt"
    lines = "movie_lines.txt"
    characters = "movie_characters_metadata.txt"
    conversations = "movie_conversations.txt"
    titles = "movie_titles_metadata.txt"
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org31b0c39">
<h3 id="org31b0c39">Movie Lines</h3>
<div class="outline-text-3" id="text-org31b0c39">
<p>Here's an excerpt from the <code>README.txt</code> file:</p>
<blockquote>
<p>In all files the field separator is " <del><del><del>$</del></del></del> "</p>
<ul class="org-ul">
<li>movie_lines.txt
<ul class="org-ul">
<li>contains the actual text of each utterance</li>
<li>fields:
<ul class="org-ul">
<li>lineID</li>
<li>characterID (who uttered this phrase)</li>
<li>movieID</li>
<li>character name</li>
<li>text of the utterance</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</div>
<div class="outline-4" id="outline-container-org5117764">
<h4 id="org5117764">Movie Line Data</h4>
<div class="outline-text-4" id="text-org5117764">
<p>To load the lines I'm going to make a <a href="https://docs.python.org/3.6/library/collections.html#collections.namedtuple">namedtuple</a>.</p>
<div class="highlight">
<pre><span></span>MovieLine = namedtuple("MovieLine", ["line_id",
                                     "character_id",
                                     "movie_id",
                                     "character_name",
                                     "text"])

LineData = Dict[str, MovieLine]
LineFields = MovieLine(**{field: index
                          for index, field in enumerate(MovieLine._fields)})
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6f3bca9">
<h4 id="org6f3bca9">A Line Loader</h4>
<div class="outline-text-4" id="text-org6f3bca9">
<div class="highlight">
<pre><span></span>class MovieLines:
    """loads the movie dialog lines

    Args:
     path: path to the source file
     separator: column-separator
     encoding: the file encoding type (e.g. UTF-8)
    """
    def __init__(self, path: Path, separator: str=" +++$+++ ",
                 encoding="UTF-8") -&gt; None:
        self.path = path
        self.separator = separator
        self.encoding = encoding
        self._lines = None
        return

    @property
    def lines(self) -&gt; LineData:
        """Dictionary Of Lines in the Data"""
        if self._lines is None:
            self._lines = {}
            with self.path.open(encoding=self.encoding) as reader:
                for line in reader:
                    tokens = line.strip().split(self.separator)

                    text = tokens[LineFields.text] if len(tokens) == len(LineFields) else ""
                    movie_line = MovieLine(line_id=tokens[LineFields.line_id],
                                           character_id=tokens[LineFields.character_id],
                                           movie_id=tokens[LineFields.movie_id],
                                           character_name=tokens[LineFields.character_name],
                                           text=text,
                    )
                    self._lines[movie_line.line_id] = movie_line
        return self._lines

    def head(self, lines: int=5, get: bool=False) -&gt; OptionalList:
        """show the first lines

        Args:
         lines: number of lines to read
         get: if true, return the lines
        """
        output = [] if get else None
        with self.path.open() as reader:
            for index, line in enumerate(reader):
                line = line.rstrip()
                print(line)
                if get:
                    output.append(line)
                if index + 1 &gt;= lines:
                    break
        return output
</pre></div>
<div class="highlight">
<pre><span></span>movie_lines = MovieLines(movie_data.data_path.joinpath(MovieFile.lines), encoding=ENCODING)
output_lines = movie_lines.head(10)
</pre></div>
<pre class="example" id="orgc8a3037">
L1045 +++$+++ u0 +++$+++ m0 +++$+++ BIANCA +++$+++ They do not!
L1044 +++$+++ u2 +++$+++ m0 +++$+++ CAMERON +++$+++ They do to!
L985 +++$+++ u0 +++$+++ m0 +++$+++ BIANCA +++$+++ I hope so.
L984 +++$+++ u2 +++$+++ m0 +++$+++ CAMERON +++$+++ She okay?
L925 +++$+++ u0 +++$+++ m0 +++$+++ BIANCA +++$+++ Let's go.
L924 +++$+++ u2 +++$+++ m0 +++$+++ CAMERON +++$+++ Wow
L872 +++$+++ u0 +++$+++ m0 +++$+++ BIANCA +++$+++ Okay -- you're gonna need to learn how to lie.
L871 +++$+++ u2 +++$+++ m0 +++$+++ CAMERON +++$+++ No
L870 +++$+++ u0 +++$+++ m0 +++$+++ BIANCA +++$+++ I'm kidding.  You know how sometimes you just become this "persona"?  And you don't know how to quit?
L869 +++$+++ u0 +++$+++ m0 +++$+++ BIANCA +++$+++ Like my fear of wearing pastels?
</pre>
<p>As note in the <code>README.txt</code> those strange characters are how the columns are separated (I guess so that the commas could be kept in the text). The Line IDs seem to be in reverse oredr, and don't seem to have all the lines - unless they're out of order and just looking at the head is misleading. For reference the movie for the lines I showed (the dialog between Bianca and Cameron) is from <a href="https://www.imdb.com/title/tt0147800/">12 Things I Hate About You</a>. For some reason they both encode the chraracters and give their names - <code>u0</code> is <code>BIANCA</code>.</p>
<p>If you poke around in the file you'll find that there's something peculiar about the characters in it.</p>
<div class="highlight">
<pre><span></span>output = subprocess.run(["file", "-i", str(movie_lines.path)], stdout=subprocess.PIPE)
print(output.stdout)
</pre></div>
<pre class="example">
b'/home/athena/data/datasets/cornell_movie_dialogs_corpus/movie_lines.txt: text/plain; charset=unknown-8bit\n'
</pre>
<p>It doesn't look like standard ASCII, but I wonder if it matters. In the pytorch tutorial they give the encoding as <code>iso-8859-1</code>, although I can't find any documentation for this, but since they gave it, I guess we can use it.</p>
<div class="highlight">
<pre><span></span><span class="n">ENCODING</span> <span class="o">=</span> <span class="s2">"iso-8859-1"</span>
</pre></div>
<p>I'm using it in MovieLines too so I defined ENCODING at the top of the notebook, this is just to show where it came from.</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orga41afb3">
<h3 id="orga41afb3">Conversations</h3>
<div class="outline-text-3" id="text-orga41afb3">
<p>The movie-lines file has all the movie-conversations together, but we want conversations between characters. For that you need to group the lines using the <code>movie_conversations.txt</code> file.</p>
<blockquote>
<ul class="org-ul">
<li>movie_conversations.txt
<ul class="org-ul">
<li>the structure of the conversations</li>
<li>fields
<ul class="org-ul">
<li>characterID of the first character involved in the conversation</li>
<li>characterID of the second character involved in the conversation</li>
<li>movieID of the movie in which the conversation occurred</li>
<li>list of the utterances that make the conversation, in chronological order: ['lineID1','lineID2',Ã‰,'lineIDN'] has to be matched with movie_lines.txt to reconstruct the actual content</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>You can see that the README has some kind of funky character in it (the third item in the <code>order</code> list). Weird.</p>
</div>
<div class="outline-4" id="outline-container-orgc464839">
<h4 id="orgc464839">A Conversation Holder</h4>
<div class="outline-text-4" id="text-orgc464839">
<p>A <i>conversation</i> is a list of lines said by characters to each other. Although the dialog file is presumably in order, we want to be able to partition lines that are part of a single conversation - a verbal interaction between two characters.</p>
<div class="highlight">
<pre><span></span>ConversationIDs = namedtuple("ConversationIDs", ["character_id_1",
                                                 "character_id_2",
                                                 "movie_id",
                                                 "lines"])
ConversationFields = ConversationIDs(
    **{field: index
       for index, field in enumerate(ConversationIDs._fields)})
ConversationData = List[ConversationIDs]
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org8d2aa9b">
<h4 id="org8d2aa9b">A Conversations Builder</h4>
<div class="outline-text-4" id="text-org8d2aa9b">
<p>This is code to pull the lines out and group them by conversation.</p>
<div class="highlight">
<pre><span></span>class Conversations:
    """Holds the conversations

    Args:
     path: path to the conversations file
     moviez: object with the movie lines
     encoding: the encoding for the file
     separator: the column separator
    """
    def __init__(self,
                 path: Path,
                 movies: MovieLines,
                 separator: str=" +++$+++ ",
                 encoding:str="UTF-8") -&gt; None:
        self.path = path
        self.movies = movies
        self.separator = separator
        self.encoding = encoding
        self._conversations = None
        self._sentence_pairs = None
        return

    @property
    def conversations(self) -&gt; ConversationData:
        """The list of conversation line data
        """
        if self._conversations is None:
            self._conversations = []
            with self.path.open(encoding=self.encoding) as reader:
                for line in reader:
                    tokens = line.strip().split(self.separator)
                    line_ids = eval(tokens[ConversationFields.lines])
                    lines = [self.movies.lines[line_id] for line_id in line_ids]
                    self._conversations.append(
                        ConversationIDs(
                            character_id_1=tokens[ConversationFields.character_id_1],
                            character_id_2=tokens[ConversationFields.character_id_2],
                            movie_id=tokens[ConversationFields.movie_id],
                            lines = lines,
                        ))
        return self._conversations

    @property
    def sentence_pairs(self) -&gt; list:
        """paired-sentences from the conversations"""
        if self._sentence_pairs is None:
            self._sentence_pairs = []
            for conversation in self.conversations:
                for index in range(len(conversation.lines) - 1):
                    utterance = conversation.lines[index].text
                    response = conversation.lines[index + 1].text
                    # you might not always have pairs
                    if utterance and response:
                        self._sentence_pairs.append([utterance, response])
        return self._sentence_pairs

    def head(self, count: int=5) -&gt; None:
        """Print the first lines

        Args:
         count: how many lines to print
        """
        with self.path.open(encoding=self.encoding) as reader:
            so_far = 0
            for line in reader:
                print(line.rstrip())
                so_far += 1
                if so_far &gt;= count:
                    break
        return
</pre></div>
<p>Now I'll build the conversations from the file.</p>
<div class="highlight">
<pre><span></span>conversations_path = movie_data.data_path.joinpath(MovieFile.conversations)
conversations = Conversations(conversations_path, movie_lines, encoding=ENCODING)
conversations.head()
</pre></div>
<pre class="example">
u0 +++$+++ u2 +++$+++ m0 +++$+++ ['L194', 'L195', 'L196', 'L197']
u0 +++$+++ u2 +++$+++ m0 +++$+++ ['L198', 'L199']
u0 +++$+++ u2 +++$+++ m0 +++$+++ ['L200', 'L201', 'L202', 'L203']
u0 +++$+++ u2 +++$+++ m0 +++$+++ ['L204', 'L205', 'L206']
u0 +++$+++ u2 +++$+++ m0 +++$+++ ['L207', 'L208']
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgc997abd">
<h3 id="orgc997abd">Store the Processed Lines</h3>
<div class="outline-text-3" id="text-orgc997abd">
<p>Since we've transformed the data we should store it to avoid needing to transform it again later.</p>
<div class="highlight">
<pre><span></span>with TIMER:
    processed_path = movie_data.data_path.joinpath("conversation_line_pairs.tsv")
    delimiter = str(codecs.decode("\t", "unicode_escape"))
    NEWLINE = "\n"
    with processed_path.open("w", encoding="utf-8") as outputfile:
        writer = csv.writer(outputfile, delimiter=delimiter)
        for pair in conversations.sentence_pairs:
            writer.writerow(pair)
</pre></div>
<pre class="example">
Started: 2019-02-18 18:44:01.624014
Ended: 2019-02-18 18:44:04.127445
Elapsed: 0:00:02.503431
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgdeb98c8">
<h3 id="orgdeb98c8">Check Our Stored File</h3>
<div class="outline-text-3" id="text-orgdeb98c8">
<div class="highlight">
<pre><span></span>with processed_path.open() as reader:
    count = 0
    for line in reader:
        print(repr(line))
        count += 1
        if count == 5:
            break
</pre></div>
<pre class="example">
"Can we make this quick?  Roxanne Korrine and Andrew Barrett are having an incredibly horrendous public break- up on the quad.  Again.\tWell, I thought we'd start with pronunciation, if that's okay with you.\n"
"Well, I thought we'd start with pronunciation, if that's okay with you.\tNot the hacking and gagging and spitting part.  Please.\n"
"Not the hacking and gagging and spitting part.  Please.\tOkay... then how 'bout we try out some French cuisine.  Saturday?  Night?\n"
"You're asking me out.  That's so cute. What's your name again?\tForget it.\n"
"No, no, it's my fault -- we didn't have a proper introduction ---\tCameron.\n"
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orge65bb5c">
<h2 id="orge65bb5c">A Vocabulary</h2>
<div class="outline-text-2" id="text-orge65bb5c">
<div class="highlight">
<pre><span></span>PADDING, START_OF_SENTENCE, END_OF_SENTENCE = 0, 1, 2

class Vocabulary:
    """A class to hold words and sentences

    Args:
     name: name of the vocabulary
     token_delimiter: what to split sentences on
    """
    def __init__(self, name: str, token_delimiter: str=" ") -&gt; None:
        self.name = name
        self.trimmed = False
        self.token_delimiter = token_delimiter
        self.word_to_index = {}
        self._word_to_count = None
        self._index_to_word = None
        return

    @property
    def word_to_count(self) -&gt; defaultdict:
        """map of word to word count"""
        if self._word_to_count is None:
            self._word_to_count = defaultdict(lambda: 1)
        return self._word_to_count

    @property
    def index_to_word(self) -&gt; dict:
        """map of word-index back to the word"""
        if self._index_to_word is None:
            self._index_to_word = dict(
                PADDING="PAD",
                START_OF_SENTENCE="SOS",
                END_OF_SENTENCE="EOS",
            )
        return self._index_to_word

    @property
    def word_count(self) -&gt; int:
        """the number of words in our vocabulary"""
        return len(self.index_to_word)

    def add_sentence(self, sentence: str) -&gt; None:
        """Adds the words in the sentence to our dictionary

        Args:
         sentence: string of words
        """
        for word in sentence.split(self.token_delimiter):
            self.add_word(word)
        return

    def add_word(self, word: str) -&gt; None:
        """add the word to our vocabulary

        Args:
         word: word to add
        """
        if word not in self.word_to_index:
            self.word_to_index[word] = self.word_count
            self.index_to_word[self.word_count] = word
        else:
            self.word_to_count[word] += 1
        return

    def trim(self, minimum: int) -&gt; None:
        """Trim words below the minimum

        .. warning:: This will only work once, even if you change the
          minimum. set self.trimmed to False if you want to do it again

        Args:
         minimum: lowest acceptible count for a word
        """
        if self.trimmed:
            return
        self.trimmed = True
        keepers = []
        for word, count in self.word_to_count.items():
            if count &gt;= minimum:
                keepers.append(word)
        print("Keep: {}/{} = {:.2f}".format(len(keepers),
                                            len(self.word_count),
                                            len(keepers)/len(self.word_count)))
        self.reset()
        for word in keepers:
            self.add_word(word)
        return

    def reset(self) -&gt; None:
        """Resets the dictionaries"""
        self.word_to_index = {}
        self._word_to_count = None
        self._index_to_word = None
        return
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org231e46f">
<h2 id="org231e46f">Preparing the Data For Model-Training</h2>
</div>
<div class="outline-2" id="outline-container-org2a7a025">
<h2 id="org2a7a025">Related Repositories To Check Out</h2>
<div class="outline-text-2" id="text-org2a7a025">
<ul class="org-ul">
<li><a href="https://github.com/ywk991112/pytorch-chatbot">Formosa Speech Grand Challenge Chatbot</a></li>
<li><a href="https://github.com/spro/practical-pytorch/tree/master/seq2seq-translation">Practical Pytorch seq2seq translation</a></li>
<li><a href="https://github.com/floydhub/textutil-preprocess-cornell-movie-corpus">Cornell Movie Corpus Pre-processor</a></li>
</ul>
</div>
</div>
</div>
<aside class="postpromonav">
<nav>
<ul class="tags" itemprop="keywords">
<li><a class="tag p-category" href="../../../../categories/rnn/" rel="tag">rnn</a></li>
<li><a class="tag p-category" href="../../../../categories/text/" rel="tag">text</a></li>
<li><a class="tag p-category" href="../../../../categories/tutorial/" rel="tag">tutorial</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous"><a href="../../../nano/tv-script-generation/tv-script-generation/" rel="prev" title="TV Script Generation">Previous post</a></li>
<li class="next"><a href="../../pytorch-60-minute-blitz/" rel="next" title="Pytorch 60 Minute Blitz">Next post</a></li>
</ul>
</nav>
</aside>
</article>
<!--End of body content-->
<footer id="footer"><a href="http://creativecommons.org/licenses/by/4.0/" rel="license"><img alt="Creative Commons License" id="license-image" src="https://i.creativecommons.org/l/by/4.0/80x15.png" style="border-width:0"></a>This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. <a href="mailto:necromuralist@protonmail.com">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a></footer>
</div>
</div>
<script src="../../../../assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
</script>
</body>
</html>
