#+BEGIN_COMMENT
.. title: MNIST GAN
.. slug: mnist-gan
.. date: 2021-04-06 17:48:17 UTC-07:00
.. tags: gans
.. category: GANs
.. link: 
.. description: An MNIST GAN with pytorch.
.. type: text
.. has_math: True
#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-3722e9ad-c9cc-4374-95af-0c1518710310-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
%config InlineBackend.figure_format 'retina'
#+END_SRC

* Beginning
** Imports
#+begin_src python :results none
# python
from collections import namedtuple
from functools import partial
from pathlib import Path

# from pypi
from torch import nn
from torchvision import transforms
from torchvision.datasets import MNIST
from torchvision.utils import make_grid
from torch.utils.data import DataLoader

import hvplot.pandas
import matplotlib.pyplot as pyplot
import pandas
import torch

# local code
from graeae import EmbedHoloviews, Timer
#+end_src
** Some Setup
   First we'll set the manual seed to make this reproducible.
#+begin_src python :results none
torch.manual_seed(0)
#+end_src

This is a convenience object to time the training.
#+begin_src python :results none
TIMER = Timer()
#+end_src

This is for plotting.

#+begin_src python :results none
slug = "mnist-gan"

Embed = partial(EmbedHoloviews, folder_path=f"files/posts/gans/{slug}")

Plot = namedtuple("Plot", ["width", "height", "fontscale",
                           "tan", "blue", "red", "sizing_mode"],
                  defaults=[
                      900,
                      556,
                      2,
                      "#ddb377",
                      "#4687b7",
                      "#ce7b6d",
                      "scale_both",
                  ])()

GANParts = namedtuple("GANParts", ["generator", "generator_optimizer",
                                   "discriminator", "discriminator_optimizer"])

PlotData = namedtuple("PlotData", ["steps", "generator_losses",
                                   "discriminator_losses", "best_loss"])

MODEL_PATH = Path("~/models/gans/mnist.pth").expanduser()
INFINITY = float("inf")
#+end_src
* Middle
** The MNIST Dataset
The training images we will be using are from a dataset called [[http://yann.lecun.com/exdb/mnist/][MNIST]]. The dataset contains 60,000 images of handwritten digits, from 0 to 9.

The images are 28 pixels x 28 pixels in size. The small size of its images makes MNIST ideal for simple training. Additionally, these images are also in black-and-white so only one dimension, or "color channel", is needed to represent them. Pytorch has a [[https://pytorch.org/vision/0.8/datasets.html#mnist][version of it]] ready-made for their system so we'll use theirs.

** The Generator
The first step is to build the generator component.

We'll start by creating a function to make a single layer/block for the generator's neural network. Each block should include a [[https://pytorch.org/docs/stable/generated/torch.nn.Linear.html][linear transformation]] (\(y=xA^T + b\)) to the input to another shape, [[https://pytorch.org/docs/stable/generated/torch.nn.BatchNorm1d.html][batch normalization]] for stabilization, and finally a non-linear activation function ([[https://pytorch.org/docs/master/generated/torch.nn.ReLU.html][ReLU]] in this case).

#+begin_src python :results none
def generator_block(input_features: int, output_features: int) -> nn.Sequential:
    """
    Creates a block of the generator's neural network

    Args:
      input_features: the dimension of the input vector
      output_features: the dimension of the output vector

    Returns:
        a generator neural network layer, with a linear transformation 
          followed by a batch normalization and then a relu activation
    """
    return nn.Sequential(
        nn.Linear(input_features, output_features),
        nn.BatchNorm1d(output_features),
        nn.ReLU(inplace=True),
    )
#+end_src

*** Verify the generator block function
#+begin_src python :results none
def test_gen_block(in_features: int, out_features: int,
                   test_rows: int=1000) -> None:
    """Test the generator block creator

    Args:
     in_features: number of features for the block input
     out_features: the final number of features for it to output
     test_rows: how many rows to put in the test Tensor

    Raises:
     AssertionError: something isn't right
    """
    block = generator_block(in_features, out_features)

    # Check the three parts
    assert len(block) == 3
    assert type(block[0]) == nn.Linear
    assert type(block[1]) == nn.BatchNorm1d
    assert type(block[2]) == nn.ReLU
    
    # Check the output shape
    test_output = block(torch.randn(test_rows, in_features))
    assert tuple(test_output.shape) == (test_rows, out_features)

    # check the normalization
    assert 0.65 > test_output.std() > 0.55
    return

test_gen_block(25, 12)
test_gen_block(15, 28)
#+end_src
*** Building the Generator Class
    Now that we have the block-builder we can define our Generator network. It's going to contain a sequence of blocks output by our block-building function and a final two layers that use the linear transformation again, but don't apply normalization and use a [[https://pytorch.org/docs/master/generated/torch.nn.Sigmoid.html][Sigmoid Function]] instead of the ReLU. Each block will have an output double that of the previous one.

#+begin_src plantuml :results none :exports results :file ../../files/posts/gans/mnist-gan/generator.png
class nn.Module #white;line:lightslategray
Generator -|> nn.Module
class Generator #white;line:lightslategray {
 int: input_dimension
 int: image_dimension
 int: hidden_dimension
 nn.Sequential: generator

 torch.Tensor: forward(torch.Tensor: noise)
}
#+end_src

[[file:generator.png]]

#+begin_src python :results none
class Generator(nn.Module):
    """Generator Class

    Args:
      input_dimension: the dimension of the noise vector
      image_dimension: the dimension of the images, fitted for the dataset used
         (MNIST images are 28 x 28 = 784 so that is the default)
      hidden_dimension: the initial hidden-layer dimension
    """
    def __init__(self, input_dimension: int=10, image_dimension: int=784,
                 hidden_dimension: int=128):
        super().__init__()

        self.generator = nn.Sequential(
            generator_block(input_dimension, hidden_dimension),
            generator_block(hidden_dimension, hidden_dimension * 2),
            generator_block(hidden_dimension * 2, hidden_dimension * 4),
            generator_block(hidden_dimension * 4, hidden_dimension * 8),
            nn.Linear(hidden_dimension * 8, image_dimension),
            nn.Sigmoid()
        )
        return

    def forward(self, noise: torch.Tensor) -> torch.Tensor:
        """
        Method for a forward pass of the generator

        Args:
         noise: a noise tensor with dimensions (n_samples, z_dim)

        Returns: 
         generated images.
        """
        return self.generator(noise)
#+end_src

*** Verify the Generator Class

#+begin_src python :results none
def test_generator(z_dim: int, im_dim: int, hidden_dim: int, 
                   num_test: int=10000) -> None:
    """Test the Generator Class

    Args:
     z_dim: the size of the input
     im_dim: the size of the image
     hidden_dim: the size of the initial hidden layer

    Raises:
     AssertionError: something is wrong
    """
    gen = Generator(z_dim, im_dim, hidden_dim).generator
    
    # Check there are six modules in the sequential part
    assert len(gen) == 6
    test_input = torch.randn(num_test, z_dim)
    test_output = gen(test_input)

    # Check that the output shape is correct
    assert tuple(test_output.shape) == (num_test, im_dim)

    # Chechk the output
    assert 0 < test_output.max() < 1, "Make sure to use a sigmoid"
    assert test_output.min() < 0.5, "Don't use a block in your solution"
    assert 0.15 > test_output.std() > 0.05, "Don't use batchnorm here"
    return

test_generator(5, 10, 20)
test_generator(20, 8, 24)
#+end_src

** Noise
To be able to use the generator, we will need to be able to create noise vectors. The noise vector =z= has the important role of making sure the images generated from the same class don't all look the same -- think of it as a random seed. You will generate it randomly using PyTorch by sampling random numbers from the normal distribution. Since multiple images will be processed per pass, you will generate all the noise vectors at once.

 Note that whenever you create a new tensor using torch.ones, torch.zeros, or [[https://pytorch.org/docs/master/generated/torch.randn.html][torch.randn]], you either need to create it on the target device, e.g. =torch.ones(3, 3, device=device)=, or move it onto the target device using =torch.ones(3, 3).to(device)=. You do not need to do this if you're creating a tensor by manipulating another tensor or by using a variation that defaults the device to the input, such as =torch.ones_like=. In general, use =torch.ones_like= and =torch.zeros_like= instead of =torch.ones= or =torch.zeros= where possible.

#+begin_src python :results none
get_noise = partial(torch.randn, device="cuda")
#+end_src

*** Verify the noise vector function
#+begin_src python :results none
def test_get_noise(n_samples, z_dim, device='cpu'):
    noise = get_noise(n_samples, z_dim, device=device)
    
    # Make sure a normal distribution was used
    assert tuple(noise.shape) == (n_samples, z_dim)
    assert torch.abs(noise.std() - torch.tensor(1.0)) < 0.01
    assert str(noise.device).startswith(device)

test_get_noise(1000, 32)
#+end_src

** The Discriminator
The second component that you need to construct is the discriminator. As with the generator component, you will start by creating a function that builds a neural network block for the discriminator.

*Note: You use [[https://pytorch.org/docs/master/generated/torch.nn.LeakyReLU.html][leaky ReLUs]] to prevent the "dying ReLU" problem, which refers to the phenomenon where the parameters stop changing due to consistently negative values passed to a ReLU, which result in a zero gradient.* 

#+begin_src python :results none
def get_discriminator_block(input_dim: int, output_dim: int,
                            negative_slope: float=0.2) -> nn.Sequential:
    """Create the Discriminator block

    Args:
      input_dim: the dimension of the input vector, a scalar
      output_dim: the dimension of the output vector, a scalar
      negative_slope: angle for the negative slope

    Returns:
        a discriminator neural network layer, with a linear transformation 
          followed by an nn.LeakyReLU activation with negative slope of 0.2 
    """
    return nn.Sequential(
        nn.Linear(input_dim, output_dim),
        nn.LeakyReLU(negative_slope=0.2)
    )
#+end_src

*** Verify the discriminator block function

#+begin_src python :results none
def test_disc_block(in_features, out_features, num_test=10000):
    block = get_discriminator_block(in_features, out_features)

    # Check there are two parts
    assert len(block) == 2
    test_input = torch.randn(num_test, in_features)
    test_output = block(test_input)

    # Check that the shape is right
    assert tuple(test_output.shape) == (num_test, out_features)
    
    # Check that the LeakyReLU slope is about 0.2
    assert -test_output.min() / test_output.max() > 0.1
    assert -test_output.min() / test_output.max() < 0.3
    assert test_output.std() > 0.3
    assert test_output.std() < 0.5

test_disc_block(25, 12)
test_disc_block(15, 28)
#+end_src


*** The Discriminator Class
The discriminator class holds 2 values:

 - The image dimension
 - The hidden dimension

 The discriminator will build a neural network with 4 layers. It will start with the image tensor and transform it until it returns a single number (1-dimension tensor) output. This output classifies whether an image is fake or real. Note that you do not need a sigmoid after the output layer since it is included in the loss function. Finally, to use your discrimator's neural network you are given a forward pass function that takes in an image tensor to be classified.

#+begin_src python :results none
class Discriminator(nn.Module):
    """The Discriminator Class

    Args:
        im_dim: the dimension of the images, fitted for the dataset used, a scalar
            (MNIST images are 28x28 = 784 so that is your default)
        hidden_dim: the inner dimension, a scalar
    """
    def __init__(self, im_dim: int=784, hidden_dim: int=128):
        super().__init__()
        self.disc = nn.Sequential(
            get_discriminator_block(im_dim, hidden_dim * 4),
            get_discriminator_block(hidden_dim * 4, hidden_dim * 2),
            get_discriminator_block(hidden_dim * 2, hidden_dim),
            nn.Linear(hidden_dim, 1)
        )

    def forward(self, image: torch.Tensor) -> torch.Tensor:
        """forward pass of the discriminator

        Args:
            image: a flattened image tensor with dimension (im_dim)
        
        Returns a 1-dimension tensor representing fake/real.
        """
        return self.disc(image)
#+end_src

**** Verify the discriminator class
#+begin_src python :results none
def test_discriminator(z_dim, hidden_dim, num_test=100):
    
    disc = Discriminator(z_dim, hidden_dim).disc

    # Check there are three parts
    assert len(disc) == 4

    # Check the linear layer is correct
    test_input = torch.randn(num_test, z_dim)
    test_output = disc(test_input)
    assert tuple(test_output.shape) == (num_test, 1)
    
    # Don't use a block
    assert not isinstance(disc[-1], nn.Sequential)

test_discriminator(5, 10)
test_discriminator(20, 8)
#+end_src

** Training
First, you will set your parameters:
   -   criterion: the loss function ([[https://pytorch.org/docs/stable/generated/torch.nn.BCEWithLogitsLoss.html?highlight=bcewithlogitsloss][BCEWithLogitsLoss]])
   -   n_epochs: the number of times you iterate through the entire dataset when training
   -   z_dim: the dimension of the noise vector
   -   display_step: how often to display/visualize the images
   -   batch_size: the number of images per forward/backward pass
   -   lr: the learning rate
   -   device: the device type, here using a GPU (which runs CUDA), not CPU

 Next, you will load the MNIST dataset as tensors using a dataloader.


*** Set your parameters
#+begin_src python :results none
criterion = nn.BCEWithLogitsLoss()
z_dim = 64
batch_size = 128
lr = 0.00001
#+end_src

*** Load MNIST dataset as tensors

#+begin_src python :results none
data_path = Path("~/data/datasets/pytorch/").expanduser()
dataloader = DataLoader(
    MNIST(root=data_path, download=True, transform=transforms.ToTensor()),
    batch_size=batch_size,
    shuffle=True)
#+end_src

 Now, you can initialize your generator, discriminator, and optimizers. Note that each optimizer only takes the parameters of one particular model, since we want each optimizer to optimize only one of the models.

#+begin_src python :results none
def build_parts(z_dim: int=z_dim, learning_rate: float=lr) -> GANParts:
    device = "cuda"
    generator = Generator(z_dim).to(device)
    gen_optimizer = torch.optim.Adam(generator.parameters(), lr=learning_rate)
    discriminator = Discriminator().to(device) 
    disc_optimizer = torch.optim.Adam(discriminator.parameters(), lr=learning_rate)
    return GANParts(generator, gen_optimizer, discriminator, disc_optimizer)

gen, gen_opt, disc, disc_opt = build_parts()
#+end_src

This next bit is from https://stackoverflow.com/questions/48152674/how-to-check-if-pytorch-is-using-the-gpu.

#+begin_src python :results output :exports both
def check_gpu():
    assert torch.cuda.is_available()
    current_device = torch.cuda.current_device()
    print(current_device)
    print(torch.cuda.device_count())
    print(torch.cuda.get_device_name(current_device))
    print('Memory Usage:')
    print(f"Allocated: {torch.cuda.memory_allocated(current_device)/1024**2:,}"
          " MB")
    print(f"Cached:   {torch.cuda.memory_reserved(0)/1024**2:,} MB")
    return

check_gpu()
#+end_src

#+RESULTS:
: 0
: 1
: NVIDIA GeForce GTX 1070 Ti
: Memory Usage:
: Allocated: 7.92138671875 MB
: Cached:   22.0 MB

Before you train your GAN, you will need to create functions to calculate the discriminator's loss and the generator's loss. This is how the discriminator and generator will know how they are doing and improve themselves. Since the generator is needed when calculating the discriminator's loss, you will need to call .detach() on the generator result to ensure that only the discriminator is updated!

 Remember that you have already defined a loss function earlier (=criterion=) and you are encouraged to use [[https://pytorch.org/docs/master/generated/torch.ones_like.html?highlight=ones_like#torch.ones_like][=torch.ones_like=]] and [[https://pytorch.org/docs/master/generated/torch.zeros_like.html?highlight=zeros_like#torch.zeros_like][=torch.zeros_like=]] instead of =torch.ones= or =torch.zeros=. If you use =torch.ones= or =torch.zeros=, you'll need to pass =device=device= to them.

#+begin_src python :results none
def get_disc_loss(gen: Generator, disc: Discriminator,
                  criterion: nn.BCEWithLogitsLoss,
                  real: torch.Tensor,
                  num_images: int, z_dim: int, 
                  device: str="cuda"):
    """
    Get the loss of the discriminator given inputs.

    Args:
        gen: the generator model, which returns an image given z-dimensional noise
        disc: the discriminator model, which returns a single-dimensional prediction of real/fake
        criterion: the loss function, which should be used to compare 
               the discriminator's predictions to the ground truth reality of the images 
               (e.g. fake = 0, real = 1)
        real: a batch of real images
        num_images: the number of images the generator should produce, 
                which is also the length of the real images
        z_dim: the dimension of the noise vector, a scalar
        device: the device type

    Returns:
        disc_loss: a torch scalar loss value for the current batch
    """
    noise = torch.randn(num_images, z_dim, device=device)
    fakes = gen(noise).detach()

    fake_prediction = disc(fakes)
    fake_loss = criterion(fake_prediction, torch.zeros_like(fake_prediction))

    real_prediction = disc(real)
    real_loss = criterion(real_prediction, torch.ones_like(real_prediction))
    disc_loss = (fake_loss + real_loss)/2
    return disc_loss
#+end_src

#+begin_src python :results none
def test_disc_reasonable(num_images=10):
    # Don't use explicit casts to cuda - use the device argument
    import inspect, re
    lines = inspect.getsource(get_disc_loss)
    assert (re.search(r"to\(.cuda.\)", lines)) is None
    assert (re.search(r"\.cuda\(\)", lines)) is None
    
    z_dim = 64
    gen = torch.zeros_like
    disc = lambda x: x.mean(1)[:, None]
    criterion = torch.mul # Multiply
    real = torch.ones(num_images, z_dim)
    disc_loss = get_disc_loss(gen, disc, criterion, real, num_images, z_dim, 'cpu')
    assert torch.all(torch.abs(disc_loss.mean() - 0.5) < 1e-5)
    
    gen = torch.ones_like
    criterion = torch.mul # Multiply
    real = torch.zeros(num_images, z_dim)
    assert torch.all(torch.abs(get_disc_loss(gen, disc, criterion, real, num_images, z_dim, 'cpu')) < 1e-5)
    
    gen = lambda x: torch.ones(num_images, 10)
    disc = lambda x: x.mean(1)[:, None] + 10
    criterion = torch.mul # Multiply
    real = torch.zeros(num_images, 10)
    assert torch.all(torch.abs(get_disc_loss(gen, disc, criterion, real, num_images, z_dim, 'cpu').mean() - 5) < 1e-5)

    gen = torch.ones_like
    disc = nn.Linear(64, 1, bias=False)
    real = torch.ones(num_images, 64) * 0.5
    disc.weight.data = torch.ones_like(disc.weight.data) * 0.5
    disc_opt = torch.optim.Adam(disc.parameters(), lr=lr)
    criterion = lambda x, y: torch.sum(x) + torch.sum(y)
    disc_loss = get_disc_loss(gen, disc, criterion, real, num_images, z_dim, 'cpu').mean()
    disc_loss.backward()
    assert torch.isclose(torch.abs(disc.weight.grad.mean() - 11.25), torch.tensor(3.75))
    return

test_disc_reasonable()
#+end_src
    
#+begin_src python :results none
device = "cuda"
def test_disc_loss(max_tests = 10):
    z_dim = 64
    gen = Generator(z_dim).to(device)
    gen_opt = torch.optim.Adam(gen.parameters(), lr=lr)
    disc = Discriminator().to(device) 
    disc_opt = torch.optim.Adam(disc.parameters(), lr=lr)
    num_steps = 0
    for real, _ in dataloader:
        cur_batch_size = len(real)
        real = real.view(cur_batch_size, -1).to(device)

        ### Update discriminator ###
        # Zero out the gradient before backpropagation
        disc_opt.zero_grad()

        # Calculate discriminator loss
        disc_loss = get_disc_loss(gen, disc, criterion, real, cur_batch_size, z_dim, device)
        assert (disc_loss - 0.68).abs() < 0.05, disc_loss

        # Update gradients
        disc_loss.backward(retain_graph=True)

        # Check that they detached correctly
        assert gen.generator[0][0].weight.grad is None

        # Update optimizer
        old_weight = disc.disc[0][0].weight.data.clone()
        disc_opt.step()
        new_weight = disc.disc[0][0].weight.data
        
        # Check that some discriminator weights changed
        assert not torch.all(torch.eq(old_weight, new_weight))
        num_steps += 1
        if num_steps >= max_tests:
            break

test_disc_loss()
#+end_src
*** Generator Loss
#+begin_src python :results none
def get_generator_loss(gen: Generator,
                       disc: Discriminator,
                       criterion: nn.BCEWithLogitsLoss,
                       num_images: int,
                       z_dim: int, device: str="cuda") -> torch.Tensor:
    """Calculates the loss for the generator

    Args:
        gen: the generator model, which returns an image given z-dimensional noise
        disc: the discriminator model, which returns a single-dimensional prediction of real/fake
        criterion: the loss function, which should be used to compare 
               the discriminator's predictions to the ground truth reality of the images 
               (e.g. fake = 0, real = 1)
        num_images: the number of images the generator should produce, 
                which is also the length of the real images
        z_dim: the dimension of the noise vector, a scalar
        device: the device type
    Returns:
        gen_loss: a torch scalar loss value for the current batch
    """
    noise = torch.randn(num_images, z_dim, device=device)
    fakes = gen(noise)
    fake_prediction = disc(fakes)
    gen_loss = criterion(fake_prediction, torch.ones_like(fake_prediction))
    return gen_loss
#+end_src

#+begin_src python :results none
def test_gen_reasonable(num_images=10):
    # Don't use explicit casts to cuda - use the device argument
    import inspect, re
    lines = inspect.getsource(get_gen_loss)
    assert (re.search(r"to\(.cuda.\)", lines)) is None
    assert (re.search(r"\.cuda\(\)", lines)) is None
    
    z_dim = 64
    gen = torch.zeros_like
    disc = nn.Identity()
    criterion = torch.mul # Multiply
    gen_loss_tensor = get_gen_loss(gen, disc, criterion, num_images, z_dim, 'cpu')
    assert torch.all(torch.abs(gen_loss_tensor) < 1e-5)
    #Verify shape. Related to gen_noise parametrization
    assert tuple(gen_loss_tensor.shape) == (num_images, z_dim)

    gen = torch.ones_like
    disc = nn.Identity()
    criterion = torch.mul # Multiply
    real = torch.zeros(num_images, 1)
    gen_loss_tensor = get_gen_loss(gen, disc, criterion, num_images, z_dim, 'cpu')
    assert torch.all(torch.abs(gen_loss_tensor - 1) < 1e-5)
    #Verify shape. Related to gen_noise parametrization
    assert tuple(gen_loss_tensor.shape) == (num_images, z_dim)
    return
test_gen_reasonable(10)
#+end_src

#+begin_src python :results none
def test_gen_loss(num_images):
    z_dim = 64
    gen = Generator(z_dim).to(device)
    gen_opt = torch.optim.Adam(gen.parameters(), lr=lr)
    disc = Discriminator().to(device) 
    disc_opt = torch.optim.Adam(disc.parameters(), lr=lr)
    
    gen_loss = get_generator_loss(gen, disc, criterion, num_images, z_dim, device)
    
    # Check that the loss is reasonable
    assert (gen_loss - 0.7).abs() < 0.1
    gen_loss.backward()
    old_weight = gen.generator[0][0].weight.clone()
    gen_opt.step()
    new_weight = gen.generator[0][0].weight
    assert not torch.all(torch.eq(old_weight, new_weight))
test_gen_loss(18)
#+end_src
*** All Together
For each epoch, you will process the entire dataset in batches. For every batch, you will need to update the discriminator and generator using their loss. Batches are sets of images that will be predicted on before the loss functions are calculated (instead of calculating the loss function after each image). Note that you may see a loss to be greater than 1, this is okay since binary cross entropy loss can be any positive number for a sufficiently confident wrong guess. 
 
 Itâ€™s also often the case that the discriminator will outperform the generator, especially at the start, because its job is easier. It's important that neither one gets too good (that is, near-perfect accuracy), which would cause the entire model to stop learning. Balancing the two models is actually remarkably hard to do in a standard GAN and something you will see more of in later lectures and assignments.

 After you've submitted a working version with the original architecture, feel free to play around with the architecture if you want to see how different architectural choices can lead to better or worse GANs. For example, consider changing the size of the hidden dimension, or making the networks shallower or deeper by changing the number of layers.

#+begin_src python :results output :exports both
def train(epochs: int=2000, gen: Generator=gen,
          gen_opt: torch.optim.Adam=gen_opt,
          disc: Discriminator=disc,
          disc_opt: torch.optim.Adam=disc_opt,
          start_step: int=0,
          best_loss: float = INFINITY,
          test_the_generator: bool=True,
          display_step: int=4500) -> PlotData:
    """Train a batch

    Args:
     epochs: number of epochs to train
     gen: the Generator object
     gen_opt: optimizer for the generator
     disc: the Discriminator object
     disc_opt: the optimizer for the discriminator
     start_step: where we are in the training if this is called more than once
     best_loss: what the best loss for the generator has been so far
     test_the_generator: whether to double-check the generator is changing
     display_step: how often to emit messages
    """
    current_step = start_step
    mean_generator_loss = 0
    mean_discriminator_loss = 0
    generator_loss = False
    error = False
    generator_losses = []
    discriminator_losses = []
    steps = []
    
    with TIMER:
        for epoch in range(epochs):
          
            # Dataloader returns the batches
            for real, _ in dataloader:
                cur_batch_size = len(real)
        
                # Flatten the batch of real images from the dataset
                real = real.view(cur_batch_size, -1).to(device)
        
                ### Update discriminator ###
                # Zero out the gradients before backpropagation
                disc_opt.zero_grad()
        
                # Calculate discriminator loss
                disc_loss = get_disc_loss(gen, disc, criterion, real,
                                          cur_batch_size, z_dim, device)
        
                # Update gradients
                disc_loss.backward(retain_graph=True)
        
                # Update optimizer
                disc_opt.step()
        
                # For testing purposes, to keep track of the generator weights
                if test_generator:
                    old_generator_weights = gen.generator[0][0].weight.detach().clone()
        
                ### Update generator ###
                gen_opt.zero_grad()
                generator_loss = get_generator_loss(gen, disc, criterion, cur_batch_size, z_dim, device)
                generator_loss.backward(retain_graph=True)
                gen_opt.step()

                # check if it's the best so far
                if generator_loss.item() < best_loss:
                    best_loss = generator_loss.item()
                    print(f"Saving model with best loss so far ({best_loss:.2f})")

                    torch.save(gen.state_dict(), MODEL_PATH)
                # For testing purposes, to check that your code changes the generator weights
                if test_generator:
                    try:
                        assert lr > 0.0000002 or (gen.generator[0][0].weight.grad.abs().max() < 0.0005 and epoch == 0)
                        assert torch.any(gen.generator[0][0].weight.detach().clone() != old_generator_weights)
                    except:
                        error = True
                        print("Runtime tests have failed")
        
                # Keep track of the average discriminator loss
                mean_discriminator_loss += disc_loss.item() / display_step
        
                # Keep track of the average generator loss
                mean_generator_loss += generator_loss.item() / display_step
        
                if current_step % display_step == 0 and current_step > 0:
                    print(f"Epoch {epoch}, step {current_step}: Generator loss:"
                            f" {mean_generator_loss}, discriminator loss:"
                            f" {mean_discriminator_loss}")
                    steps.append(current_step)
                    generator_losses.append(mean_generator_loss)
                    discriminator_losses.append(mean_discriminator_loss)
    
                    mean_generator_loss = 0
                    mean_discriminator_loss = 0
                current_step += 1
    return PlotData(steps=steps, generator_losses=generator_losses,
                    discriminator_losses=discriminator_losses, best_loss=best_loss)
print(train(epochs=10))
#+end_src

#+RESULTS:
#+begin_example
Started: 2021-12-12 21:18:06.595695
Saving model with best loss so far (3.82)
Saving model with best loss so far (3.77)
Saving model with best loss so far (3.75)
Saving model with best loss so far (3.58)
Saving model with best loss so far (3.54)
Saving model with best loss so far (3.50)
Saving model with best loss so far (3.25)
Epoch 9, step 4500: Generator loss: 4.100310390790306, discriminator loss: 0.053616619475599675
Ended: 2021-12-12 21:19:19.963121
Elapsed: 0:01:13.367426
PlotData(steps=[4500], generator_losses=[4.100310390790306], discriminator_losses=[0.053616619475599675], best_loss=3.2485642433166504)
#+end_example

#+begin_src python :results none
def run_batch(parts: GANParts, plot_data: PlotData,
              batch_size: int=100) -> PlotData:
    """Run a smaller batch of epochs

    Args:
     parts: the GAN parts
     plot_data: the accumulated output of the training

    Returns:
     updated plot_data
    """
    next_step = max(plot_data.steps) + 1 if plot_data.steps else 0
    best_loss = plot_data.best_loss
    output = train(gen=parts.generator,
                   gen_opt=parts.generator_optimizer,
                   disc=parts.discriminator,
                   disc_opt=parts.discriminator_optimizer, epochs=batch_size,
                   start_step=next_step, best_loss=best_loss)
    return PlotData(
        steps=plot_data.steps + output.steps,
        generator_losses=plot_data.generator_losses + output.generator_losses,
        discriminator_losses=(plot_data.discriminator_losses +
                              output.discriminator_losses), best_loss=output.best_loss)
#+end_src

At about one epoch a minute, this should take about an hour and forty minutes or so.

#+begin_src python :results output :exports both
parts = build_parts()
plot_data = run_batch(parts, PlotData([], [], [], best_loss=INFINITY))
#+end_src

#+RESULTS:
#+begin_example
Started: 2021-12-12 22:41:21.823164
Saving model with best loss so far (0.68)
Epoch 9, step 4500: Generator loss: 2.0671158762905333, discriminator loss: 0.2002916043450438
Epoch 19, step 9000: Generator loss: 3.894586259894906, discriminator loss: 0.07030286101831354
Epoch 28, step 13500: Generator loss: 4.128244651317588, discriminator loss: 0.07312827965741342
Epoch 38, step 18000: Generator loss: 3.679966155105171, discriminator loss: 0.11400978071076953
Epoch 47, step 22500: Generator loss: 3.396804347621069, discriminator loss: 0.1500528004517162
Epoch 57, step 27000: Generator loss: 3.1040636014938245, discriminator loss: 0.17772292008996066
Epoch 67, step 31500: Generator loss: 2.8721981742117144, discriminator loss: 0.20018046746320184
Epoch 76, step 36000: Generator loss: 2.6418062130610167, discriminator loss: 0.22749259825216356
Epoch 86, step 40500: Generator loss: 2.5520630269580473, discriminator loss: 0.2384359383367829
Epoch 95, step 45000: Generator loss: 2.2842552210754827, discriminator loss: 0.2856089066366352
Ended: 2021-12-12 22:53:26.813378
Elapsed: 0:12:04.990214
#+end_example

Twelve minutes... something's wrong with my math (or my code).

#+begin_src python :results output :exports both
plot_data = run_batch(parts, plot_data, batch_size=500)
#+end_src

#+RESULTS:
#+begin_example
Started: 2021-12-12 22:56:24.985796
Epoch 9, step 49500: Generator loss: 1.9961646406915445, discriminator loss: 0.3290849660535635
Epoch 19, step 54000: Generator loss: 1.8578781396812813, discriminator loss: 0.352255903386407
Epoch 28, step 58500: Generator loss: 1.7970310585498779, discriminator loss: 0.35997216095195933
Epoch 38, step 63000: Generator loss: 1.790595402267244, discriminator loss: 0.35704792838626415
Epoch 47, step 67500: Generator loss: 1.6337452937761876, discriminator loss: 0.399976011382207
Epoch 57, step 72000: Generator loss: 1.553067971309023, discriminator loss: 0.4149618665973359
Epoch 67, step 76500: Generator loss: 1.530716036346228, discriminator loss: 0.41230284125937433
Epoch 76, step 81000: Generator loss: 1.4763377503554027, discriminator loss: 0.42583107221126515
Epoch 86, step 85500: Generator loss: 1.4468076727655206, discriminator loss: 0.43238778846131376
Epoch 95, step 90000: Generator loss: 1.341741836388908, discriminator loss: 0.4629372137056456
Epoch 105, step 94500: Generator loss: 1.3321984058486116, discriminator loss: 0.4620412641101409
Epoch 115, step 99000: Generator loss: 1.2581868343618232, discriminator loss: 0.48384387395116984
Epoch 124, step 103500: Generator loss: 1.2193222048944967, discriminator loss: 0.4943520678679146
Epoch 134, step 108000: Generator loss: 1.210901861535182, discriminator loss: 0.4949321229921447
Epoch 143, step 112500: Generator loss: 1.1491395987007338, discriminator loss: 0.5172655161817865
Epoch 153, step 117000: Generator loss: 1.1057299662033748, discriminator loss: 0.5293599960472835
Epoch 163, step 121500: Generator loss: 1.0677826208141108, discriminator loss: 0.5450594869587152
Epoch 172, step 126000: Generator loss: 1.0314588887823974, discriminator loss: 0.5558468225730787
Epoch 182, step 130500: Generator loss: 0.988256526258255, discriminator loss: 0.5727653868463289
Epoch 191, step 135000: Generator loss: 0.9866233132415357, discriminator loss: 0.5702601793143482
Epoch 201, step 139500: Generator loss: 0.9552508686383555, discriminator loss: 0.5773511084649297
Epoch 211, step 144000: Generator loss: 0.9940739690330269, discriminator loss: 0.5602315128578074
Epoch 220, step 148500: Generator loss: 0.957331194546487, discriminator loss: 0.5762877901130254
Epoch 230, step 153000: Generator loss: 0.940105734388034, discriminator loss: 0.5758193738725437
Epoch 239, step 157500: Generator loss: 0.9115204359822786, discriminator loss: 0.5869797533286937
Epoch 249, step 162000: Generator loss: 0.9108314050965834, discriminator loss: 0.5894923475186025
Epoch 259, step 166500: Generator loss: 0.8571861512131169, discriminator loss: 0.6157774040169194
Epoch 268, step 171000: Generator loss: 0.9255197024875222, discriminator loss: 0.5831143510672784
Epoch 278, step 175500: Generator loss: 0.9227028174797725, discriminator loss: 0.5861976487901457
Epoch 287, step 180000: Generator loss: 0.9116632200082172, discriminator loss: 0.5921973378062267
Epoch 297, step 184500: Generator loss: 0.896604921857515, discriminator loss: 0.5983437673317067
Epoch 307, step 189000: Generator loss: 0.8876715467108619, discriminator loss: 0.5988295680549406
Epoch 316, step 193500: Generator loss: 0.8981850113338913, discriminator loss: 0.596900998810927
Epoch 326, step 198000: Generator loss: 0.9132995079225976, discriminator loss: 0.5932699956099183
Saving model with best loss so far (0.67)
Saving model with best loss so far (0.66)
Saving model with best loss so far (0.66)
Saving model with best loss so far (0.65)
Saving model with best loss so far (0.64)
Saving model with best loss so far (0.63)
Saving model with best loss so far (0.62)
Epoch 335, step 202500: Generator loss: 0.8218274900118518, discriminator loss: 0.6400571531719623
Epoch 345, step 207000: Generator loss: 0.9687661434412017, discriminator loss: 0.5792819880843164
Saving model with best loss so far (0.62)
Saving model with best loss so far (0.61)
Saving model with best loss so far (0.59)
Saving model with best loss so far (0.59)
Saving model with best loss so far (0.58)
Saving model with best loss so far (0.58)
Saving model with best loss so far (0.57)
Saving model with best loss so far (0.56)
Saving model with best loss so far (0.56)
Saving model with best loss so far (0.53)
Saving model with best loss so far (0.51)
Saving model with best loss so far (0.50)
Epoch 355, step 211500: Generator loss: 0.7063771485355128, discriminator loss: 0.7654304582807753
Epoch 364, step 216000: Generator loss: 0.8059421989785318, discriminator loss: 0.6302714381350409
Epoch 374, step 220500: Generator loss: 0.9056880848937555, discriminator loss: 0.5996440589427954
Epoch 383, step 225000: Generator loss: 0.9476164460844481, discriminator loss: 0.5872065601017749
Epoch 393, step 229500: Generator loss: 0.8700628989405085, discriminator loss: 0.614429159349864
Epoch 402, step 234000: Generator loss: 0.9316757869985379, discriminator loss: 0.5935855323341168
Epoch 412, step 238500: Generator loss: 0.9884794838296045, discriminator loss: 0.5769219878051017
Epoch 422, step 243000: Generator loss: 0.9787677707009845, discriminator loss: 0.5881667502986057
Epoch 431, step 247500: Generator loss: 0.9812438432375566, discriminator loss: 0.5934927140739243
Epoch 441, step 252000: Generator loss: 0.9866997564368781, discriminator loss: 0.5696533908512852
Epoch 450, step 256500: Generator loss: 1.0139115802447014, discriminator loss: 0.5784266778760502
Epoch 460, step 261000: Generator loss: 0.9905964203940505, discriminator loss: 0.5876510691973909
Epoch 470, step 265500: Generator loss: 0.9866478079954776, discriminator loss: 0.5789911089009697
Epoch 479, step 270000: Generator loss: 0.9699252954191648, discriminator loss: 0.593749921997389
Epoch 489, step 274500: Generator loss: 0.9484661724964777, discriminator loss: 0.5820076752834854
Epoch 498, step 279000: Generator loss: 0.9874062088992859, discriminator loss: 0.5781058085229654
Ended: 2021-12-12 23:56:45.487848
Elapsed: 1:00:20.502052
#+end_example

#+begin_src python :results none
def hook(plot, element):
    figure = plot.state
    figure["layout"]["sizing_mode"] = Plot.sizing_mode
    return

def plot_losses(plot_data: PlotData, file_name: str="losses",
                title: str="Training Loss"):
    """Plot the losses in Holoviews

    Args:
     plot_data: namedtuple with the losses over time
     file_name: name to save the plot (without extension)
     title: title for the plot
    """
    plotting = pandas.DataFrame.from_dict({
        "Step": plot_data.steps,
        "Generator Loss": plot_data.generator_losses,
        "Discriminator Loss": plot_data.discriminator_losses
    })

    gen_plot = plotting.hvplot(x="Step", y="Generator Loss", color=Plot.blue)
    disc_plot = plotting.hvplot(x="Step", y="Discriminator Loss", color=Plot.red)

    plot = (gen_plot * disc_plot).opts(title=title,
                                       height=Plot.height,
                                       width=Plot.width,
                                       ylabel="Loss",
                                       hooks=[hook],
                                       fontscale=Plot.fontscale)
    return Embed(plot=plot, file_name=file_name)()
#+end_src

#+begin_src python :results none
output = plot_losses(plot_data)
#+end_src

#+begin_src python :results output html :exports results
print(output)
#+end_src

#+begin_export html
<object type="text/html" data="losses.html" style="width:100%" height=800>
  <p>Figure Missing</p>
</object>
#+end_export


#+begin_src python :results output :exports both
plot_data = run_batch(parts, plot_data, batch_size=500)
output = plot_losses(plot_data, file_name="losses_2", title="Training Loss 2")
#+end_src

#+begin_src python :results output html :exports results
print(output)
#+end_src


#+begin_export html
<object type="text/html" data="losses_2.html" style="width:100%" height=800>
  <p>Figure Missing</p>
</object>
#+end_export

** Looking at the Final model.
#+begin_src python :results none
def plot_image(image: torch.Tensor,
                filename: str,
                title: str,
                num_images: int=25,
                size: tuple=(1, 28, 28),
                folder: str="files/posts/gans/mnist-gan/") -> None:
    """Plot the image and save it

    Args:
     image: the tensor with the image to plot
     filename: name for the final image file
     title: title to put on top of the image
     num_images: how many images to put in the composite image
     size: the size for the image
     folder: sub-folder to save the file in
    """
    unflattened_image = image.detach().cpu().view(-1, *size)
    image_grid = make_grid(unflattened_image[:num_images], nrow=5)

    pyplot.title(title)
    pyplot.grid(False)
    pyplot.imshow(image_grid.permute(1, 2, 0).squeeze())

    pyplot.tick_params(bottom=False, top=False, labelbottom=False,
                       right=False, left=False, labelleft=False)
    pyplot.savefig(folder + filename)
    print(f"[[file:{filename}]]")
    return
#+end_src

#+begin_src python :results output :exports both
fake_noise = get_noise(500, z_dim, device=device)
parts.generator.load_state_dict(torch.load(MODEL_PATH))
fake = parts.generator(fake_noise)
plot_image(image=fake, filename="fake_digits.png", title="Fake Digits")
#+end_src

 [[file:fake_digits.png]]

It's interesting that there's that crossover point where the generator's loss dips below the discriminator's and then they diverge again and the generator seems to stop improving. The digits for the best model do look passable as human-written digits, in most cases (depending on the human it might be in all cases).
