#+BEGIN_COMMENT
.. title: A Fully Connected Generator
.. slug: a-fully-connected-generator
.. date: 2023-07-01 15:51:10 UTC-07:00
.. tags: gans
.. category: GANs
.. link: 
.. description: A fully connected Generator for GANs.
.. type: text

#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 2

#+begin_src python :tangle ../neurotic/gans/fully_connected.py :exports none
# python
<<factory-python-imports>>

# pypi
<<factory-pypi-imports>>

<<generator-defaults>>


<<fully-connected-generator>>

    <<fully-connected-forward>>

<<generator-factory>>

    <<factory-block-method>>


    <<factory-blocks-property>>

    <<generator-property>>
#+end_src

* The Imports
** Python Imports

#+begin_src python :noweb-ref factory-python-imports
from dataclasses import dataclass
#+end_src

| Item        | Documentation |
|-------------+---------------|
| ~dataclass~ | [[https://docs.python.org/3/library/dataclasses.html][dataclasses]]   |

** PyPi Imports

#+begin_src python :noweb-ref factory-pypi-imports
from torch import nn
import torch
#+end_src

* Generator Defaults
The GeneratorDefault class is a [[https://docs.python.org/3/library/dataclasses.html][python dataclass]] to hold the default values for the generator.

#+begin_src python :noweb-ref generator-defaults
@dataclass
class GeneratorDefault:
    """Default values for the generator"""
    input_size: int=10
    hidden_layer_size: int=128
    output_size: int=784
    block_count: int=4
    size_multiplier: int=2
#+end_src

| Attribute         | Description                                                   |
|-------------------+---------------------------------------------------------------|
| input_size        | length of input to the network (presumed 10 is for 10 digits) |
| hidden_layer_size | length of output for first layer                              |
| output_size       | length of the output image                                    |
| block_count       | Number of Linear blocks for the generator                     |
| size_multiplier   | Amount hidden layer output multiplies by for each block       |

#+begin_notecard
The ~output_size~ is based on the MNIST images which are 28 pixels x 28 pixels and when flattened out to a one-dimensional vector ends up as 784 pixels.
#+end_notecard
* The Fully Connected Generator Factory

The ~GeneratorFactory~ builds the fully-connected Generator.

#+begin_src plantuml :file ../files/posts/a-fully-connected-generator/fully-connected-factory.png :exports none
!theme mars

class GeneratorFactory {
  input_size: Integer
  output_size: Integer
  hidden_layer_size: Integer
  block_count: Integer
  size_multiplier: Integer
  generator : nn.Sequential

  block(input_size: Integer, output_size: Integer) : nn.Sequential
}
#+end_src

#+RESULTS:
[[file:../files/posts/a-fully-connected-generator/fully-connected-factory.png]]

[[img-url: fully-connected-factory.png][Generator Factory Class Diagram]]

** The Generator Factory Definition

#+begin_src python :noweb-ref generator-factory
class GeneratorFactory:
    """Builder of fully-connected generators

    Args:

     input_size: length for the input noise-vector
     hidden_layer_size: length of output for first layer
     output_size: the length of the output image vector
     block_count: how many linear-norm-relu blocks to give the generator
     size_multiplier: how much to multiply hidden layer by for each block
    """
    def __init__(self, input_size: int=GeneratorDefault.input_size,
                 hidden_layer_size: int=GeneratorDefault.hidden_layer_size,
                 output_size: int=GeneratorDefault.output_size,
                 block_count: int=GeneratorDefault.block_count,
                 size_multiplier: int=GeneratorDefault.size_multiplier):
        self.input_size = input_size
        self.hidden_layer_size = hidden_layer_size
        self.output_size = output_size
        self.block_count = block_count
        self.size_multiplier = size_multiplier
        self._blocks = None
        self._generator = None
        return
#+end_src

** The Block Creation Method

#+begin_src python :noweb-ref factory-block-method
def block(self, input_size: int, output_size: int) -> nn.Sequential:
    """Create a linear block for the generator

    Args:
     - `input_size`: vector size for the input to the linear layer
     - `output_size`: vector size for the output

    Returns:
     - Sequential generator block
    """
    return nn.Sequential(
        nn.Linear(input_size, output_size),
        nn.BatchNorm1d(output_size),
        nn.ReLU(inplace=True),
    )
#+end_src

#+begin_notecard
**Note:** The default for ~ReLU~ is ~inplace=False~, but according to this [[https://discuss.pytorch.org/t/guidelines-for-when-and-why-one-should-set-inplace-true/50923][post on pytorch's forum]] you can use ~inplace=True~ to save memory if it doesn't produce an error and you don't need the values that you had before applying the ReLU. Confusingly, though, the [[https://pytorch.org/docs/master/notes/autograd.html#in-place-operations-with-autograd][Autograd  Documentation]] suggests you never use ~inplace=True~ since it doesn't save much memory and can cause problems for Autograd. Hmm...
#+end_notecard

** The Blocks Property

#+begin_src python :noweb-ref factory-blocks-property
@property
def blocks(self) -> nn.Sequential: 
   """Creates the network for the generator


    Returns:
     sequence of generator blocks with Linear and Sigmoid tail
    """
   if self._blocks is None:
      input_size, output_size = self.input_size, self.hidden_layer_size
      blocks = []

      for block in range(self.block_count):
         blocks.append(self.block(input_size, output_size))
         input_size, output_size = (output_size, output_size
                                    ,* self.size_multiplier)


      input_size = input_size if self.block_count else output_size
      blocks.append(nn.Linear(input_size,
                              self.output_size))
      blocks.append(nn.Sigmoid())
      self._blocks = nn.Sequential(*blocks)
   return self._blocks
#+end_src

** The Generator Property

#+begin_src python :noweb-ref generator-property
@property
def generator(self) -> FullyConnectedGenerator:
    """The built generator"""
    if self._generator is None:
        self._generator = FullyConnectedGenerator(self.blocks)
    return self._generator
#+end_src
* The Fully Connected Generator

 #+begin_src plantuml :file ../files/posts/a-fully-connected-generator/fully-connected.png :exports none
!theme mars

class FullyConnectedGenerator {
 generator: Sequential
 forward(noise: torch.Tensor) : torch.Tensor
}

nn.Sequential o- FullyConnected
nn.Module <|-- FullyConnected
 #+end_src

 #+RESULTS:
 [[file:../files/posts/a-fully-connected-generator/fully-connected.png]]

 [[img-url: fully-connected.png]]

** The Generator

#+begin_notecard
*Note:* Since I'm using type-hinting for the ~GeneratorFactory.generator~ the class definition for the ~FullyConnectedGenerator~ has to come before the ~GeneratorFactory~ in the actual python module or it will raise an error. I put this section after the Factory's section in this post because it's less interesting.
#+end_notecard

#+begin_src python :noweb-ref fully-connected-generator
class FullyConnectedGenerator(nn.Module):
    """A fully-connected multilayer perceptron

    Args:
      network: the feed-forward network to use.
    """
    def __init__(self, network: nn.Sequential):
        super().__init__()
        self.network = network
        return
#+end_src

** The Forward Method

#+begin_src python :noweb-ref fully-connected-forward
def forward(self, noise: torch.Tensor) -> torch.Tensor:
    """Runs the noise through the network

    Args:
     noise: vector input for the network

    Returns:
     Image output by the network
    """
    return self.network(noise)
#+end_src
* Testing the Factory

#+begin_src gherkin :noweb-ref feature-fully-connected-factory
Feature: A Fully Connected Generator factory
  A builder of fully-connected multi-layer perceptrons to generate images.
#+end_src

#+begin_src gherkin :tangle ../tests/features/fully_connected/generator_factory.feature :exports none
<<feature-fully-connected-factory>>

<<scenario-default-factory>>

<<scenario-factory-block>>

<<scenario-factory-blocks>>

<<scenario-no-block-count>>

<<scenario-factory-arbitrary-blocks>>

<<scenario-factory-arbitrary-size-multiplier>>

<<scenario-factory-builds-generator>>
#+end_src

#+begin_src python :tangle ../tests/functional/fully_connected/test_generator_factory.py :exports none
"""Fully Connected Generator factory feature tests."""
# python

<<python-testing-imports>>
# from pypi

<<pypi-testing-imports>>

# the software under test
<<factory-import>>


<<fake-sequential>>


<<scenarios>>

#* Scenario: The default fully-connected generator factory *#

<<given-default-factory>>


<<check-input-size>>


<<check-hidden-size>>


<<check-output-size>>


<<check-block-count>>


<<check-size-multiplier>>


<<default-input-size>>


<<default-hidden-size>>


<<default-output-size>>


<<default-block-count>>


<<default-size-multiplier>>

#* Scenario: The Default Factory Builds a Block *#

#**  Given a default fully-connected-generator-factory

<<call-block-method>>


<<check-block>>


<<check-block-length>>


<<check-linear>>


<<check-normalization-layer>>


<<check-activation-layer>>


#** Scenario: The Default Factory Builds the Blocks **#

#  Given a default fully-connected-generator-factory


<<get-blocks-property>>


<<check-blocks-are-sequential>>


<<check-blocks-layer-count>>


<<check-blocks-block-layers>>


<<check-second-to-the-last-layer>>


<<check-second-to-last-input-and-output>>


<<check-last-layer-is-sigmoid>>


#** Scenario: The Factory Builds With No Generator Blocks **#

<<create-factory-with-zero-block-count>>

#  When the blocks property is checked
#  Then the blocks have the right number of layers
#  And the blocks linear layer has the right input and output dimensions
#  And the second to the last blocks layer is a linear layer
#  And the last blocks layer is a sigmoid

# ** Scenario: The Factory Builds With Arbitrary Generator Blocks ** #

<<arbitrary-block-count>>

#  When the blocks property is checked
#  Then the blocks have the right number of layers
#  And the second to the last blocks layer is a linear layer
#  And the blocks linear layer has the right input and output dimensions
#  And the last blocks layer is a sigmoid

# ** Scenario: The Factory Builds with Arbitrary Size Multiplier ** #


<<arbitrary-size-multiplier>>

#  When the blocks property is checked
#  Then the blocks have the right number of layers
#  And the second to the last blocks layer is a linear layer
#  And the blocks linear layer has the right input and output dimensions
#  And the last blocks layer is a sigmoid


# ** Scenario: The factory builds the Generator ** #

#  Given a default fully-connected-generator-factory


<<get-the-generator>>


<<its-fully-connected>>


<<it-has-the-blocks>>
#+end_src
** The imports
*** From Python

#+begin_src python :noweb-ref python-testing-imports
import math
import random
#+end_src

*** From PyPi
#+begin_src python :noweb-ref pypi-testing-imports
from expects import (
    be,
    be_a,
    be_true,
    equal,
    expect,
    have_length,
)

from pytest_bdd import (
    given,
    scenarios,
    then,
    when,
)

from torch import nn

# this project (testing only)
from ..fixtures import katamari


and_when = when
And = then
#+end_src

** The Factory Imports

#+begin_src python :noweb-ref factory-import
from neurotic.gans.fully_connected import (GeneratorDefault,
                                           GeneratorFactory,
                                           FullyConnectedGenerator)
#+end_src
** Set the Feature File
#+begin_src python :noweb-ref scenarios
scenarios("fully_connected/generator_factory.feature")
#+end_src

** The Fake Sequential

This is a fake-Sequential object to test the blocks property.

#+begin_src python :noweb-ref fake-sequential
class FakeSequential(nn.Module):
    """A fake module to check blocks"""
#+end_src
** The Default Factory Scenario

#+begin_src gherkin :noweb-ref scenario-default-factory
Scenario: The default fully-connected generator factory
  Given a default fully-connected-generator-factory
  When the input_size is checked
  And the hidden_size is checked
  And the output_size is checked
  And the block_count is checked
  And the size_multiplier is checked

  Then the input_size is the default
  And the hidden_size is the default
  And the image_size is the default
  And the block_count is the default
  And the size_multiplier is the default
#+end_src
*** The Default Fully Connected Generator Factory

#+begin_src python :noweb-ref given-default-factory
@given("a default fully-connected-generator-factory",
       target_fixture="test_thing")
def _(katamari):
    katamari.factory =  GeneratorFactory()
    return katamari
#+end_src

*** Check the Input Size
#+begin_src python :noweb-ref check-input-size
@when("the input_size is checked", target_fixture="input_size")
def _(test_thing):
    return test_thing.factory.input_size
#+end_src

*** Default Input Size

#+begin_src python :noweb-ref default-input-size
@then('the input_size is the default')
def _(input_size):
    expect(input_size).to(equal(GeneratorDefault.input_size))
    return
#+end_src

*** Check Hidden Layer Size

#+begin_src python :noweb-ref check-hidden-size
@and_when("the hidden_size is checked", target_fixture="hidden_size")
def _(test_thing):
    return test_thing.factory.hidden_layer_size
#+end_src
*** Default Hidden Layer Size

#+begin_src python :noweb-ref default-hidden-size
@then("the hidden_size is the default")
def _(hidden_size):
    expect(hidden_size).to(equal(GeneratorDefault.hidden_layer_size))
#+end_src
*** Check the Output Image Size

#+begin_src python :noweb-ref check-output-size
@and_when("the output_size is checked", target_fixture="output_size")
def _(test_thing):
    return test_thing.factory.output_size
#+end_src
*** Default Output Image Size

#+begin_src python :noweb-ref default-output-size
@then("the image_size is the default")
def _(output_size):
    expect(output_size).to(equal(GeneratorDefault.output_size))
#+end_src
*** Check the Block Count

#+begin_src python :noweb-ref check-block-count
@and_when("the block_count is checked", target_fixture="block_count")
def _(test_thing):
    return test_thing.factory.block_count
#+end_src
*** Default Block Count

#+begin_src python :noweb-ref default-block-count
@then("the block_count is the default")
def _(block_count):
    expect(block_count).to(equal(GeneratorDefault.block_count))
#+end_src
*** Check the Size Multiplier

#+begin_src python :noweb-ref check-size-multiplier
@and_when("the size_multiplier is checked", target_fixture="size_multiplier")
def _(test_thing):
    return test_thing.factory.size_multiplier
#+end_src

*** Default Size Multiplier

#+begin_src python :noweb-ref default-size-multiplier
@then("the size_multiplier is the default")
def _(size_multiplier):
    expect(size_multiplier).to(equal(GeneratorDefault.size_multiplier))
    return
#+end_src
** The Block Method Call Scenario

#+begin_src gherkin :noweb-ref scenario-factory-block
Scenario: The Default Factory Builds a Block
  Given a default fully-connected-generator-factory
  When the block method is called
  Then the block output is a Sequential
  And the block output has three layers
  And the block output has the expected Linear layer
  And the block output has the expected Normalization Layer
  And the block output has the expected activation layer
#+end_src

*** Call the Block

#+begin_src python :noweb-ref call-block-method
@when("the block method is called", target_fixture="block_output" )
def _(test_thing):
    test_thing.input_size = random.randrange(10, 100)
    test_thing.output_size = random.randrange(10, 100)
    return test_thing.factory.block(input_size=test_thing.input_size,
                                    output_size=test_thing.output_size)
#+end_src

*** Check the Block

#+begin_src python :noweb-ref check-block
@then("the block output is a Sequential")
def _(block_output):
    expect(block_output).to(be_a(nn.Sequential))
    return
#+end_src

*** Check The Number Of Layers

#+begin_src python :noweb-ref check-block-length
@And("the block output has three layers")
def _(block_output):
    expect(block_output).to(have_length(3))
    return
#+end_src

*** Check The linear Layer

#+begin_src python :noweb-ref check-linear
@And("the block output has the expected Linear layer")
def _(block_output, test_thing):
    first_layer = block_output[0]
    expect(first_layer).to(be_a(nn.Linear))
    expect(first_layer.in_features).to(equal(test_thing.input_size))
    expect(first_layer.out_features).to(equal(test_thing.output_size))
    return
#+end_src

*** Check the Normalization Layer

#+begin_src python :noweb-ref check-normalization-layer
@And("the block output has the expected Normalization Layer")
def _(block_output, test_thing):
    second_layer = block_output[1]
    expect(second_layer).to(be_a(nn.BatchNorm1d))
    expect(second_layer.num_features).to(equal(test_thing.output_size))
    return
#+end_src

*** Check the Activation Layer

#+begin_src python :noweb-ref check-activation-layer
@And("the block output has the expected activation layer")
def _(block_output):
    third_layer = block_output[2]
    expect(third_layer).to(be_a(nn.ReLU))
    expect(third_layer.inplace).to(be_true)
    return
#+end_src

** The Blocks Property Scenario

#+begin_src gherkin :noweb-ref scenario-factory-blocks
Scenario: The Default Factory Builds the Blocks
  Given a default fully-connected-generator-factory
  When the blocks property is checked
  Then the blocks are a Sequential
  And the blocks have the right number of layers
  And all but the last two blocks layers match the block call
  And the second to the last blocks layer is a linear layer
  And the blocks linear layer has the right input and output dimensions
  And the last blocks layer is a sigmoid
#+end_src
*** Get the Blocks

#+begin_src python :noweb-ref get-blocks-property
@when("the blocks property is checked", target_fixture="blocks")
def _(test_thing, monkeypatch):
    def mock_blocks(input_size, output_size):
        return FakeSequential()
    monkeypatch.setattr(test_thing.factory, "block", mock_blocks)
    return test_thing.factory.blocks
#+end_src

*** Check the Blocks are Sequential

#+begin_src python :noweb-ref check-blocks-are-sequential
@then("the blocks are a Sequential")
def _(blocks):
    expect(blocks).to(be_a(nn.Sequential))
    return
#+end_src

*** Check the Blocks Layer Count

#+begin_src python :noweb-ref check-blocks-layer-count
@And("the blocks have the right number of layers")
def _(blocks, test_thing):
    expect(blocks).to(have_length(test_thing.factory.block_count + 2))
    return
#+end_src

*** Check the Blocks Blocks

#+begin_src python :noweb-ref check-blocks-block-layers
@And("all but the last two blocks layers match the block call")
def _(blocks):
    for layer in blocks[:-2]:
        expect(layer).to(be_a(FakeSequential))
    return
#+end_src

*** Check the Second to the Last Layer

#+begin_src python :noweb-ref check-second-to-the-last-layer
@And("the second to the last blocks layer is a linear layer")
def _(blocks):
    expect(blocks[-2]).to(be_a(nn.Linear))
    return
#+end_src

*** Check Second to Last Layer Input and Output

#+begin_src python :noweb-ref check-second-to-last-input-and-output
@And("the blocks linear layer has the right input and output dimensions")
def _(blocks, test_thing):
    almost_last = blocks[-2]
    expected_input_size = (math.ceil(
        test_thing.factory.size_multiplier** (test_thing.factory.block_count - 1))
        ,* test_thing.factory.hidden_layer_size)
    expected_output_size = test_thing.factory.output_size
    expect(almost_last.in_features).to(equal(expected_input_size))
    expect(almost_last.out_features).to(equal(expected_output_size))
    return
#+end_src

*** Check the Last Blocks Layer

#+begin_src python :noweb-ref check-last-layer-is-sigmoid
@And("the last blocks layer is a sigmoid")
def _(blocks):
    expect(blocks[-1]).to(be_a(nn.Sigmoid))
    return
#+end_src

** Scenario: No Block Count

#+begin_src gherkin :noweb-ref scenario-no-block-count
Scenario: The Factory Builds With No Generator Blocks
  Given a fully-connected-generator-factory with no block_count
  When the blocks property is checked
  Then the blocks have the right number of layers
  And the second to the last blocks layer is a linear layer
  And the blocks linear layer has the right input and output dimensions
  And the last blocks layer is a sigmoid
#+end_src

#+begin_src python :noweb-ref create-factory-with-zero-block-count
@given("a fully-connected-generator-factory with no block_count",
       target_fixture="test_thing")
def _(katamari):
    katamari.factory = GeneratorFactory(block_count=0)
    return katamari
#+end_src

** Scenario: Some Arbitrary Number of Blocks

#+begin_src gherkin :noweb-ref scenario-factory-arbitrary-blocks
Scenario: The Factory Builds With Arbitrary Generator Blocks
  Given a fully-connected-generator-factory with an arbitrary block_count
  When the blocks property is checked
  Then the blocks have the right number of layers
  And the second to the last blocks layer is a linear layer
  And the blocks linear layer has the right input and output dimensions
  And the last blocks layer is a sigmoid
#+end_src

#+begin_src python :noweb-ref arbitrary-block-count
@given("a fully-connected-generator-factory with an arbitrary block_count",
       target_fixture="test_thing")
def _(katamari):
    katamari.factory = GeneratorFactory(
        block_count=random.randrange(10)
    )
    return katamari
#+end_src

** Scenario: Arbitrary Size Multiplier

#+begin_src gherkin :noweb-ref scenario-factory-arbitrary-size-multiplier
Scenario: The Factory Builds with Arbitrary Size Multiplier
  Given a fully-connected-generator-factory with an arbitrary size_multiplier
  When the blocks property is checked
  Then the blocks have the right number of layers
  And the second to the last blocks layer is a linear layer
  And the blocks linear layer has the right input and output dimensions
  And the last blocks layer is a sigmoid
#+end_src

#+begin_src python :noweb-ref arbitrary-size-multiplier
@given("a fully-connected-generator-factory with an arbitrary size_multiplier",
       target_fixture="test_thing")
def _(katamari):
    katamari.factory = GeneratorFactory(size_multiplier=random.randint(2, 10))
    return katamari
#+end_src
** Scenario: The Generator is checked

#+begin_src gherkin :noweb-ref scenario-factory-builds-generator
Scenario: The factory builds the Generator
  Given a default fully-connected-generator-factory
  When the generator is checked
  Then the generator is a Fully Connected Generator
  And the generator has the factory's blocks
#+end_src

#+begin_src python :noweb-ref get-the-generator
@when("the generator is checked", target_fixture="el_generator")
def _(test_thing):
    return test_thing.factory.generator
#+end_src

*** The Generator is Fully Connected

#+begin_src python :noweb-ref its-fully-connected
@then("the generator is a Fully Connected Generator")
def _(el_generator):
    expect(el_generator).to(be_a(FullyConnectedGenerator))
    return
#+end_src
*** The Generator Has the Factory's Blocks

#+begin_src python :noweb-ref it-has-the-blocks
@And("the generator has the factory's blocks")
def _(test_thing, el_generator):
    expect(el_generator.network).to(be(test_thing.factory.blocks))
    return
#+end_src
* Testing The Generator

#+begin_src gherkin :noweb-ref feature-fully-connected-generator
Feature: A Fully Connected Generator
  A fully-connected multilayer perceptron to generate images
#+end_src

#+begin_src gherkin  :tangle ../tests/features/fully_connected/generator.feature :exports none
<<feature-fully-connected-generator>>

<<scenario-generator-is-built>>

<<scenario-generator-forward>>
#+end_src

#+begin_src python :tangle ../tests/functional/fully_connected/test_generator.py :exports none
<<generator-pypi-imports>>

# software under test

<<generator-import>>


<<generator-scenarios>>


# ** Scenario: The fully connected generator is built ** #

<<build-the-generator>>


<<check-the-generator>>


<<check-the-generators-parent>>


# ** Scenario: The generator's forward method is called ** #
#  Given a fully connected generator

<<call-the-forward-method>>


<<check-the-networks-call>>

<<check-the-returned-output>>
#+end_src

** Imports
*** PyPi

#+begin_src python :noweb-ref generator-pypi-imports
from expects import (
    be,
    be_a,    
    equal,
    expect
)
from pytest_bdd import (
    given,
    scenarios,
    then,
    when,
)

from torch import nn

# this project (testing only)
from ..fixtures import katamari


# testing alias
And = then
#+end_src
*** The Generator Import

#+begin_src python :noweb-ref generator-import
from neurotic.gans.fully_connected import FullyConnectedGenerator
#+end_src

** Set the Feature File
#+begin_src python :noweb-ref generator-scenarios
scenarios("fully_connected/generator.feature")
#+end_src

** Scenario: Buld the Generator
#+begin_src gherkin :noweb-ref scenario-generator-is-built
Scenario: The fully connected generator is built
  Given a fully connected generator
  When the generator is checked
  Then it is a nn Module
#+end_src

*** Build the Generator
#+begin_src python :noweb-ref build-the-generator
@given("a fully connected generator", target_fixture="generator")
def _(mocker):
    return FullyConnectedGenerator(mocker.MagicMock(spec=nn.Sequential))
#+end_src

*** Check the Generator

#+begin_src python :noweb-ref check-the-generator
@when("the generator is checked")
def _():
    return
#+end_src

*** Check the Generator's Type

#+begin_src python :noweb-ref check-the-generators-parent
@then("it is a nn Module")
def _(generator):
    expect(generator).to(be_a(nn.Module))
    return
#+end_src

** Scenario: Call the Forward Method

#+begin_src gherkin :noweb-ref scenario-generator-forward
Scenario: The generator's forward method is called
  Given a fully connected generator
  When the generator's forward method is called
  Then it passes the input to its network
  And it returns the output of the network
#+end_src

*** Call the Forward Method
#+begin_src python :noweb-ref call-the-forward-method
@when("the generator's forward method is called", target_fixture="forward_output")
def _(generator, mocker, katamari):
    katamari.noise = mocker.Mock()
    katamari.expected = mocker.Mock()
    generator.network.return_value = katamari.expected
    katamari.output = generator.forward(katamari.noise)
    return katamari
#+end_src

*** Check the Network Was Called

#+begin_src python :noweb-ref check-the-networks-call
@then("it passes the input to its network")
def _(generator, forward_output, mocker):
    expect(generator.network.call_args).to(equal(
        mocker.call(forward_output.noise)))
    return
#+end_src

*** Check the Returned Output

#+begin_src python :noweb-ref check-the-returned-output
@And("it returns the output of the network")
def _(forward_output):
    expect(forward_output.output).to(be(forward_output.expected))
    return
#+end_src
* Links

- Expects — Expects 0.9.0 documentation [Internet]. [cited 2023 Jul 5]. Available from: https://expects.readthedocs.io/en/stable/
  
- PyTorch Forums [Internet]. 2019 [cited 2023 Jul 5]. Guidelines for when and why one should set inplace = True? Available from: https://discuss.pytorch.org/t/guidelines-for-when-and-why-one-should-set-inplace-true/50923
  
- Autograd mechanics — PyTorch master documentation [Internet]. [cited 2023 Jul 5]. Available from: https://pytorch.org/docs/master/notes/autograd.html#in-place-operations-with-autograd

- Linear — PyTorch 2.0 documentation [Internet]. [cited 2023 Jul 10]. Available from: https://pytorch.org/docs/stable/generated/torch.nn.Linear.html

- Module — PyTorch 2.0 documentation [Internet]. [cited 2023 Jul 8]. Available from: https://pytorch.org/docs/stable/generated/torch.nn.Module.html

- ReLU — PyTorch 2.0 documentation [Internet]. [cited 2023 Jul 22]. Available from: https://pytorch.org/docs/stable/generated/torch.nn.ReLU.html
  
- Sequential — PyTorch 2.0 documentation [Internet]. [cited 2023 Jul 8]. Available from: https://pytorch.org/docs/stable/generated/torch.nn.Sequential.html?highlight=sequential#torch.nn.Sequential

- torch.sigmoid — PyTorch 2.0 documentation [Internet]. [cited 2023 Jul 22]. Available from: https://pytorch.org/docs/stable/generated/torch.sigmoid.html
