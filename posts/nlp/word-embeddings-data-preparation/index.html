<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="Data Preparation for word embeddings." name="description">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Word Embeddings: Data Preparation | Neurotic Networking</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="../../../rss.xml" hreflang="en" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/Neurotic-Networking/posts/nlp/word-embeddings-data-preparation/" rel="canonical"><!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]-->
<link href="../../../apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="../../../favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="../../../favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="../../../site.webmanifest" rel="manifest">
<meta content="Cloistered Monkey" name="author">
<link href="../word-embeddings-with-the-cbow-model/" rel="prev" title="Word Embeddings with the CBOW Model" type="text/html">
<link href="../introducing-the-cbow-model/" rel="next" title="Introducing the CBOW Model" type="text/html">
<meta content="Neurotic Networking" property="og:site_name">
<meta content="Word Embeddings: Data Preparation" property="og:title">
<meta content="https://necromuralist.github.io/Neurotic-Networking/posts/nlp/word-embeddings-data-preparation/" property="og:url">
<meta content="Data Preparation for word embeddings." property="og:description">
<meta content="article" property="og:type">
<meta content="2020-12-08T18:29:17-08:00" property="article:published_time">
<meta content="data preparation" property="article:tag">
<meta content="nlp" property="article:tag">
<meta content="word embeddings" property="article:tag">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="../../../"><span id="blog-title">Neurotic Networking</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../../archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="../../../categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="../../../rss.xml">RSS feed</a></li>
<li class="nav-item"><a class="nav-link" href="https://necromuralist.github.io/">Cloistered Monkey</a></li>
</ul>
<!-- Google custom search -->
<form action="https://www.google.com/search" class="navbar-form navbar-right" method="get" role="search">
<div class="form-group"><input class="form-control" name="q" placeholder="Search" type="text"></div>
<!-- 
<button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
</button>
-->
<input name="sitesearch" type="hidden" value="https://necromuralist.github.io/Neurotic-Networking/"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right">
<li class="nav-item"><a class="nav-link" href="index.org" id="sourcelink">Source</a></li>
</ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title" itemprop="headline name"><a class="u-url" href=".">Word Embeddings: Data Preparation</a></h1>
<div class="metadata">
<p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2020-12-08T18:29:17-08:00" itemprop="datePublished" title="2020-12-08 18:29">2020-12-08 18:29</time></a></p>
<p class="sourceline"><a class="sourcelink" href="index.org">Source</a></p>
</div>
</header>
<div class="e-content entry-content" itemprop="articleBody text">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgde2334c">Data Preparation</a>
<ul>
<li><a href="#org9ef8e24">Python Imports</a></li>
<li><a href="#orge7e0b10">PyPi Imports</a></li>
</ul>
</li>
<li><a href="#org6b8475c">And Now the Processing</a>
<ul>
<li><a href="#orgb2545c0">Our Corpus</a></li>
<li><a href="#orgf67d8fe">Cleaning and Tokenization</a>
<ul>
<li><a href="#orge7afee7">Punctuation</a></li>
</ul>
</li>
<li><a href="#orgc149a6c">Tokenize</a></li>
<li><a href="#org93e745c">Lower-Case And More Cleaning</a></li>
<li><a href="#org7ef1d85">Wrap It Together</a></li>
<li><a href="#orga93b500">Sliding Window of Words</a></li>
<li><a href="#org3c0a201">Words To Vectors</a>
<ul>
<li><a href="#org7a2bbf2">Mapping words to indices and indices to words</a></li>
<li><a href="#orgadd9b31">One-Hot Word Vectors</a></li>
<li><a href="#org30fcd99">Context Word Vectors</a></li>
</ul>
</li>
<li><a href="#org5e59547">Building the training set</a></li>
</ul>
</li>
<li><a href="#orgd8108c5">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgde2334c">
<h2 id="orgde2334c">Data Preparation</h2>
<div class="outline-text-2" id="text-orgde2334c">
<p>This is a look at the types of things we're going to need to do in order to convert our twitter data into a form that we can use for machine learning.</p>
</div>
<div class="outline-3" id="outline-container-org9ef8e24">
<h3 id="org9ef8e24">Python Imports</h3>
<div class="outline-text-3" id="text-org9ef8e24">
<p>This is pretty standard stuff. Only the <a href="https://docs.python.org/3/library/re.html#module-re">re</a> module for regular expressions is, strictly speaking, needed here.</p>
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">re</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orge7e0b10">
<h3 id="orge7e0b10">PyPi Imports</h3>
<div class="outline-text-3" id="text-orge7e0b10">
<p>These are libraries installed via the Python Package Index (<a href="https://pypi.org/">pypi</a>).</p>
<ul class="org-ul">
<li><a href="https://github.com/carpedm20/emoji">emoji</a>: Convert emoji to text aliases and vice-versa</li>
<li><a href="https://www.nltk.org/">nltk</a>: The Natural Language Toolkit</li>
<li><a href="https://numpy.org/">numpy</a>: We'll use it for their arrays.</li>
</ul>
<div class="highlight">
<pre><span></span><span class="kn">import</span> <span class="nn">emoji</span>
<span class="kn">import</span> <span class="nn">nltk</span>
<span class="kn">import</span> <span class="nn">numpy</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org6b8475c">
<h2 id="org6b8475c">And Now the Processing</h2>
<div class="outline-text-2" id="text-org6b8475c">
<p>The basic problem we have is that our data is made up of tweets (strings) with emojis, punctuation, and so on but we need to convert it to something numeric. The first step in that process is to standardize the strings and break them up into tokens.</p>
</div>
<div class="outline-3" id="outline-container-orgb2545c0">
<h3 id="orgb2545c0">Our Corpus</h3>
<div class="outline-text-3" id="text-orgb2545c0">
<p>Here's a fake tweet that we can use to work our way through the steps.</p>
<div class="highlight">
<pre><span></span><span class="n">corpus</span> <span class="o">=</span> <span class="n">emoji</span><span class="o">.</span><span class="n">emojize</span><span class="p">((</span>
    <span class="s2">"My :ogre: :red_heart: :moyai:, but "</span>
    <span class="s2">"my :goblin: must :poop:! Ho, :zany_face:. Human-animals $??"</span><span class="p">),</span>
                       <span class="n">use_aliases</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
</pre></div>
<p>My üëπ ‚ù§ üóø, but my üë∫ must üí©! Ho, ü§™. Human-animals $??</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgf67d8fe">
<h3 id="orgf67d8fe">Cleaning and Tokenization</h3>
<div class="outline-text-3" id="text-orgf67d8fe"></div>
<div class="outline-4" id="outline-container-orge7afee7">
<h4 id="orge7afee7">Punctuation</h4>
<div class="outline-text-4" id="text-orge7afee7">
<p>The first thing we're going to do is replace the punctuation with periods (<code>.</code>) using <a href="https://docs.python.org/3/library/re.html#re.sub">re.sub</a> .</p>
<div class="highlight">
<pre><span></span><span class="n">ONE_OR_MORE</span> <span class="o">=</span> <span class="s2">"+"</span>
<span class="n">PERIOD</span> <span class="o">=</span> <span class="s2">"."</span>
<span class="n">PUNCTUATION</span> <span class="o">=</span> <span class="s2">",!?;-"</span>
<span class="n">EXPRESSION</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="n">PUNCTUATION</span><span class="si">}</span><span class="s2">]"</span> <span class="o">+</span> <span class="n">ONE_OR_MORE</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">EXPRESSION</span><span class="p">,</span> <span class="n">PERIOD</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"First cleaning:  '</span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>
</pre></div>
<p>First cleaning: 'My üëπ ‚ù§ üóø. but my üë∫ must üí©. Ho. ü§™. Human.animals $.'</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgc149a6c">
<h3 id="orgc149a6c">Tokenize</h3>
<div class="outline-text-3" id="text-orgc149a6c">
<p>Next, use NLTK's <a href="https://www.nltk.org/api/nltk.tokenize.html#nltk.tokenize.punkt.PunktLanguageVars.word_tokenize">punkt word_tokenize</a> to break our corpus into tokens. <i>punkt</i> is German for "period" and is the name of a system created by Tibor Kiss and Jan Strunk. There's a link to the original paper ("Unsupervised Multilingual Sentence Boundary Detection") <a href="https://direct.mit.edu/coli/article/32/4/485/1923/Unsupervised-Multilingual-Sentence-Boundary">on this page</a>.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - Before: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - After tokenization:  </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>Before: My üëπ ‚ù§ üóø. but my üë∫ must üí©. Ho. ü§™. Human.animals $.</li>
<li>After tokenization: ['My', 'üëπ', '‚ù§', 'üóø', '.', 'but', 'my', 'üë∫', 'must', 'üí©', '.', 'Ho', '.', 'ü§™', '.', 'Human.animals', '$', '.']</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org93e745c">
<h3 id="org93e745c">Lower-Case And More Cleaning</h3>
<div class="outline-text-3" id="text-org93e745c">
<p>Now we'll reduce the tokens a little more:</p>
<ul class="org-ul">
<li>lower-case everything</li>
<li>filter out everything but letters, periods, and emoji</li>
</ul>
<p>We're going to use <a href="https://github.com/carpedm20/emoji/blob/70e7ba12dfaf3449a5d445b1e7de4ae2c6245d19/emoji/core.py#L112">get_emoji_regexp</a> which returns a regular expression object that matches emojis. Since it returns a compiled python Regular Expression object we can call its <a href="https://docs.python.org/3/library/re.html#re.Pattern.search">search</a> method to see if the token matches an emoji.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - Before:  </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="n">emoji_expression</span> <span class="o">=</span> <span class="n">emoji</span><span class="o">.</span><span class="n">get_emoji_regexp</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">data</span>
         <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">token</span><span class="o">.</span><span class="n">isalpha</span><span class="p">(),</span>
                 <span class="n">token</span><span class="o">==</span> <span class="s1">'.'</span><span class="p">,</span>
                 <span class="n">emoji_expression</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">token</span><span class="p">)))</span>
       <span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - After:  </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>Before: ['My', 'üëπ', '‚ù§', 'üóø', '.', 'but', 'my', 'üë∫', 'must', 'üí©', '.', 'Ho', '.', 'ü§™', '.', 'Human.animals', '$', '.']</li>
<li>After: ['my', 'üëπ', '‚ù§', 'üóø', '.', 'but', 'my', 'üë∫', 'must', 'üí©', '.', 'ho', '.', 'ü§™', '.', '.']</li>
</ul>
<p>One thing to notice is that it got rid of <i>Human.animals</i> so because of the way we're doing it, any hyphenated words are going to be eliminated.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org7ef1d85">
<h3 id="org7ef1d85">Wrap It Together</h3>
<div class="outline-text-3" id="text-org7ef1d85">
<p>While the steps were useful for illustrating things, it'll be more convenient to put it into a function for later.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="n">corpus</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""clean and tokenize the corpus</span>

<span class="sd">    Args:</span>
<span class="sd">     corpus: original source text</span>

<span class="sd">    Returns:</span>
<span class="sd">     list of cleaned tokens from the corpus</span>
<span class="sd">    """</span>
    <span class="n">ONE_OR_MORE</span> <span class="o">=</span> <span class="s2">"+"</span>
    <span class="n">PUNCTUATION</span> <span class="o">=</span> <span class="s2">",!?;-"</span>
    <span class="n">EXPRESSION</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">"[</span><span class="si">{</span><span class="n">PUNCTUATION</span><span class="si">}</span><span class="s2">]"</span> <span class="o">+</span> <span class="n">ONE_OR_MORE</span>
    <span class="n">PERIOD</span> <span class="o">=</span> <span class="s2">"."</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">EXPRESSION</span><span class="p">,</span> <span class="n">PERIOD</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span>
    <span class="n">expression</span> <span class="o">=</span> <span class="n">emoji</span><span class="o">.</span><span class="n">get_emoji_regexp</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="n">token</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">data</span>
             <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">token</span><span class="o">.</span><span class="n">isalpha</span><span class="p">(),</span>
                     <span class="n">token</span><span class="o">==</span> <span class="s1">'.'</span><span class="p">,</span>
                     <span class="n">expression</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">token</span><span class="p">)))</span>
       <span class="p">]</span>    
    <span class="k">return</span> <span class="n">data</span>
</pre></div>
<p>Now we can test it out.</p>
<div class="highlight">
<pre><span></span><span class="n">corpus</span> <span class="o">=</span> <span class="n">emoji</span><span class="o">.</span><span class="n">emojize</span><span class="p">(</span>
    <span class="p">(</span><span class="s2">"Able was :clown_face:; ere :clown_face: saw :frog_face:! "</span>
    <span class="s2">"Rejoice! :cigarette: for $9?"</span><span class="p">),</span> <span class="n">use_aliases</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Print new corpus</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - Corpus:  </span><span class="si">{</span><span class="n">corpus</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># Save tokenized version of corpus into 'words' variable</span>
<span class="n">words</span> <span class="o">=</span> <span class="n">tokenize</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>

<span class="c1"># Print the tokenized version of the corpus</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - Words (tokens):  </span><span class="si">{</span><span class="n">words</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>Corpus: Able was ü§°; ere ü§° saw :frog_face:! Rejoice! üö¨ for $9?</li>
<li>Words (tokens): ['able', 'was', 'ü§°', '.', 'ere', 'ü§°', 'saw', '.', 'rejoice', '.', 'üö¨', 'for', '.']</li>
</ul>
<p>Check with an alternative sentence.</p>
<div class="highlight">
<pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="n">emoji</span><span class="o">.</span><span class="n">emojize</span><span class="p">(</span>
    <span class="p">(</span><span class="s2">"I'm tired of being a token! Where's all the other "</span>
     <span class="s2">":cheese_wedge:-sniffing"</span>
     <span class="s2">" Gnomish at? I bet theres' at least 2 of us :gorilla: "</span>
     <span class="s2">"out there, or maybe more..."</span><span class="p">),</span>
    <span class="n">use_aliases</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - Before: </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - After: </span><span class="si">{</span><span class="n">tokenize</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>Before: I'm tired of being a token! Where's all the other üßÄ-sniffing Gnomish at? I bet theres' at least 2 of us ü¶ç out there, or maybe more‚Ä¶</li>
<li>After: ['i', 'tired', 'of', 'being', 'a', 'token', '.', 'where', 'all', 'the', 'other', 'üßÄ.sniffing', 'gnomish', 'at', '.', 'i', 'bet', 'theres', 'at', 'least', 'of', 'us', 'ü¶ç', 'out', 'there', '.', 'or', 'maybe', 'more']</li>
</ul>
<p>Interestingly, it removes "am" (in the contraction "I'm") but not "a", I guess because it's language neutral it can't understand the contractions the way some english-specific tokenizers can.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orga93b500">
<h3 id="orga93b500">Sliding Window of Words</h3>
<div class="outline-text-3" id="text-orga93b500">
<p>The idea behind word-embeddings is that we assume that the words around a word (the context) are what give us the meaning of the word so we create vectors whose distance to other vectors with similar contexts is closer than to those with more different contexts. So our data is made up of list of words around a word. If for example our sentence is:</p>
<blockquote>
<p>Fruit flies like a banana.</p>
</blockquote>
<p>And we get the context for the word "like" with a half-window (number of tokens on either side of the word) of 2, then our window will be:</p>
<pre class="example" id="orge5b87da">
["fruit", "flies", "a", "banana"]
</pre>
<div class="highlight">
<pre><span></span><span class="n">GetWindowYield</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_windows</span><span class="p">(</span><span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                <span class="n">half_window</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">GetWindowYield</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">"""Generates windows of words</span>

<span class="sd">    Args:</span>
<span class="sd">     words: cleaned tokens</span>
<span class="sd">     half_window: number of words in the half-window</span>

<span class="sd">    Yields:</span>
<span class="sd">     the next window</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">center_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">half_window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span> <span class="o">-</span> <span class="n">half_window</span><span class="p">):</span>
        <span class="n">center_word</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">center_index</span><span class="p">]</span>
        <span class="n">context_words</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span><span class="p">[(</span><span class="n">center_index</span> <span class="o">-</span> <span class="n">half_window</span><span class="p">)</span> <span class="p">:</span> <span class="n">center_index</span><span class="p">]</span>
                         <span class="o">+</span> <span class="n">words</span><span class="p">[(</span><span class="n">center_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):(</span><span class="n">center_index</span> <span class="o">+</span> <span class="n">half_window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="k">yield</span> <span class="n">context_words</span><span class="p">,</span> <span class="n">center_word</span>
    <span class="k">return</span>
</pre></div>
<p>The first argument of this function, <code>words</code>, is a list of words (or tokens). The second argument, <code>half_window</code>, is the context half-size. As I mentioned, for a given center word, the context words are made of <code>half_window</code> words to the left and <code>half_window</code> words to the right of the center word.</p>
<p>Now let's try it on the <code>words</code> we defined earlier using a window of 2.</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">get_windows</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>['able', 'was', '.', 'ere'] ü§°</li>
<li>['was', 'ü§°', 'ere', 'ü§°'] .</li>
<li>['ü§°', '.', 'ü§°', 'saw'] ere</li>
<li>['.', 'ere', 'saw', '.'] ü§°</li>
<li>['ere', 'ü§°', '.', 'rejoice'] saw</li>
<li>['ü§°', 'saw', 'rejoice', '.'] .</li>
<li>['saw', '.', '.', 'üö¨'] rejoice</li>
<li>['.', 'rejoice', 'üö¨', 'for'] .</li>
<li>['rejoice', '.', 'for', '.'] üö¨</li>
</ul>
<p>The first example is made up of:</p>
<ul class="org-ul">
<li>the context words "able", "was", ".", "ere",</li>
<li>and the center word to be predicted is a clown-face.</li>
</ul>
<p>Once more with feeling.</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">context</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">get_windows</span><span class="p">(</span><span class="n">tokenize</span><span class="p">(</span><span class="s2">"My baloney has a first name, it's Gerald."</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>['my', 'baloney', 'a', 'first'] has</li>
<li>['baloney', 'has', 'first', 'name'] a</li>
<li>['has', 'a', 'name', '.'] first</li>
<li>['a', 'first', '.', 'it'] name</li>
<li>['first', 'name', 'it', 'gerald'] .</li>
<li>['name', '.', 'gerald', '.'] it</li>
</ul>
<p>It's a little more obvious now that the way we wrote it the last two tokens (<code>Gerald</code> and <code>.</code>) don't get a context, so if we wanted to make sure that we did we'd probably have to pad the tokens or figure out some other scheme.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org3c0a201">
<h3 id="org3c0a201">Words To Vectors</h3>
<div class="outline-text-3" id="text-org3c0a201">
<p>The next step is to convert the words to vectors using the contexts and words.</p>
</div>
<div class="outline-4" id="outline-container-org7a2bbf2">
<h4 id="org7a2bbf2">Mapping words to indices and indices to words</h4>
<div class="outline-text-4" id="text-org7a2bbf2">
<p>The center words will be represented as <a href="https://www.wikiwand.com/en/One-hot#/Natural_language_processing">one-hot vectors</a> (vectors of all zeros except in the cell representing the word), and the vectors that represent context words are also based on one-hot vectors.</p>
<p>To create one-hot word vectors, we can start by mapping each unique word to a unique integer (or index). We'll start with a function named <code>get_dict</code>, that creates a Python dictionary that maps words to integers and back.</p>
<div class="highlight">
<pre><span></span><span class="n">WordToIndex</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">IndexToWord</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">GetDictOutput</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">WordToIndex</span><span class="p">,</span> <span class="n">IndexToWord</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_dict</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">GetDictOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Creates index to word mappings</span>

<span class="sd">    The index is based on the sorted unique tokens in the data</span>

<span class="sd">    Args:</span>
<span class="sd">     data: the data you want to pull from</span>

<span class="sd">    Returns:</span>
<span class="sd">     word_to_index: returns dictionary mapping the word to its index</span>
<span class="sd">     index_to_word: returns dictionary mapping the index to its word</span>
<span class="sd">    """</span>
    <span class="n">words</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>

    <span class="n">word_to_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">word</span><span class="p">:</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">words</span><span class="p">)}</span>
    <span class="n">index_to_word</span> <span class="o">=</span> <span class="p">{</span><span class="n">index</span><span class="p">:</span> <span class="n">word</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">words</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">word_to_index</span><span class="p">,</span> <span class="n">index_to_word</span>
</pre></div>
<p>So, let's try it out with the corpus.</p>
<div class="highlight">
<pre><span></span><span class="n">word_to_index</span><span class="p">,</span> <span class="n">index_to_word</span> <span class="o">=</span> <span class="n">get_dict</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - </span><span class="si">{</span><span class="n">word_to_index</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - </span><span class="si">{</span><span class="n">index_to_word</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
- {'.': 0, 'able': 1, 'ere': 2, 'for': 3, 'rejoice': 4, 'saw': 5, 'was': 6, 'üö¨': 7, 'ü§°': 8}
- {0: '.', 1: 'able', 2: 'ere', 3: 'for', 4: 'rejoice', 5: 'saw', 6: 'was', 7: 'üö¨', 8: 'ü§°'}
</pre>
<p>If it isn't obvious, the purpose of the <code>word_to_index</code> dictionary is to convert a word to an integer.</p>
<div class="highlight">
<pre><span></span><span class="n">token</span> <span class="o">=</span> <span class="s2">"ere"</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Index of the word '</span><span class="si">{</span><span class="n">token</span><span class="si">}</span><span class="s2">':  </span><span class="si">{</span><span class="n">word_to_index</span><span class="p">[</span><span class="n">token</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Index of the word 'ere':  2
</pre>
<p>And now in the other direction.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Word which has index 2:  '</span><span class="si">{</span><span class="n">index_to_word</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">'"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Word which has index 2:  'ere'
</pre>
<p>Finally, we need to know how many unique tokens are in our data set. The unique tokens make up our "vocabulary".</p>
<div class="highlight">
<pre><span></span><span class="n">vocabulary_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_to_index</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Size of vocabulary: </span><span class="si">{</span><span class="n">vocabulary_size</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Size of vocabulary: 9
</pre></div>
</div>
<div class="outline-4" id="outline-container-orgadd9b31">
<h4 id="orgadd9b31">One-Hot Word Vectors</h4>
<div class="outline-text-4" id="text-orgadd9b31">
<p>Now let's look at creating one-hot vectors for the words. We'll start with one word - "rejoice".</p>
<div class="highlight">
<pre><span></span><span class="n">word</span> <span class="o">=</span> <span class="s2">"rejoice"</span>
<span class="n">word_index</span> <span class="o">=</span> <span class="n">word_to_index</span><span class="p">[</span><span class="n">word</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Index for '</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">': </span><span class="si">{</span><span class="n">word_index</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Index for 'rejoice': 4
</pre>
<p>Now we'll create a vector that has as many cells as there are tokens in the vocabulary and populate it with zeros (using <a href="https://numpy.org/doc/stable/reference/generated/numpy.zeros.html">numpy.zeros</a>). This is why we needed the vocabulary size.</p>
<div class="highlight">
<pre><span></span><span class="n">center_word_vector</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vocabulary_size</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">center_word_vector</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">center_word_vector</span><span class="p">)</span> <span class="o">==</span> <span class="n">vocabulary_size</span>
<span class="k">assert</span> <span class="n">center_word_vector</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span>
</pre></div>
<pre class="example">
[0. 0. 0. 0. 0. 0. 0. 0. 0.]
</pre>
<p>Now, to make the vector represent out word, we need to set the cell that represents the word to 1.</p>
<div class="highlight">
<pre><span></span><span class="n">center_word_vector</span><span class="p">[</span><span class="n">word_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
<p>And now we have our one-hot word vector.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">center_word_vector</span><span class="p">)</span>

<span class="n">the_ones</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">center_word_vector</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">the_ones</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">index_to_word</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
[0. 0. 0. 0. 1. 0. 0. 0. 0.]
rejoice
</pre>
<p>So, like before, let's put everything into a function.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">word_to_one_hot_vector</span><span class="p">(</span><span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">word_to_index</span><span class="p">:</span> <span class="n">WordToIndex</span><span class="o">=</span><span class="n">word_to_index</span><span class="p">,</span>
                           <span class="n">vocabulary_size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="n">vocabulary_size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Create a one-hot-vector with a 1 where the word is</span>


<span class="sd">    Args:</span>
<span class="sd">     word: known token to add to the vector</span>
<span class="sd">     word_to_index: dict mapping word: index</span>
<span class="sd">     vocabulary_size: how long to make the vector</span>

<span class="sd">    Returns:</span>
<span class="sd">     vector with zeros everywhere except where the word is</span>
<span class="sd">    """</span>
    <span class="n">one_hot_vector</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vocabulary_size</span><span class="p">)</span>
    <span class="n">one_hot_vector</span><span class="p">[</span><span class="n">word_to_index</span><span class="p">[</span><span class="n">word</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">one_hot_vector</span>
</pre></div>
<p>Now we can check that it worked out.</p>
<div class="highlight">
<pre><span></span><span class="n">actual</span> <span class="o">=</span> <span class="n">word_to_one_hot_vector</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">actual</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">actual</span> <span class="o">==</span> <span class="n">center_word_vector</span><span class="p">)</span>
</pre></div>
<pre class="example">
[0. 0. 0. 0. 1. 0. 0. 0. 0.]
</pre></div>
</div>
<div class="outline-4" id="outline-container-org30fcd99">
<h4 id="org30fcd99">Context Word Vectors</h4>
<div class="outline-text-4" id="text-org30fcd99">
<p>So, now we come to the context words. It may not be quite as obvious what this is, since we said we're going to use one-hot vectors, but each context is made up of multiple words. What we'll do is calculate the average of the one-hot vectors representing the individual words.</p>
<p>As an illustration let's start with one set of context words.</p>
<div class="highlight">
<pre><span></span><span class="n">contexts</span> <span class="o">=</span> <span class="n">get_windows</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">context_words</span><span class="p">,</span> <span class="n">word</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">contexts</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - Word: </span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">" - Context: </span><span class="si">{</span><span class="n">context_words</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<ul class="org-ul">
<li>Word: ü§°</li>
<li>Context: ['able', 'was', '.', 'ere']</li>
</ul>
<p>To create the one-hot vector we're going to create a list of all the vectors for the words in the context.</p>
<div class="highlight">
<pre><span></span><span class="n">context_words_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">word_to_one_hot_vector</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">context_words</span><span class="p">]</span>
<span class="n">pprint</span><span class="p">(</span><span class="n">context_words_vectors</span><span class="p">)</span>
</pre></div>
<pre class="example">
[array([0., 1., 0., 0., 0., 0., 0., 0., 0.]),
 array([0., 0., 0., 0., 0., 0., 1., 0., 0.]),
 array([1., 0., 0., 0., 0., 0., 0., 0., 0.]),
 array([0., 0., 1., 0., 0., 0., 0., 0., 0.])]
</pre>
<p>And now we can get the average of these vectors using numpy's <a href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html">mean</a> function, to get the vector representation of the context words.</p>
<div class="highlight">
<pre><span></span><span class="n">ROWS</span><span class="p">,</span> <span class="n">COLUMNS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">first</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">context_words_vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ROWS</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
</pre></div>
<pre class="example">
[0.25 0.25 0.25 0.   0.   0.   0.25 0.   0.  ]
</pre>
<p>Once again, let's wrap those separate code blocks back into a single function.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">context_words_to_vector</span><span class="p">(</span><span class="n">context_words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                            <span class="n">word_to_index</span><span class="p">:</span> <span class="n">WordToIndex</span><span class="o">=</span><span class="n">word_to_index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Create vector with the mean of the one-hot-vectors</span>

<span class="sd">    Args:</span>
<span class="sd">     context_words: words to covert to one-hot vectors</span>
<span class="sd">     word_to_index: dict mapping word to index</span>

<span class="sd">    Returns:</span>
<span class="sd">     array with the mean of the one-hot vectors for the context_words</span>
<span class="sd">    """</span>
    <span class="n">vocabulary_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_to_index</span><span class="p">)</span>
    <span class="n">context_words_vectors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">word_to_one_hot_vector</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">word_to_index</span><span class="p">,</span> <span class="n">vocabulary_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">context_words</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">context_words_vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ROWS</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">second</span> <span class="o">=</span> <span class="n">context_words_to_vector</span><span class="p">(</span><span class="n">context_words</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">second</span><span class="p">)</span>
<span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">first</span><span class="o">==</span><span class="n">second</span><span class="p">)</span>
</pre></div>
<pre class="example">
[0.25 0.25 0.25 0.   0.   0.   0.25 0.   0.  ]
</pre>
<p>So, there you go. It isn't really a one-hot vector but is just based on one.</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org5e59547">
<h3 id="org5e59547">Building the training set</h3>
<div class="outline-text-3" id="text-org5e59547">
<p>Now we can put them all together and create a training data set for a Continuous Bag of Words model.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
</pre></div>
<pre class="example">
['able', 'was', 'ü§°', '.', 'ere', 'ü§°', 'saw', '.', 'rejoice', '.', 'üö¨', 'for', '.']
</pre>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">context_words</span><span class="p">,</span> <span class="n">center_word</span> <span class="ow">in</span> <span class="n">get_windows</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">half_window</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Context words:  </span><span class="si">{</span><span class="n">context_words</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">context_words_to_vector</span><span class="p">(</span><span class="n">context_words</span><span class="p">)</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Center word:  </span><span class="si">{</span><span class="n">center_word</span><span class="si">}</span><span class="s2"> -&gt; "</span>
          <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">word_to_one_hot_vector</span><span class="p">(</span><span class="n">center_word</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
<pre class="example" id="org459a866">
Context words:  ['able', 'was', '.', 'ere'] -&gt; [0.25 0.25 0.25 0.   0.   0.   0.25 0.   0.  ]
Center word:  ü§° -&gt; [0. 0. 0. 0. 0. 0. 0. 0. 1.]

Context words:  ['was', 'ü§°', 'ere', 'ü§°'] -&gt; [0.   0.   0.25 0.   0.   0.   0.25 0.   0.5 ]
Center word:  . -&gt; [1. 0. 0. 0. 0. 0. 0. 0. 0.]

Context words:  ['ü§°', '.', 'ü§°', 'saw'] -&gt; [0.25 0.   0.   0.   0.   0.25 0.   0.   0.5 ]
Center word:  ere -&gt; [0. 0. 1. 0. 0. 0. 0. 0. 0.]

Context words:  ['.', 'ere', 'saw', '.'] -&gt; [0.5  0.   0.25 0.   0.   0.25 0.   0.   0.  ]
Center word:  ü§° -&gt; [0. 0. 0. 0. 0. 0. 0. 0. 1.]

Context words:  ['ere', 'ü§°', '.', 'rejoice'] -&gt; [0.25 0.   0.25 0.   0.25 0.   0.   0.   0.25]
Center word:  saw -&gt; [0. 0. 0. 0. 0. 1. 0. 0. 0.]

Context words:  ['ü§°', 'saw', 'rejoice', '.'] -&gt; [0.25 0.   0.   0.   0.25 0.25 0.   0.   0.25]
Center word:  . -&gt; [1. 0. 0. 0. 0. 0. 0. 0. 0.]

Context words:  ['saw', '.', '.', 'üö¨'] -&gt; [0.5  0.   0.   0.   0.   0.25 0.   0.25 0.  ]
Center word:  rejoice -&gt; [0. 0. 0. 0. 1. 0. 0. 0. 0.]

Context words:  ['.', 'rejoice', 'üö¨', 'for'] -&gt; [0.25 0.   0.   0.25 0.25 0.   0.   0.25 0.  ]
Center word:  . -&gt; [1. 0. 0. 0. 0. 0. 0. 0. 0.]

Context words:  ['rejoice', '.', 'for', '.'] -&gt; [0.5  0.   0.   0.25 0.25 0.   0.   0.   0.  ]
Center word:  üö¨ -&gt; [0. 0. 0. 0. 0. 0. 0. 1. 0.]
</pre>
<p>Next we'll create a generator that yields the context-vectors.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">get_training_example</span><span class="p">(</span>
        <span class="n">words</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">half_window</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">word_to_index</span><span class="p">:</span> <span class="n">WordToIndex</span><span class="o">=</span><span class="n">word_to_index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                               <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">"""generates training examples</span>

<span class="sd">    Args:</span>
<span class="sd">     words: source of words</span>
<span class="sd">     half_window: half the window size</span>
<span class="sd">     word_to_index: dict with word to index mapping</span>

<span class="sd">    Yields:</span>
<span class="sd">     array with the mean of the one-hot vectors for the context words</span>
<span class="sd">    """</span>
    <span class="n">vocabulary_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word_to_index</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">context_words</span><span class="p">,</span> <span class="n">center_word</span> <span class="ow">in</span> <span class="n">get_windows</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">half_window</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">context_words_to_vector</span><span class="p">(</span><span class="n">context_words</span><span class="p">),</span> <span class="n">word_to_one_hot_vector</span><span class="p">(</span>
            <span class="n">center_word</span><span class="p">,</span> <span class="n">word_to_index</span><span class="p">,</span>
            <span class="n">vocabulary_size</span><span class="p">)</span>
    <span class="k">return</span>
</pre></div>
<p>The output of this function can be iterated on to get successive context word vectors and center word vectors, as demonstrated in the next cell.</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">context_words_vector</span><span class="p">,</span> <span class="n">center_word_vector</span> <span class="ow">in</span> <span class="n">get_training_example</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Context words vector:  </span><span class="si">{</span><span class="n">context_words_vector</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Center word vector:  </span><span class="si">{</span><span class="n">center_word_vector</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>
<pre class="example" id="orgc18bcba">
Context words vector:  [0.25 0.25 0.25 0.   0.   0.   0.25 0.   0.  ]
Center word vector:  [0. 0. 0. 0. 0. 0. 0. 0. 1.]

Context words vector:  [0.   0.   0.25 0.   0.   0.   0.25 0.   0.5 ]
Center word vector:  [1. 0. 0. 0. 0. 0. 0. 0. 0.]

Context words vector:  [0.25 0.   0.   0.   0.   0.25 0.   0.   0.5 ]
Center word vector:  [0. 0. 1. 0. 0. 0. 0. 0. 0.]

Context words vector:  [0.5  0.   0.25 0.   0.   0.25 0.   0.   0.  ]
Center word vector:  [0. 0. 0. 0. 0. 0. 0. 0. 1.]

Context words vector:  [0.25 0.   0.25 0.   0.25 0.   0.   0.   0.25]
Center word vector:  [0. 0. 0. 0. 0. 1. 0. 0. 0.]

Context words vector:  [0.25 0.   0.   0.   0.25 0.25 0.   0.   0.25]
Center word vector:  [1. 0. 0. 0. 0. 0. 0. 0. 0.]

Context words vector:  [0.5  0.   0.   0.   0.   0.25 0.   0.25 0.  ]
Center word vector:  [0. 0. 0. 0. 1. 0. 0. 0. 0.]

Context words vector:  [0.25 0.   0.   0.25 0.25 0.   0.   0.25 0.  ]
Center word vector:  [1. 0. 0. 0. 0. 0. 0. 0. 0.]

Context words vector:  [0.5  0.   0.   0.25 0.25 0.   0.   0.   0.  ]
Center word vector:  [0. 0. 0. 0. 0. 0. 0. 1. 0.]
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgd8108c5">
<h2 id="orgd8108c5">End</h2>
<div class="outline-text-2" id="text-orgd8108c5">
<p>Now that we know how to creat the training set, we can move on to the CBOW model itself which will be covered in the <a href="../introducing-the-cbow-model/">next post</a>. This is part of a series of posts looking at some preliminaries for creating word-embeddings. There is a table-of-contents post <a href="../word-embeddings-with-the-cbow-model/">here</a>.</p>
</div>
</div>
</div>
<aside class="postpromonav">
<nav>
<ul class="tags" itemprop="keywords">
<li><a class="tag p-category" href="../../../categories/data-preparation/" rel="tag">data preparation</a></li>
<li><a class="tag p-category" href="../../../categories/nlp/" rel="tag">nlp</a></li>
<li><a class="tag p-category" href="../../../categories/word-embeddings/" rel="tag">word embeddings</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous"><a href="../word-embeddings-with-the-cbow-model/" rel="prev" title="Word Embeddings with the CBOW Model">Previous post</a></li>
<li class="next"><a href="../introducing-the-cbow-model/" rel="next" title="Introducing the CBOW Model">Next post</a></li>
</ul>
</nav>
</aside>
</article>
<!--End of body content-->
<footer id="footer">Scribbles by <a href="mailto:cloisteredmonkey.jmark@slmail.me">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a>
<div id="license" xmlns:cc="http://creativecommons.org/ns#">This work is licensed under <a href="http://creativecommons.org/licenses/by/4.0/?ref=chooser-v1" rel="license noopener noreferrer" style="display:inline-block;" target="_blank">CC BY 4.0 <img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"></a></div>
</footer>
</div>
</div>
<script src="../../../assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
</script>
</body>
</html>
