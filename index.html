<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="Studies in Deep Learning." name="description">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>In Too Deep</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="rss.xml" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/In-Too-Deep/" rel="canonical">
<link href="index-9.html" rel="next" type="text/html"><!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
<link href="apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="site.webmanifest" rel="manifest">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script async src="javascript/bokeh-1.3.4.min.js" type="text/javascript"></script>
<link href="/posts/fastai/hand-rolling-a-countvectorizer/" rel="prefetch" type="text/html">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="https://necromuralist.github.io/In-Too-Deep/"><span id="blog-title">In Too Deep</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="/categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="/rss.xml">RSS feed</a></li>
<li class="nav-item active"><a class="nav-link" href="/">Cloistered Monkey <span class="sr-only">(active)</span></a></li>
</ul>
<!-- Google custom search -->
<form action="https://www.google.com/search" class="navbar-form navbar-right" method="get" role="search">
<div class="form-group"><input class="form-control" name="q" placeholder="Search" type="text"></div>
<!-- 
<button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
</button>
-->
<input name="sitesearch" type="hidden" value="https://necromuralist.github.io/In-Too-Deep/"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<div class="postindex">
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/fastai/hand-rolling-a-countvectorizer/">Hand-rolling a CountVectorizer</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/fastai/hand-rolling-a-countvectorizer/" rel="bookmark"><time class="published dt-published" datetime="2020-01-03T17:21:23-08:00" itemprop="datePublished" title="2020-01-03 17:21">2020-01-03 17:21</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org7aaa637">Beginning</a>
<ul>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#orga61f278">Imports</a>
<ul>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org0f9a8ec">Python</a></li>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#orgee179f7">PyPi</a></li>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org3247bf2">Others</a></li>
</ul>
</li>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org4426f1d">Setup</a>
<ul>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org638cd6c">Plotting</a></li>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org8b93ef7">The Data Set</a></li>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org4d4f3cd">The Text List</a></li>
</ul>
</li>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org086e2b4">Creating a Term-Document Matrix</a></li>
</ul>
</li>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org0532fb5">End</a>
<ul>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#orgc8bcdd7">Reference</a>
<ul>
<li><a href="/posts/fastai/hand-rolling-a-countvectorizer/#org66ad631">The Dataset</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org7aaa637">
<h2 id="org7aaa637">Beginning</h2>
<div class="outline-text-2" id="text-org7aaa637">
<p>This is part of lesson 3 from the <a href="https://github.com/fastai/course-nlp">fastai NLP course</a>.</p>
</div>
<div class="outline-3" id="outline-container-orga61f278">
<h3 id="orga61f278">Imports</h3>
<div class="outline-text-3" id="text-orga61f278"></div>
<div class="outline-4" id="outline-container-org0f9a8ec">
<h4 id="org0f9a8ec">Python</h4>
<div class="outline-text-4" id="text-org0f9a8ec">
<div class="highlight">
<pre><span></span>from collections import Counter
from functools import partial
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgee179f7">
<h4 id="orgee179f7">PyPi</h4>
<div class="outline-text-4" id="text-orgee179f7">
<div class="highlight">
<pre><span></span>from fastai.text import (
    URLs,
    untar_data,
    TextList,
    )
import hvplot.pandas
import pandas
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org3247bf2">
<h4 id="org3247bf2">Others</h4>
<div class="outline-text-4" id="text-org3247bf2">
<div class="highlight">
<pre><span></span>from graeae import CountPercentage, EmbedHoloviews
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org4426f1d">
<h3 id="org4426f1d">Setup</h3>
<div class="outline-text-3" id="text-org4426f1d"></div>
<div class="outline-4" id="outline-container-org638cd6c">
<h4 id="org638cd6c">Plotting</h4>
<div class="outline-text-4" id="text-org638cd6c">
<div class="highlight">
<pre><span></span>Embed = partial(
    EmbedHoloviews,
    folder_path="../../files/posts/fastai/hand-rolling-a-countvectorizer/")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org8b93ef7">
<h4 id="org8b93ef7">The Data Set</h4>
<div class="outline-text-4" id="text-org8b93ef7">
<p>The data-set is a collection of 50,000 IMDB reviews <a href="https://course.fast.ai/datasets.html">hosted on AWS Open Datasets</a> as part of the fastai datasets collection. We're going to try and create a classifier that can predict the "sentiment" of reviews. The <a href="http://ai.stanford.edu/~amaas/data/sentiment/">original dataset</a> comes from Stanford University.</p>
<p>To make it easier to experiment, we'll initially load a sub-set of the dataset that fastai prepared. The <a href="https://docs.fast.ai/datasets.html#URLs">URLs</a> class contains the URLs for the datasets that fastai has uploaded and the <a href="https://docs.fast.ai/datasets.html#untar_data"><code>untar_data</code></a> function downloads data from the URL given to a given (or in this case default) location.</p>
<div class="highlight">
<pre><span></span>path = untar_data(URLs.IMDB_SAMPLE)
print(path)
</pre></div>
<pre class="example">
/home/athena/.fastai/data/imdb_sample
</pre>
<p>The <code>untar_data</code> function doesn't actually load the data for us, so we'll use pandas to do that.</p>
<div class="highlight">
<pre><span></span>sample_frame = pandas.read_csv(path/"texts.csv")
print(sample_frame.head())
</pre></div>
<pre class="example">
      label                                               text  is_valid
0  negative  Un-bleeping-believable! Meg Ryan doesn't even ...     False
1  positive  This is a extremely well-made film. The acting...     False
2  negative  Every once in a long while a movie will come a...     False
3  positive  Name just says it all. I watched this movie wi...     False
4  negative  This movie succeeds at being one of the most u...     False
</pre>
<p>The <code>is_valid</code> column is kind of interesting here especially since the first examples are all false… but I couldn't find an explanation for it on the data-download page.</p>
<div class="highlight">
<pre><span></span>CountPercentage(sample.label)()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Value</th>
<th class="org-right" scope="col">Count</th>
<th class="org-right" scope="col">Percent (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">negative</td>
<td class="org-right">524</td>
<td class="org-right">52.40</td>
</tr>
<tr>
<td class="org-left">positive</td>
<td class="org-right">476</td>
<td class="org-right">47.60</td>
</tr>
</tbody>
</table>
<p>So it is nearly balanced but with a slight bias toward negative comments.</p>
<div class="highlight">
<pre><span></span>CountPercentage(sample.is_valid)()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Value</th>
<th class="org-right" scope="col">Count</th>
<th class="org-right" scope="col">Percent (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">False</td>
<td class="org-right">800</td>
<td class="org-right">80.00</td>
</tr>
<tr>
<td class="org-left">True</td>
<td class="org-right">200</td>
<td class="org-right">20.00</td>
</tr>
</tbody>
</table>
<p>Well, so exactly 20% are invalid? Curious.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org4d4f3cd">
<h4 id="org4d4f3cd">The Text List</h4>
<div class="outline-text-4" id="text-org4d4f3cd">
<p>To actually work with the dataset we'll use fastai's <a href="https://docs.fast.ai/text.data.html#The-TextList-input-classes">TextList</a> instead of pandas' dataframe.</p>
<div class="highlight">
<pre><span></span>sample_list = TextList.from_csv(path, "texts.csv", cols="text")
sample_split = sample_list.split_from_df(col=2)
sample = (sample_split
          .label_from_df(cols=0))
</pre></div>
<p>The original notebook builds the <code>TextList</code> in a single train-wreck, but if you try and find out what those methods do from the fastai documentation… well, good luck to you, it's easier (although still obscure) to inspect the intermediate objects to try and muddle through what's going on. The ultimate outcome seems to be that <code>sample</code> is an object with the somewhat pre-processed. It looks like the text is lower-cased and somewhat tokenized. There's also a lot of strange tokens inserted (<code>xxmaj</code>, <code>xxunk</code>) which, according to the <a href="https://docs.fast.ai/text.transform.html#Introduction">tokenization documentation</a> indicate special tokens - although there's more unknown tokens than I would have expected.</p>
<div class="highlight">
<pre><span></span>print(sample.train.x[0])
</pre></div>
<pre class="example">
xxbos xxmaj un - xxunk - believable ! xxmaj meg xxmaj ryan does n't even look her usual xxunk lovable self in this , which normally makes me forgive her shallow xxunk acting xxunk . xxmaj hard to believe she was the producer on this dog . xxmaj plus xxmaj kevin xxmaj kline : what kind of suicide trip has his career been on ? xxmaj xxunk ... xxmaj xxunk ! ! ! xxmaj finally this was directed by the guy who did xxmaj big xxmaj xxunk ? xxmaj must be a replay of xxmaj jonestown - hollywood style . xxmaj xxunk !
</pre>
<div class="highlight">
<pre><span></span>print(sample_frame.text.iloc[0])
</pre></div>
<pre class="example">
Un-bleeping-believable! Meg Ryan doesn't even look her usual pert lovable self in this, which normally makes me forgive her shallow ticky acting schtick. Hard to believe she was the producer on this dog. Plus Kevin Kline: what kind of suicide trip has his career been on? Whoosh... Banzai!!! Finally this was directed by the guy who did Big Chill? Must be a replay of Jonestown - hollywood style. Wooofff!
</pre>
<p>Here's the category fo that review.</p>
<div class="highlight">
<pre><span></span>print(sample.train.y[0])
</pre></div>
<pre class="example">
negative
</pre>
<p>Note that the output looks like a string, but it's actually a fastai "type".</p>
<div class="highlight">
<pre><span></span>print(type(sample.train.y[0]))
</pre></div>
<pre class="example">
&lt;class 'fastai.core.Category'&gt;
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org086e2b4">
<h3 id="org086e2b4">Creating a Term-Document Matrix</h3>
<div class="outline-text-3" id="text-org086e2b4">
<p>Here we'll create a matrix that counts the number of times each token appears in each document.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org0532fb5">
<h2 id="org0532fb5">End</h2>
<div class="outline-text-2" id="text-org0532fb5"></div>
<div class="outline-3" id="outline-container-orgc8bcdd7">
<h3 id="orgc8bcdd7">Reference</h3>
<div class="outline-text-3" id="text-orgc8bcdd7"></div>
<div class="outline-4" id="outline-container-org66ad631">
<h4 id="org66ad631">The Dataset</h4>
<div class="outline-text-4" id="text-org66ad631">
<ul class="org-ul">
<li>Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. 2011. Learning word vectors for sentiment analysis. In Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies - Volume 1 (HLT ’11). Association for Computational Linguistics, USA, 142–150</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/fastai/topic-modeling-with-matrix-decomposition/">Topic Modeling With Matrix Decomposition</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/" rel="bookmark"><time class="published dt-published" datetime="2019-12-28T17:11:58-08:00" itemprop="datePublished" title="2019-12-28 17:11">2019-12-28 17:11</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org1d6dfc5">Beginning</a>
<ul>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#orgabeb223">Related Tutorials</a></li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org4600693">Imports</a>
<ul>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org071f5ef">Python</a></li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org3d61d4f">PyPi</a></li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org9f4acb2">Others</a></li>
</ul>
</li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#orgbee7f69">Set Up</a>
<ul>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#orgf62df2a">The Timer</a></li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#orge1bdf9e">Plotting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org1a4d31d">Middle</a>
<ul>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org6cc96b2">The Dataset</a>
<ul>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org53811db">Vectorizing</a></li>
</ul>
</li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#orgbf2153c">Singular Value Decomposition (SVD)</a></li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org91d24db">Looking At Some Topics</a></li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#org121b4f1">Non-negative Matrix Factorization (NMF)</a></li>
<li><a href="/posts/fastai/topic-modeling-with-matrix-decomposition/#orgdc25eb5">Term-Frequency/Inverse Document Frequency</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org1d6dfc5">
<h2 id="org1d6dfc5">Beginning</h2>
<div class="outline-text-2" id="text-org1d6dfc5">
<p>This is part of a walk-through of the <a href="https://github.com/fastai/course-nlp">fastai Code-First Introduction to NLP</a>. In this post I'll be using <a href="https://www.wikiwand.com/en/Singular_value_decomposition">Singular Value Decomposition (SVD)</a> and <a href="https://www.wikiwand.com/en/Non-negative_matrix_factorization">Non-Negative Matrix Factorization (NMF)</a> to group <a href="https://scikit-learn.org/stable/datasets/index.html#newsgroups-dataset">newsgroup posts</a>. Both of these methods are statistical approaches that use the word-counts within documents to decide how similar they are (while ignoring things like word order).</p>
</div>
<div class="outline-3" id="outline-container-orgabeb223">
<h3 id="orgabeb223">Related Tutorials</h3>
<div class="outline-text-3" id="text-orgabeb223">
<ul class="org-ul">
<li><a href="http://scikit-learn.org/stable/auto_examples/applications/plot_out_of_core_classification.html">Out-Of-Core Text Classification with sklearn</a></li>
<li><a href="https://de.dariah.eu/tatom/index.html)">Text Analysis with Topic Models for the Humanities and Social Sciences</a></li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org4600693">
<h3 id="org4600693">Imports</h3>
<div class="outline-text-3" id="text-org4600693"></div>
<div class="outline-4" id="outline-container-org071f5ef">
<h4 id="org071f5ef">Python</h4>
<div class="outline-text-4" id="text-org071f5ef">
<div class="highlight">
<pre><span></span>from functools import partial
import random
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org3d61d4f">
<h4 id="org3d61d4f">PyPi</h4>
<div class="outline-text-4" id="text-org3d61d4f">
<div class="highlight">
<pre><span></span>from scipy import linalg
from sklearn import decomposition
from sklearn.datasets import fetch_20newsgroups
from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer
import hvplot.pandas
import matplotlib.pyplot as pyplot
import numpy
import pandas
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9f4acb2">
<h4 id="org9f4acb2">Others</h4>
<div class="outline-text-4" id="text-org9f4acb2">
<div class="highlight">
<pre><span></span>from graeae import EmbedHoloviews, Timer
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgbee7f69">
<h3 id="orgbee7f69">Set Up</h3>
<div class="outline-text-3" id="text-orgbee7f69"></div>
<div class="outline-4" id="outline-container-orgf62df2a">
<h4 id="orgf62df2a">The Timer</h4>
<div class="outline-text-4" id="text-orgf62df2a">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orge1bdf9e">
<h4 id="orge1bdf9e">Plotting</h4>
<div class="outline-text-4" id="text-orge1bdf9e">
<div class="highlight">
<pre><span></span>Embed = partial(
    EmbedHoloviews,
    folder_path="../../files/posts/fastai/topic-modeling-with-matrix-decomposition")
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org1a4d31d">
<h2 id="org1a4d31d">Middle</h2>
<div class="outline-text-2" id="text-org1a4d31d"></div>
<div class="outline-3" id="outline-container-org6cc96b2">
<h3 id="org6cc96b2">The Dataset</h3>
<div class="outline-text-3" id="text-org6cc96b2">
<p>The dataset consists of ~18,000 newsgroup posts with 20 topics. To keep the computation down I'll only use a subset of the categories. I'm also going to only use the body of the posts.</p>
<div class="highlight">
<pre><span></span>keep = ("alt.atheism", "comp.graphics", "misc.forsale", "sci.crypt", "talk.politics.guns")
remove = ("headers", "footers", "quotes")
training = fetch_20newsgroups(subset="train", categories=keep, remove=remove)
testing = fetch_20newsgroups(subset="test", categories=keep, remove=remove)
</pre></div>
<p>I've run this more than once so there's no output, but the first time you run the <code>fetch_20newsgroups</code> function it downloads the dataset and you'll see some output mentioning this fact.</p>
<div class="highlight">
<pre><span></span>print(f"{training.filenames.shape[0]:,}")
print(f"{training.target.shape[0]:,}")
</pre></div>
<pre class="example">
2,790
2,790
</pre>
<p>So, although the entire dataset has over 18,000 entries, our sub-set has fewer than 3,000.</p>
<div class="highlight">
<pre><span></span>print(numpy.unique(training.target))
</pre></div>
<pre class="example">
[0 1 2 3 4]
</pre>
<p>So the categories don't seem to be preserved (I'm assuming that the five I kept weren't the first five in the original set) so you have to check anytime you pull a subset out of the data.</p>
<p>Lets see what one of the posts looks like.</p>
<div class="highlight">
<pre><span></span>print(random.choice(training.data))
</pre></div>
<pre class="example">
      Just a question. 
      As a provider of a public BBS service - aren't you bound by law to gurantee
      intelligble access to the data of the users on the BBS, if police comes
      with sufficent authorisation ? I guessed this would be  a basic condition
      for such systems. (I did run a bbs some time ago, but that was in Switzerland)

The US doesn't yet have many laws covering BBSs - they're not common carriers,
they're not phone companies, they're just private machines or services
operated by businesses.  There's no obligation to keep records.
As Perry Metzger points out, if the police come with a search warrant,
you have to let them see what the warrant demands, if it exists,
and they generally can confiscate the equipment as "evidence"
(which is not Constitutionally valid, but we're only beginning to
develop court cases supporting us).  A court MAY be able to compel
you to tell them information you know, such as the encryption password
for the disk - there aren't any definitive cases yet, since it's a new
situation, and there probably aren't laws specifically covering it.
But the court can't force you to *know* the keys, and there are no
laws preventing you from allowing your users to have their own keys
for their own files without giving them to you.

Even in areas that do have established law, there is uncertainty.
There was a guy in Idaho a few years ago who had his business records
subpoenaed as evidence for taxes or some other business-restriction law,
so he gave the court the records.  Which were in Hebrew.
The US doesn't have laws forcing you to keep your records in English,
and these were the originals of the records.  HE didn't speak Hebrew,
and neither did anybody in the court organization.  Don't think they
were able to do much about it.

It might be illegal for your BBS to deny access to potential customers
based on race, religion, national origin, gender, or sexual preference;
it probably hasn't been tested in court, but it seems like a plausible
extension of anti-discrimination laws affecting other businesses.
</pre></div>
<div class="outline-4" id="outline-container-org53811db">
<h4 id="org53811db">Vectorizing</h4>
<div class="outline-text-4" id="text-org53811db">
<p>Here we'll convert the text to a matrix using <a href="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html">sklearn's CountVectorizer</a>. Interestingly, the <a href="https://nlp.stanford.edu/IR-book/html/htmledition/dropping-common-terms-stop-words-1.html">Introduction to Information Retrieval</a> book says the the trend has been towards not removing the most common words (<i>stop word</i>) but we'll be dropping them. There's a paper called <a href="https://www.aclweb.org/anthology/W18-2502/">Stop Word Lists in Free Open-source Software Packages</a> which points out some problems with stop-word lists in general, but sklearn's list in particular. I don't know if sklearn has done anything to address their concerns since the paper came out, but the sklearn documentation includes a link to the paper so I would assume the problems are still there. Nonetheless, the fastai examples uses them so I will too.</p>
<div class="highlight">
<pre><span></span>vectorizer = CountVectorizer(stop_words="english")
</pre></div>
<p>The function we'le going to use doesn't accept the sparse matrices that are output by default so we'll make it a dense matrix after it's fit.</p>
<div class="highlight">
<pre><span></span>with TIMER:
    vectors = vectorizer.fit_transform(training.data).todense()
</pre></div>
<pre class="example">
2020-01-01 16:26:48,048 graeae.timers.timer start: Started: 2020-01-01 16:26:48.047927
2020-01-01 16:26:48,466 graeae.timers.timer end: Ended: 2020-01-01 16:26:48.466285
2020-01-01 16:26:48,466 graeae.timers.timer end: Elapsed: 0:00:00.418358
</pre>
<p>That was much quicker than I thought it would be, probably because our dataset is so small.</p>
<div class="highlight">
<pre><span></span>vocabulary = vectorizer.get_feature_names()
print(f"{len(vocabulary):,}")
</pre></div>
<pre class="example">
34,632
</pre>
<p>So our "vocabulary" is around 35,000 tokens.</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgbf2153c">
<h3 id="orgbf2153c">Singular Value Decomposition (SVD)</h3>
<div class="outline-text-3" id="text-orgbf2153c">
<p>Singular Value Decomposition is a linear algebra method to factor a matrix. The math is beyond me at this point, so I'll just try using it as a black box.</p>
<div class="highlight">
<pre><span></span>with TIMER:
    U, s, V = linalg.svd(vectors, full_matrices=False)
</pre></div>
<pre class="example">
2020-01-01 16:26:50,508 graeae.timers.timer start: Started: 2020-01-01 16:26:50.508003
2020-01-01 16:27:23,979 graeae.timers.timer end: Ended: 2020-01-01 16:27:23.978988
2020-01-01 16:27:23,980 graeae.timers.timer end: Elapsed: 0:00:33.470985
</pre>
<div class="highlight">
<pre><span></span>s_frame = pandas.Series(s)
plot = s_frame.hvplot().opts(title="Diagonal Matrix S", width=1000, height=800)
Embed(plot=plot, file_name="s_values")()
</pre></div>
<object data="/posts/fastai/topic-modeling-with-matrix-decomposition/s_values.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object></div>
</div>
<div class="outline-3" id="outline-container-org91d24db">
<h3 id="org91d24db">Looking At Some Topics</h3>
<div class="outline-text-3" id="text-org91d24db">
<div class="highlight">
<pre><span></span>top_words_count = 8

def top_words(token):
    return [vocabulary[index] for index in numpy.argsort(token)[: -top_words_count - 1: -1]]

def show_topics(array):
    topic_words = ([top_words(topic) for topic in array])
    return [' '.join(topic) for topic in topic_words]
</pre></div>
<div class="highlight">
<pre><span></span>topics = show_topics(V[:10])
for index, topic in enumerate(topics):
    print(f"{index}: {topic}")
</pre></div>
<pre class="example">
0: propagandist heliocentric galacticentric surname sandvik 400included wovy imaginative
1: file jpeg image edu pub ftp use graphics
2: file gun congress firearms control mr states rkba
3: privacy internet anonymous pub email information eff mail
4: graphics edu 128 3d ray pub data ftp
5: 00 50 40 appears dos 10 art 25
6: privacy internet 00 jpeg eff pub email electronic
7: key data image encryption des chip available law
8: pub key jesus jpeg eff graphics encryption ripem
9: key encryption edu des anonymous posting chip graphics
</pre>
<p>So what we're showing is the most significant words for the top-ten most strongly grouped "topics". It takes a little bit of interpretation to figure out how to map them to the newsgroups we used, and there probably could have been some clean-up of the texts (entry 5 looks suspect) but it's interesting that this linear algebra decomposition method could find these similar groups without any kind of prompting as to what groups might even exist in the first place (this is an unsupervised method, not a supervised method).</p>
</div>
</div>
<div class="outline-3" id="outline-container-org121b4f1">
<h3 id="org121b4f1">Non-negative Matrix Factorization (NMF)</h3>
<div class="outline-text-3" id="text-org121b4f1">
<div class="highlight">
<pre><span></span>number_of_topics = 5
classifier = decomposition.NMF(n_components=number_of_topics, random_state=1)
weights = classifier.fit_transform(vectors)
classified = classifier.components_
for index, topic in enumerate(show_topics(classified)):
    print(f"{index}: {topic}")
</pre></div>
<pre class="example">
0: db mov bh si cs byte al bl
1: privacy internet anonymous information email eff use pub
2: file gun congress control firearms states mr united
3: jpeg image gif file color images format quality
4: edu graphics pub image data ftp mail available
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgdc25eb5">
<h3 id="orgdc25eb5">Term-Frequency/Inverse Document Frequency</h3>
<div class="outline-text-3" id="text-orgdc25eb5">
<div class="highlight">
<pre><span></span>tfidf_vectorizer = TfidfVectorizer(stop_words="english")
tfidf_vectors = tfidf_vectorizer.fit_transform(training.data)
weights = classifier.fit_transform(tfidf_vectors)
classified = classifier.components_

for index, topic in enumerate(show_topics(classified)):
    print(f"{index}: {topic}")
</pre></div>
<pre class="example">
0: people gun don think just guns right government
1: 00 sale offer shipping new drive price condition
2: key chip encryption clipper keys escrow government algorithm
3: graphics thanks file files image program know windows
4: god atheism believe does atheists belief said exist
</pre></div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/link-collection/">Link-Collection</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/link-collection/" rel="bookmark"><time class="published dt-published" datetime="2019-12-28T16:12:17-08:00" itemprop="datePublished" title="2019-12-28 16:12">2019-12-28 16:12</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/link-collection/#org41e629b">Machine Learning</a>
<ul>
<li><a href="/posts/link-collection/#org1cc43f3">Blogs</a></li>
</ul>
</li>
<li><a href="/posts/link-collection/#org654fd36">Visualization</a></li>
<li><a href="/posts/link-collection/#org3ca40ba">Natural Language Processing</a>
<ul>
<li><a href="/posts/link-collection/#org0206ee9">Books</a></li>
<li><a href="/posts/link-collection/#orgec8d0be">Blogs</a></li>
<li><a href="/posts/link-collection/#org70ff7fa">Code</a>
<ul>
<li><a href="/posts/link-collection/#org3004566">FaceBook</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org41e629b">
<h2 id="org41e629b">Machine Learning</h2>
<div class="outline-text-2" id="text-org41e629b"></div>
<div class="outline-3" id="outline-container-org1cc43f3">
<h3 id="org1cc43f3">Blogs</h3>
<div class="outline-text-3" id="text-org1cc43f3">
<ul class="org-ul">
<li><a href="https://smerity.com/">Smerity</a></li>
</ul>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org654fd36">
<h2 id="org654fd36">Visualization</h2>
<div class="outline-text-2" id="text-org654fd36">
<ul class="org-ul">
<li><a href="https://jalammar.github.io/">Jay Alamar</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org3ca40ba">
<h2 id="org3ca40ba">Natural Language Processing</h2>
<div class="outline-text-2" id="text-org3ca40ba"></div>
<div class="outline-3" id="outline-container-org0206ee9">
<h3 id="org0206ee9">Books</h3>
<div class="outline-text-3" id="text-org0206ee9">
<ul class="org-ul">
<li><a href="https://web.stanford.edu/~jurafsky/slp3/">Speech and Language Processing</a> by <a href="https://web.stanford.edu/~jurafsky/">Dan Jurafsky</a> and <a href="https://www.cs.colorado.edu/~martin/">James H. Martin</a></li>
<li><a href="https://nlp.stanford.edu/IR-book/">Introduction to Information Retrieval</a> by Christopher D. Manning, Prabhakar Raghavan & Hinrich Schutze</li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-orgec8d0be">
<h3 id="orgec8d0be">Blogs</h3>
<div class="outline-text-3" id="text-orgec8d0be">
<ul class="org-ul">
<li><a href="https://ruder.io/">Sebastian Ruder</a></li>
<li><a href="http://www.abigailsee.com/">Abigail See</a></li>
</ul>
</div>
</div>
<div class="outline-3" id="outline-container-org70ff7fa">
<h3 id="org70ff7fa">Code</h3>
<div class="outline-text-3" id="text-org70ff7fa"></div>
<div class="outline-4" id="outline-container-org3004566">
<h4 id="org3004566">FaceBook</h4>
<div class="outline-text-4" id="text-org3004566">
<ul class="org-ul">
<li><a href="https://github.com/facebookresearch/pytext">pytext</a></li>
<li><a href="https://fasttext.cc/">fastText</a></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/keras/nlp-classification-exercise/">NLP Classification Exercise</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/keras/nlp-classification-exercise/" rel="bookmark"><time class="published dt-published" datetime="2019-09-29T11:28:06-07:00" itemprop="datePublished" title="2019-09-29 11:28">2019-09-29 11:28</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/keras/nlp-classification-exercise/#org2e5ff19">Beginning</a>
<ul>
<li><a href="/posts/keras/nlp-classification-exercise/#org7365da4">Imports</a>
<ul>
<li><a href="/posts/keras/nlp-classification-exercise/#org2c6e8ed">Python</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#orgcc9b76d">PyPi</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#org0dcefd8">Others</a></li>
</ul>
</li>
<li><a href="/posts/keras/nlp-classification-exercise/#org8ca7e4b">Set Up</a>
<ul>
<li><a href="/posts/keras/nlp-classification-exercise/#org42ad027">The Timer</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#orga08a317">The Plotting</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#orgf97d7a6">The Dataset</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#org46ecbd6">Some Constants</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/nlp-classification-exercise/#org3545ad8">Middle</a>
<ul>
<li><a href="/posts/keras/nlp-classification-exercise/#org11f38e3">The Data</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#org2a0ae62">The Tokenizer</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#orge93351d">GloVe</a></li>
<li><a href="/posts/keras/nlp-classification-exercise/#org706a1c3">The Models</a>
<ul>
<li><a href="/posts/keras/nlp-classification-exercise/#orgc2de0b7">A CNN</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/nlp-classification-exercise/#org98467b1">End</a>
<ul>
<li><a href="/posts/keras/nlp-classification-exercise/#orgf88be27">Citations</a></li>
</ul>
</li>
<li><a href="/posts/keras/nlp-classification-exercise/#org35ff6fc">Raw</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org2e5ff19">
<h2 id="org2e5ff19">Beginning</h2>
<div class="outline-text-2" id="text-org2e5ff19"></div>
<div class="outline-3" id="outline-container-org7365da4">
<h3 id="org7365da4">Imports</h3>
<div class="outline-text-3" id="text-org7365da4"></div>
<div class="outline-4" id="outline-container-org2c6e8ed">
<h4 id="org2c6e8ed">Python</h4>
<div class="outline-text-4" id="text-org2c6e8ed">
<div class="highlight">
<pre><span></span>from argparse import Namespace
from functools import partial
from pathlib import Path
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgcc9b76d">
<h4 id="orgcc9b76d">PyPi</h4>
<div class="outline-text-4" id="text-orgcc9b76d">
<div class="highlight">
<pre><span></span>from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.preprocessing.text import Tokenizer
import hvplot.pandas
import numpy
import pandas
import tensorflow
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org0dcefd8">
<h4 id="org0dcefd8">Others</h4>
<div class="outline-text-4" id="text-org0dcefd8">
<div class="highlight">
<pre><span></span>from graeae import (CountPercentage,
                    EmbedHoloviews,
                    SubPathLoader,
                    Timer,
                    ZipDownloader)
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org8ca7e4b">
<h3 id="org8ca7e4b">Set Up</h3>
<div class="outline-text-3" id="text-org8ca7e4b"></div>
<div class="outline-4" id="outline-container-org42ad027">
<h4 id="org42ad027">The Timer</h4>
<div class="outline-text-4" id="text-org42ad027">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orga08a317">
<h4 id="orga08a317">The Plotting</h4>
<div class="outline-text-4" id="text-orga08a317">
<div class="highlight">
<pre><span></span>slug = "nlp-classification-exercise"
Embed = partial(EmbedHoloviews, folder_path=f"../../files/posts/keras/{slug}")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgf97d7a6">
<h4 id="orgf97d7a6">The Dataset</h4>
<div class="outline-text-4" id="text-orgf97d7a6">
<p>It isn't mentioned in the notebook where the data originally came from, but it looks like it's the <a href="http://help.sentiment140.com/home">Sentiment140</a> dataset, which consists of tweets whose sentiment was inferred by emoticons in each tweet.</p>
<div class="highlight">
<pre><span></span>url = "http://cs.stanford.edu/people/alecmgo/trainingandtestdata.zip"
path = Path("~/data/datasets/texts/sentiment140/").expanduser()
download = ZipDownloader(url, path)
download()
</pre></div>
<pre class="example">
Files exist, not downloading
</pre>
<div class="highlight">
<pre><span></span>columns = ["polarity", "tweet_id", "datetime", "query", "user", "text"]
training = pandas.read_csv(path/"training.1600000.processed.noemoticon.csv", 
                           encoding="latin-1", names=columns, header=None)
testing = pandas.read_csv(path/"testdata.manual.2009.06.14.csv", 
                           encoding="latin-1", names=columns, header=None)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org46ecbd6">
<h4 id="org46ecbd6">Some Constants</h4>
<div class="outline-text-4" id="text-org46ecbd6">
<div class="highlight">
<pre><span></span>Text = Namespace(
    embedding_dim = 100,
    max_length = 16,
    trunc_type='post',
    padding_type='post',
    oov_tok = "&lt;OOV&gt;",
    training_size=16000,
)
</pre></div>
<div class="highlight">
<pre><span></span>Data = Namespace(
    batch_size = 64,
    shuffle_buffer_size=100,
)
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org3545ad8">
<h2 id="org3545ad8">Middle</h2>
<div class="outline-text-2" id="text-org3545ad8"></div>
<div class="outline-3" id="outline-container-org11f38e3">
<h3 id="org11f38e3">The Data</h3>
<div class="outline-text-3" id="text-org11f38e3">
<div class="highlight">
<pre><span></span>print(training.sample().iloc[0])
</pre></div>
<pre class="example">
polarity                                                    4
tweet_id                                           1468852290
datetime                         Tue Apr 07 04:04:10 PDT 2009
query                                                NO_QUERY
user                                              leawoodward
text        Def off now...unexpected day out tomorrow so s...
Name: 806643, dtype: object
</pre>
<div class="highlight">
<pre><span></span>CountPercentage(training.polarity)()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-right" scope="col">Value</th>
<th class="org-left" scope="col">Count</th>
<th class="org-right" scope="col">Percent (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">4</td>
<td class="org-left">800,000</td>
<td class="org-right">50.00</td>
</tr>
<tr>
<td class="org-right">0</td>
<td class="org-left">800,000</td>
<td class="org-right">50.00</td>
</tr>
</tbody>
</table>
<p>The <code>polarity</code> is what might also be called the "sentiment" of the tweet - <i>0</i> means a negative tweet and <i>4</i> means a positive tweet.</p>
<p>But, for our purposes, we would be better off if the positive polarity was <code>1</code>, not <code>4</code>, so let's convert it.</p>
<div class="highlight">
<pre><span></span>training.loc[training.polarity==4, "polarity"] = 1
counts = CountPercentage(training.polarity)()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-right" scope="col">Value</th>
<th class="org-left" scope="col">Count</th>
<th class="org-right" scope="col">Percent (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">800,000</td>
<td class="org-right">50.00</td>
</tr>
<tr>
<td class="org-right">0</td>
<td class="org-left">800,000</td>
<td class="org-right">50.00</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="outline-3" id="outline-container-org2a0ae62">
<h3 id="org2a0ae62">The Tokenizer</h3>
<div class="outline-text-3" id="text-org2a0ae62">
<p>As you can see from the sample, the data is still in text form so we need to convert it to a numeric form with a Tokenizer.</p>
<p>First I'll Lower-case it.</p>
<div class="highlight">
<pre><span></span>training.loc[:, "text"] = training.text.str.lower()
</pre></div>
<p>Next we'll fit it to our text.</p>
<div class="highlight">
<pre><span></span>tokenizer = Tokenizer()
with TIMER:
    tokenizer.fit_on_texts(training.text.values)
</pre></div>
<pre class="example">
2019-10-10 07:25:09,065 graeae.timers.timer start: Started: 2019-10-10 07:25:09.065039
WARNING: Logging before flag parsing goes to stderr.
I1010 07:25:09.065394 140436771002176 timer.py:70] Started: 2019-10-10 07:25:09.065039
2019-10-10 07:25:45,389 graeae.timers.timer end: Ended: 2019-10-10 07:25:45.389540
I1010 07:25:45.389598 140436771002176 timer.py:77] Ended: 2019-10-10 07:25:45.389540
2019-10-10 07:25:45,391 graeae.timers.timer end: Elapsed: 0:00:36.324501
I1010 07:25:45.391984 140436771002176 timer.py:78] Elapsed: 0:00:36.324501
</pre>
<p>Now, we can store some of it's values in variables for convenience.</p>
<div class="highlight">
<pre><span></span>word_index = tokenizer.word_index
vocabulary_size = len(tokenizer.word_index)
</pre></div>
<p>Now, we'll convert the texts to sequences and pad them so they are all the same length.</p>
<div class="highlight">
<pre><span></span>with TIMER:
    sequences = tokenizer.texts_to_sequences(training.text.values)
    padded = pad_sequences(sequences, maxlen=Text.max_length,
                           truncating=Text.trunc_type)

    splits = train_test_split(
        padded, training.polarity, test_size=.2)

    training_sequences, test_sequences, training_labels, test_labels = splits
</pre></div>
<pre class="example">
2019-10-10 07:25:51,057 graeae.timers.timer start: Started: 2019-10-10 07:25:51.057684
I1010 07:25:51.057712 140436771002176 timer.py:70] Started: 2019-10-10 07:25:51.057684
2019-10-10 07:26:33,530 graeae.timers.timer end: Ended: 2019-10-10 07:26:33.530338
I1010 07:26:33.530381 140436771002176 timer.py:77] Ended: 2019-10-10 07:26:33.530338
2019-10-10 07:26:33,531 graeae.timers.timer end: Elapsed: 0:00:42.472654
I1010 07:26:33.531477 140436771002176 timer.py:78] Elapsed: 0:00:42.472654
</pre>
<p>Now convert them to <a href="https://www.tensorflow.org/tutorials/load_data/numpy">datasets</a>.</p>
<div class="highlight">
<pre><span></span>training_dataset = tensorflow.data.Dataset.from_tensor_slices(
    (training_sequences, training_labels)
)

testing_dataset = tensorflow.data.Dataset.from_tensor_slices(
    (test_sequences, test_labels)
)

training_dataset = training_dataset.shuffle(Data.shuffle_buffer_size).batch(Data.batch_size)
testing_dataset = testing_dataset.shuffle(Data.shuffle_buffer_size).batch(Data.batch_size)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orge93351d">
<h3 id="orge93351d">GloVe</h3>
<div class="outline-text-3" id="text-orge93351d">
<p>GloVe is short for <i>Global Vectors for Word Representation</i>. It is an <i>unsupervised</i> algorithm that creates vector representations for words. They have a <a href="https://nlp.stanford.edu/projects/glove/">site</a> where you can download pre-trained models or get the code and train one yourself. We're going to use one of their pre-trained models.</p>
<div class="highlight">
<pre><span></span>path = Path("~/models/glove/").expanduser()
url = "http://nlp.stanford.edu/data/glove.6B.zip"
ZipDownloader(url, path)()
</pre></div>
<pre class="example">
Files exist, not downloading
</pre>
<p>The GloVe data is stored as a series of space separated lines with the first column being the word that's encoded and the rest of the columns being the values for the vector. To make this work we're going to split the word off from the vector and put each into a dictionary.</p>
<div class="highlight">
<pre><span></span>embeddings = {}
with TIMER:
    with open(path/"glove.6B.100d.txt") as lines:
        for line in lines:
            tokens = line.split()
            embeddings[tokens[0]] = numpy.array(tokens[1:])
</pre></div>
<pre class="example">
2019-10-06 18:55:11,592 graeae.timers.timer start: Started: 2019-10-06 18:55:11.592880
I1006 18:55:11.592908 140055379531584 timer.py:70] Started: 2019-10-06 18:55:11.592880
2019-10-06 18:55:21,542 graeae.timers.timer end: Ended: 2019-10-06 18:55:21.542689
I1006 18:55:21.542738 140055379531584 timer.py:77] Ended: 2019-10-06 18:55:21.542689
2019-10-06 18:55:21,544 graeae.timers.timer end: Elapsed: 0:00:09.949809
I1006 18:55:21.544939 140055379531584 timer.py:78] Elapsed: 0:00:09.949809
</pre>
<div class="highlight">
<pre><span></span>print(f"{len(embeddings):,}")
</pre></div>
<pre class="example">
400,000
</pre>
<p>So, our vocabulary consists of 400,000 "words" (tokens is more accurate, since they also include punctuation). The problem we have to deal with next is that our data set wasn't part of the dataset used to train the embeddings, so there will probably be some tokens in our data set that aren't in the embeddings. To handle this we need to add zeroed embeddings for the extra tokens.</p>
<p>Rather than adding to the dict, we'll create a matrix of zeros with rows for each word in our datasets vocabulary, then we'll iterate over the words in our dataset and if there's a match in the GloVE embeddings we'll insert it into the matrix.</p>
<div class="highlight">
<pre><span></span>with TIMER:
    embeddings_matrix = numpy.zeros((vocabulary_size+1, Text.embedding_dim));
    for word, index in word_index.items():
        embedding_vector = embeddings.get(word);
        if embedding_vector is not None:
            embeddings_matrix[index] = embedding_vector;
</pre></div>
<pre class="example">
2019-10-06 18:55:46,577 graeae.timers.timer start: Started: 2019-10-06 18:55:46.577855
I1006 18:55:46.577886 140055379531584 timer.py:70] Started: 2019-10-06 18:55:46.577855
2019-10-06 18:55:51,374 graeae.timers.timer end: Ended: 2019-10-06 18:55:51.374706
I1006 18:55:51.374763 140055379531584 timer.py:77] Ended: 2019-10-06 18:55:51.374706
2019-10-06 18:55:51,377 graeae.timers.timer end: Elapsed: 0:00:04.796851
I1006 18:55:51.377207 140055379531584 timer.py:78] Elapsed: 0:00:04.796851
</pre>
<div class="highlight">
<pre><span></span>print(f"{len(embeddings_matrix):,}")
</pre></div>
<pre class="example">
690,961
</pre></div>
</div>
<div class="outline-3" id="outline-container-org706a1c3">
<h3 id="org706a1c3">The Models</h3>
<div class="outline-text-3" id="text-org706a1c3"></div>
<div class="outline-4" id="outline-container-orgc2de0b7">
<h4 id="orgc2de0b7">A CNN</h4>
<div class="outline-text-4" id="text-orgc2de0b7"></div>
<ul class="org-ul">
<li><a id="org23c0caa"></a>Build<br>
<div class="outline-text-5" id="text-org23c0caa">
<div class="highlight">
<pre><span></span>convoluted_model = tensorflow.keras.Sequential([
    tensorflow.keras.layers.Embedding(
        vocabulary_size + 1,
        Text.embedding_dim,
        input_length=Text.max_length,
        weights=[embeddings_matrix],
        trainable=False),
    tensorflow.keras.layers.Conv1D(filters=128,
                                   kernel_size=5,
    activation='relu'),
    tensorflow.keras.layers.GlobalMaxPooling1D(),
    tensorflow.keras.layers.Dense(24, activation='relu'),
    tensorflow.keras.layers.Dense(1, activation='sigmoid')
])
convoluted_model.compile(loss="binary_crossentropy", optimizer="rmsprop",
                         metrics=["accuracy"])
</pre></div>
<div class="highlight">
<pre><span></span>print(convoluted_model.summary())
</pre></div>
<pre class="example">
Model: "sequential"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding (Embedding)        (None, 16, 100)           69096100  
_________________________________________________________________
conv1d (Conv1D)              (None, 12, 128)           64128     
_________________________________________________________________
global_max_pooling1d (Global (None, 128)               0         
_________________________________________________________________
dense (Dense)                (None, 24)                3096      
_________________________________________________________________
dense_1 (Dense)              (None, 1)                 25        
=================================================================
Total params: 69,163,349
Trainable params: 67,249
Non-trainable params: 69,096,100
_________________________________________________________________
None
</pre></div>
</li>
<li><a id="orgbff7d5d"></a>Train<br>
<div class="outline-text-5" id="text-orgbff7d5d">
<div class="highlight">
<pre><span></span>Training = Namespace(
    size = 0.75,
    epochs = 2,
    verbosity = 2,
    batch_size=128,
    )
</pre></div>
<div class="highlight">
<pre><span></span>with TIMER:
    cnn_history = convoluted_model.fit(training_dataset,
                                       epochs=Training.epochs,
                                       validation_data=testing_dataset,
                                       verbose=Training.verbosity)
</pre></div>
<pre class="example">
2019-10-10 07:27:04,921 graeae.timers.timer start: Started: 2019-10-10 07:27:04.921617
I1010 07:27:04.921657 140436771002176 timer.py:70] Started: 2019-10-10 07:27:04.921617
Epoch 1/2
W1010 07:27:05.154920 140436771002176 deprecation.py:323] From /home/hades/.virtualenvs/In-Too-Deep/lib/python3.7/site-packages/tensorflow_core/python/ops/nn_impl.py:183: where (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.where in 2.0, which has the same broadcast rule as np.where
20000/20000 - 4964s - loss: 0.5091 - accuracy: 0.7454 - val_loss: 0.0000e+00 - val_accuracy: 0.0000e+00
Epoch 2/2
20000/20000 - 4935s - loss: 0.4790 - accuracy: 0.7671 - val_loss: 0.4782 - val_accuracy: 0.7677
2019-10-10 10:12:04,382 graeae.timers.timer end: Ended: 2019-10-10 10:12:04.382359
I1010 10:12:04.382491 140436771002176 timer.py:77] Ended: 2019-10-10 10:12:04.382359
2019-10-10 10:12:04,384 graeae.timers.timer end: Elapsed: 2:44:59.460742
I1010 10:12:04.384716 140436771002176 timer.py:78] Elapsed: 2:44:59.460742
</pre></div>
</li>
<li><a id="orgb25cbac"></a>Some Plotting<br>
<div class="outline-text-5" id="text-orgb25cbac">
<div class="highlight">
<pre><span></span>performance = pandas.DataFrame(cnn_history.history)
plot = performance.hvplot().opts(title="CNN Twitter Sentiment Training Performance",
                                 width=1000,
                                 height=800)
Embed(plot=plot, file_name="cnn_training")()
</pre></div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org98467b1">
<h2 id="org98467b1">End</h2>
<div class="outline-text-2" id="text-org98467b1"></div>
<div class="outline-3" id="outline-container-orgf88be27">
<h3 id="orgf88be27">Citations</h3>
<div class="outline-text-3" id="text-orgf88be27">
<ul class="org-ul">
<li>Jeffrey Pennington, Richard Socher, and Christopher D. Manning. 2014. GloVe: Global Vectors for Word Representation.</li>
</ul>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org35ff6fc">
<h2 id="org35ff6fc">Raw</h2>
<div class="outline-text-2" id="text-org35ff6fc"></div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/keras/embeddings-from-scratch/">Embeddings from Scratch</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/keras/embeddings-from-scratch/" rel="bookmark"><time class="published dt-published" datetime="2019-09-25T13:30:12-07:00" itemprop="datePublished" title="2019-09-25 13:30">2019-09-25 13:30</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/keras/embeddings-from-scratch/#org654ab8b">Beginning</a>
<ul>
<li><a href="/posts/keras/embeddings-from-scratch/#org450f849">Imports</a>
<ul>
<li><a href="/posts/keras/embeddings-from-scratch/#orgf048ca4">Python</a></li>
<li><a href="/posts/keras/embeddings-from-scratch/#org5cd9974">PyPi</a></li>
<li><a href="/posts/keras/embeddings-from-scratch/#orgc44b003">Others</a></li>
</ul>
</li>
<li><a href="/posts/keras/embeddings-from-scratch/#org06a6fad">Set Up</a>
<ul>
<li><a href="/posts/keras/embeddings-from-scratch/#org9957179">Plotting</a></li>
<li><a href="/posts/keras/embeddings-from-scratch/#org9c06b31">The Timer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/embeddings-from-scratch/#orge19c0e2">Middle</a>
<ul>
<li><a href="/posts/keras/embeddings-from-scratch/#org29416e0">Some Constants</a></li>
<li><a href="/posts/keras/embeddings-from-scratch/#org07ea982">The Embeddings Layer</a></li>
<li><a href="/posts/keras/embeddings-from-scratch/#org18118d7">The Dataset</a>
<ul>
<li><a href="/posts/keras/embeddings-from-scratch/#orge80b8db">Add Padding</a></li>
<li><a href="/posts/keras/embeddings-from-scratch/#org02d6ebc">Checkout a Sample</a></li>
</ul>
</li>
<li><a href="/posts/keras/embeddings-from-scratch/#orgf942852">Build a Model</a></li>
<li><a href="/posts/keras/embeddings-from-scratch/#orgf392af9">Compile and Train</a></li>
</ul>
</li>
<li><a href="/posts/keras/embeddings-from-scratch/#org0030993">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org654ab8b">
<h2 id="org654ab8b">Beginning</h2>
<div class="outline-text-2" id="text-org654ab8b">
<p>This is a walk-through of the tensorflow <a href="https://www.tensorflow.org/beta/tutorials/text/word_embeddings">Word Embeddings</a> tutorial, just to make sure I can do it.</p>
</div>
<div class="outline-3" id="outline-container-org450f849">
<h3 id="org450f849">Imports</h3>
<div class="outline-text-3" id="text-org450f849"></div>
<div class="outline-4" id="outline-container-orgf048ca4">
<h4 id="orgf048ca4">Python</h4>
<div class="outline-text-4" id="text-orgf048ca4">
<div class="highlight">
<pre><span></span>from argparse import Namespace
from functools import partial
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org5cd9974">
<h4 id="org5cd9974">PyPi</h4>
<div class="outline-text-4" id="text-org5cd9974">
<div class="highlight">
<pre><span></span>from tensorflow import keras
from tensorflow.keras import layers
import hvplot.pandas
import pandas
import tensorflow
import tensorflow_datasets
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgc44b003">
<h4 id="orgc44b003">Others</h4>
<div class="outline-text-4" id="text-orgc44b003">
<div class="highlight">
<pre><span></span>from graeae import EmbedHoloviews, Timer
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org06a6fad">
<h3 id="org06a6fad">Set Up</h3>
<div class="outline-text-3" id="text-org06a6fad"></div>
<div class="outline-4" id="outline-container-org9957179">
<h4 id="org9957179">Plotting</h4>
<div class="outline-text-4" id="text-org9957179">
<div class="highlight">
<pre><span></span>prefix = "../../files/posts/keras/"
slug = "embeddings-from-scratch"

Embed = partial(EmbedHoloviews, folder_path=f"{prefix}{slug}")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9c06b31">
<h4 id="org9c06b31">The Timer</h4>
<div class="outline-text-4" id="text-org9c06b31">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orge19c0e2">
<h2 id="orge19c0e2">Middle</h2>
<div class="outline-text-2" id="text-orge19c0e2"></div>
<div class="outline-3" id="outline-container-org29416e0">
<h3 id="org29416e0">Some Constants</h3>
<div class="outline-text-3" id="text-org29416e0">
<div class="highlight">
<pre><span></span>Text = Namespace(
    vocabulary_size=1000,
    embeddings_size=16,
    max_length=500,
    padding="post",
)

Tokens = Namespace(
    padding = "&lt;PAD&gt;",
    start = "&lt;START&gt;",
    unknown = "&lt;UNKNOWN&gt;",
    unused = "&lt;UNUSED&gt;",
)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org07ea982">
<h3 id="org07ea982">The Embeddings Layer</h3>
<div class="outline-text-3" id="text-org07ea982">
<div class="highlight">
<pre><span></span>print(layers.Embedding.__doc__)
</pre></div>
<pre class="example">
Turns positive integers (indexes) into dense vectors of fixed size.

  e.g. `[[4], [20]] -&gt; [[0.25, 0.1], [0.6, -0.2]]`

  This layer can only be used as the first layer in a model.

  Example:

  ```python
  model = Sequential()
  model.add(Embedding(1000, 64, input_length=10))
  # the model will take as input an integer matrix of size (batch,
  # input_length).
  # the largest integer (i.e. word index) in the input should be no larger
  # than 999 (vocabulary size).
  # now model.output_shape == (None, 10, 64), where None is the batch
  # dimension.

  input_array = np.random.randint(1000, size=(32, 10))

  model.compile('rmsprop', 'mse')
  output_array = model.predict(input_array)
  assert output_array.shape == (32, 10, 64)
  ```

  Arguments:
    input_dim: int &gt; 0. Size of the vocabulary,
      i.e. maximum integer index + 1.
    output_dim: int &gt;= 0. Dimension of the dense embedding.
    embeddings_initializer: Initializer for the `embeddings` matrix.
    embeddings_regularizer: Regularizer function applied to
      the `embeddings` matrix.
    embeddings_constraint: Constraint function applied to
      the `embeddings` matrix.
    mask_zero: Whether or not the input value 0 is a special "padding"
      value that should be masked out.
      This is useful when using recurrent layers
      which may take variable length input.
      If this is `True` then all subsequent layers
      in the model need to support masking or an exception will be raised.
      If mask_zero is set to True, as a consequence, index 0 cannot be
      used in the vocabulary (input_dim should equal size of
      vocabulary + 1).
    input_length: Length of input sequences, when it is constant.
      This argument is required if you are going to connect
      `Flatten` then `Dense` layers upstream
      (without it, the shape of the dense outputs cannot be computed).

  Input shape:
    2D tensor with shape: `(batch_size, input_length)`.

  Output shape:
    3D tensor with shape: `(batch_size, input_length, output_dim)`.
  
</pre>
<div class="highlight">
<pre><span></span>embedding_layer = layers.Embedding(Text.vocabulary_size, Text.embeddings_size)
</pre></div>
<p>The first argument is the number of possible words in the vocabulary and the second is the number of dimensions. The Emebdding is a sort of lookup table that maps an integer that represents a word to a vector. In this case we're going to build a vocabulary of 1,000 words represented by vectors with a length of 32. The weights in the vectors are learned when we train the model and will encode the distance between words.</p>
<p>The input to the embeddings layer is a 2D tensor of integers with the shape (<code>number of samples</code>, <code>sequence_length</code>). The sequences are integer-encoded sentences of the same length - so you have to pad the shorter sentences to match the longest one (the <code>sequence_length</code>).</p>
<p>The ouput of the embeddings layer is a 3D tensor with the shape (<code>number of samples</code>, <code>sequence_length</code>, <code>embedding_dimensionality</code>).</p>
</div>
</div>
<div class="outline-3" id="outline-container-org18118d7">
<h3 id="org18118d7">The Dataset</h3>
<div class="outline-text-3" id="text-org18118d7">
<div class="highlight">
<pre><span></span>(train_data, test_data), info = tensorflow_datasets.load(
    "imdb_reviews/subwords8k",
    split=(tensorflow_datasets.Split.TRAIN,
           tensorflow_datasets.Split.TEST),
    with_info=True, as_supervised=True)
</pre></div>
<div class="highlight">
<pre><span></span>encoder = info.features["text"].encoder
print(encoder.subwords[:10])
</pre></div>
<pre class="example">
['the_', ', ', '. ', 'a_', 'and_', 'of_', 'to_', 's_', 'is_', 'br']
</pre></div>
<div class="outline-4" id="outline-container-orge80b8db">
<h4 id="orge80b8db">Add Padding</h4>
<div class="outline-text-4" id="text-orge80b8db">
<div class="highlight">
<pre><span></span>padded_shapes = ([None], ())
train_batches = train_data.shuffle(Text.vocabulary_size).padded_batch(
    10, padded_shapes=padded_shapes)
test_batches = test_data.shuffle(Text.vocabulary_size).padded_batch(
    10, padded_shapes=padded_shapes
)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org02d6ebc">
<h4 id="org02d6ebc">Checkout a Sample</h4>
<div class="outline-text-4" id="text-org02d6ebc">
<div class="highlight">
<pre><span></span>batch, labels = next(iter(train_batches))
print(batch.numpy())
</pre></div>
<pre class="example">
[[  62    9    4 ...    0    0    0]
 [  19 2428    6 ...    0    0    0]
 [ 691    2  594 ... 7961 1457 7975]
 ...
 [6072 5644 8043 ...    0    0    0]
 [ 977   15   57 ...    0    0    0]
 [5646    2    1 ...    0    0    0]]
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgf942852">
<h3 id="orgf942852">Build a Model</h3>
<div class="outline-text-3" id="text-orgf942852">
<div class="highlight">
<pre><span></span>model = keras.Sequential([
    layers.Embedding(encoder.vocab_size, Text.embeddings_size),
    layers.GlobalAveragePooling1D(),
    layers.Dense(1, activation="sigmoid")
])
</pre></div>
<div class="highlight">
<pre><span></span>print(model.summary())
</pre></div>
<pre class="example">
Model: "sequential"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding_1 (Embedding)      (None, None, 16)          130960    
_________________________________________________________________
global_average_pooling1d (Gl (None, 16)                0         
_________________________________________________________________
dense (Dense)                (None, 1)                 17        
=================================================================
Total params: 130,977
Trainable params: 130,977
Non-trainable params: 0
_________________________________________________________________
None
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgf392af9">
<h3 id="orgf392af9">Compile and Train</h3>
<div class="outline-text-3" id="text-orgf392af9">
<div class="highlight">
<pre><span></span>model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])
ONCE_PER_EPOCH = 2
with TIMER:
    history = model.fit(train_batches, epochs=10,
                        validation_data=test_batches,
                        verbose=ONCE_PER_EPOCH,
                        validation_steps=20)
</pre></div>
<pre class="example">
2019-09-28 17:14:52,764 graeae.timers.timer start: Started: 2019-09-28 17:14:52.764725
I0928 17:14:52.764965 140515023214400 timer.py:70] Started: 2019-09-28 17:14:52.764725
W0928 17:14:52.806057 140515023214400 deprecation.py:323] From /home/hades/.virtualenvs/In-Too-Deep/lib/python3.7/site-packages/tensorflow_core/python/ops/nn_impl.py:183: where (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.where in 2.0, which has the same broadcast rule as np.where
Epoch 1/10
 val_loss: 0.3015 - val_accuracy: 0.8900
2019-09-28 17:17:36,036 graeae.timers.timer end: Ended: 2019-09-28 17:17:36.036090
I0928 17:17:36.036139 140515023214400 timer.py:77] Ended: 2019-09-28 17:17:36.036090
2019-09-28 17:17:36,037 graeae.timers.timer end: Elapsed: 0:02:43.271365
I0928 17:17:36.037808 140515023214400 timer.py:78] Elapsed: 0:02:43.271365
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org0030993">
<h2 id="org0030993">End</h2>
<div class="outline-text-2" id="text-org0030993">
<div class="highlight">
<pre><span></span>data = pandas.DataFrame(history.history)
plot = data.hvplot().opts(title="Training/Validation Performance",
                          width=1000,
                          height=800)
Embed(plot=plot, file_name="training")()
</pre></div>
<object data="/posts/keras/embeddings-from-scratch/training.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<p>Amazingly, even with such a simple model, it managed a 92 % validation accuracy.</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/keras/imdb-lstm-with-tokenization/">IMDB GRU With Tokenization</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/keras/imdb-lstm-with-tokenization/" rel="bookmark"><time class="published dt-published" datetime="2019-09-23T14:14:04-07:00" itemprop="datePublished" title="2019-09-23 14:14">2019-09-23 14:14</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org7562436">Beginning</a>
<ul>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#orgcbbd699">Imports</a>
<ul>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#orgbac3360">Python</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#orgaa1a2b0">PyPi</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org15bcefc">Other</a></li>
</ul>
</li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org54c5f94">Set Up</a>
<ul>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org61ee86a">The Timer</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org6961a5b">Plotting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org507cabd">Middle</a>
<ul>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org50e2be3">Set Up the Data</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org2686541">Building Up the Tokenizer</a>
<ul>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#orgec97b13">Split Up the Sentences and Their Labels</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org5defa27">Some Constants</a></li>
</ul>
</li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org9da023c">Build the Tokenizer</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org79001e4">Decoder Ring</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org3f6f8ad">Build the Model</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#orgefd5ac1">Train it</a></li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#orgce33d44">Plot It</a></li>
</ul>
</li>
<li><a href="/posts/keras/imdb-lstm-with-tokenization/#org5789c43">Raw</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org7562436">
<h2 id="org7562436">Beginning</h2>
<div class="outline-text-2" id="text-org7562436">
<p>This is another version of the RNN model to classify the IMDB reviews, but this time we're going to tokenize it ourselves and use a GRU, instead of using the tensorflow-datasets version.</p>
</div>
<div class="outline-3" id="outline-container-orgcbbd699">
<h3 id="orgcbbd699">Imports</h3>
<div class="outline-text-3" id="text-orgcbbd699"></div>
<div class="outline-4" id="outline-container-orgbac3360">
<h4 id="orgbac3360">Python</h4>
<div class="outline-text-4" id="text-orgbac3360">
<div class="highlight">
<pre><span></span>from argparse import Namespace
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgaa1a2b0">
<h4 id="orgaa1a2b0">PyPi</h4>
<div class="outline-text-4" id="text-orgaa1a2b0">
<div class="highlight">
<pre><span></span>from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences

import hvplot.pandas
import numpy
import pandas
import tensorflow
import tensorflow_datasets
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org15bcefc">
<h4 id="org15bcefc">Other</h4>
<div class="outline-text-4" id="text-org15bcefc">
<div class="highlight">
<pre><span></span>from graeae import Timer, EmbedHoloviews
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org54c5f94">
<h3 id="org54c5f94">Set Up</h3>
<div class="outline-text-3" id="text-org54c5f94"></div>
<div class="outline-4" id="outline-container-org61ee86a">
<h4 id="org61ee86a">The Timer</h4>
<div class="outline-text-4" id="text-org61ee86a">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6961a5b">
<h4 id="org6961a5b">Plotting</h4>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org507cabd">
<h2 id="org507cabd">Middle</h2>
<div class="outline-text-2" id="text-org507cabd"></div>
<div class="outline-3" id="outline-container-org50e2be3">
<h3 id="org50e2be3">Set Up the Data</h3>
<div class="outline-text-3" id="text-org50e2be3">
<div class="highlight">
<pre><span></span>imdb, info = tensorflow_datasets.load("imdb_reviews",
                                      with_info=True,
                                      as_supervised=True)
</pre></div>
<pre class="example">
WARNING: Logging before flag parsing goes to stderr.
W0924 21:52:10.158111 139862640383808 dataset_builder.py:439] Warning: Setting shuffle_files=True because split=TRAIN and shuffle_files=None. This behavior will be deprecated on 2019-08-06, at which point shuffle_files=False will be the default for all splits.
</pre>
<div class="highlight">
<pre><span></span>training, testing = imdb["train"], imdb["test"]
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org2686541">
<h3 id="org2686541">Building Up the Tokenizer</h3>
<div class="outline-text-3" id="text-org2686541">
<p>Since we didn't pass in a specifier for the configuration we wanted (e.g. <code>imdb/subwords8k</code>) it defaulted to giving us the plain text reviews (and their labels) so we have to build the tokenizer ourselves.</p>
</div>
<div class="outline-4" id="outline-container-orgec97b13">
<h4 id="orgec97b13">Split Up the Sentences and Their Labels</h4>
<div class="outline-text-4" id="text-orgec97b13">
<p>As you might recall, the data set consists of 50,000 IMDB movie reviews categorized as positive or negative. To build the tokenize we first have to split the sentences from their labels</p>
<div class="highlight">
<pre><span></span>training_sentences = []
training_labels = []
testing_sentences = []
testing_labels = []
</pre></div>
<div class="highlight">
<pre><span></span>with TIMER:
    for sentence, label in training:
        training_sentences.append(str(sentence.numpy()))
        training_labels.append(str(label.numpy()))


    for sentence, label in testing:
        testing_sentences.append(str(sentence.numpy))
        testing_labels.append(str(label.numpy()))
</pre></div>
<pre class="example">
2019-09-24 21:52:11,396 graeae.timers.timer start: Started: 2019-09-24 21:52:11.395126
I0924 21:52:11.396310 139862640383808 timer.py:70] Started: 2019-09-24 21:52:11.395126
2019-09-24 21:52:18,667 graeae.timers.timer end: Ended: 2019-09-24 21:52:18.667789
I0924 21:52:18.667830 139862640383808 timer.py:77] Ended: 2019-09-24 21:52:18.667789
2019-09-24 21:52:18,670 graeae.timers.timer end: Elapsed: 0:00:07.272663
I0924 21:52:18.670069 139862640383808 timer.py:78] Elapsed: 0:00:07.272663
</pre>
<div class="highlight">
<pre><span></span>training_labels_final = numpy.array(training_labels)
testing_labels_final = numpy.array(testing_labels)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org5defa27">
<h4 id="org5defa27">Some Constants</h4>
<div class="outline-text-4" id="text-org5defa27">
<div class="highlight">
<pre><span></span>Text = Namespace(
    vocab_size = 10000,
    embedding_dim = 16,
    max_length = 120,
    trunc_type='post',
    oov_token = "&lt;OOV&gt;",
)
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org9da023c">
<h3 id="org9da023c">Build the Tokenizer</h3>
<div class="outline-text-3" id="text-org9da023c">
<div class="highlight">
<pre><span></span>tokenizer = Tokenizer(num_words=Text.vocab_size, oov_token=Text.oov_token)
with TIMER:
    tokenizer.fit_on_texts(training_sentences)

    word_index = tokenizer.word_index
    sequences = tokenizer.texts_to_sequences(training_sentences)
    padded = pad_sequences(sequences, maxlen=Text.max_length, truncating=Text.trunc_type)

    testing_sequences = tokenizer.texts_to_sequences(testing_sentences)
    testing_padded = pad_sequences(testing_sequences, maxlen=Text.max_length)
</pre></div>
<pre class="example">
2019-09-24 21:52:21,705 graeae.timers.timer start: Started: 2019-09-24 21:52:21.705287
I0924 21:52:21.705317 139862640383808 timer.py:70] Started: 2019-09-24 21:52:21.705287
2019-09-24 21:52:32,152 graeae.timers.timer end: Ended: 2019-09-24 21:52:32.152267
I0924 21:52:32.152314 139862640383808 timer.py:77] Ended: 2019-09-24 21:52:32.152267
2019-09-24 21:52:32,154 graeae.timers.timer end: Elapsed: 0:00:10.446980
I0924 21:52:32.154620 139862640383808 timer.py:78] Elapsed: 0:00:10.446980
</pre></div>
</div>
<div class="outline-3" id="outline-container-org79001e4">
<h3 id="org79001e4">Decoder Ring</h3>
<div class="outline-text-3" id="text-org79001e4">
<div class="highlight">
<pre><span></span>index_to_word = {value: key for key, value in word_index.items()}

def decode_review(text: numpy.array) -&gt; str:
    return " ".join([index_to_word.get(item, "&lt;?&gt;") for item in text])
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org3f6f8ad">
<h3 id="org3f6f8ad">Build the Model</h3>
<div class="outline-text-3" id="text-org3f6f8ad">
<p>This time we're going to build a four-layer model with one Bidirectional layer that uses a <a href="https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/keras/layers/GRU">GRU</a> (<a href="https://www.wikiwand.com/en/Gated_recurrent_unit">Gated Recurrent Unit</a>) instead of a LSTM.</p>
<div class="highlight">
<pre><span></span>model = tensorflow.keras.Sequential([
    tensorflow.keras.layers.Embedding(Text.vocab_size, Text.embedding_dim, input_length=Text.max_length),
    tensorflow.keras.layers.Bidirectional(tensorflow.compat.v2.keras.layers.GRU(32)),
    tensorflow.keras.layers.Dense(6, activation='relu'),
    tensorflow.keras.layers.Dense(1, activation='sigmoid')
])
model.compile(loss="binary_crossentropy", optimizer="adam", metrics=["accuracy"])
</pre></div>
<div class="highlight">
<pre><span></span>print(model.summary())
</pre></div>
<pre class="example">
Model: "sequential"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding (Embedding)        (None, 120, 16)           160000    
_________________________________________________________________
bidirectional (Bidirectional (None, 64)                9600      
_________________________________________________________________
dense (Dense)                (None, 6)                 390       
_________________________________________________________________
dense_1 (Dense)              (None, 1)                 7         
=================================================================
Total params: 169,997
Trainable params: 169,997
Non-trainable params: 0
_________________________________________________________________
None
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgefd5ac1">
<h3 id="orgefd5ac1">Train it</h3>
<div class="outline-text-3" id="text-orgefd5ac1">
<div class="highlight">
<pre><span></span>EPOCHS = 50
ONCE_PER_EPOCH = 2
batch_size = 8
history = model.fit(padded, training_labels_final,
                    epochs=EPOCHS,
                    batch_size=batch_size,
                    validation_data=(testing_padded, testing_labels_final),
                    verbose=ONCE_PER_EPOCH)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgce33d44">
<h3 id="orgce33d44">Plot It</h3>
<div class="outline-text-3" id="text-orgce33d44">
<div class="highlight">
<pre><span></span>data = pandas.DataFrame(history.history)
plot = data.hvplot().opts(title="GRU Training Performance", width=1000, height=800)
Embed(plot=plot, file_name="gru_training")()
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org5789c43">
<h2 id="org5789c43">Raw</h2>
<div class="outline-text-2" id="text-org5789c43"></div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/keras/he-used-sarcasm/">He Used Sarcasm</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/keras/he-used-sarcasm/" rel="bookmark"><time class="published dt-published" datetime="2019-09-21T19:01:16-07:00" itemprop="datePublished" title="2019-09-21 19:01">2019-09-21 19:01</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/keras/he-used-sarcasm/#org03401a5">Beginning</a>
<ul>
<li><a href="/posts/keras/he-used-sarcasm/#orga5e014e">Imports</a>
<ul>
<li><a href="/posts/keras/he-used-sarcasm/#org2b1ddea">Python</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#orgf1da60c">PyPi</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org654f6ee">Other</a></li>
</ul>
</li>
<li><a href="/posts/keras/he-used-sarcasm/#orgabbaab9">Set Up</a>
<ul>
<li><a href="/posts/keras/he-used-sarcasm/#orgcaeaeb5">The Timer</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org67e59ae">The Plotting</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org184ca5c">The Data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/he-used-sarcasm/#orgb358018">Middle</a>
<ul>
<li><a href="/posts/keras/he-used-sarcasm/#orge4a503c">Looking At the Data</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#orgaa27055">Set Up the Tokenizing and Training Data</a>
<ul>
<li><a href="/posts/keras/he-used-sarcasm/#orga87f413">The Training and Testing Data</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org4e486d8">The Tokenizer</a></li>
</ul>
</li>
<li><a href="/posts/keras/he-used-sarcasm/#org2612a6f">Build The Model</a>
<ul>
<li><a href="/posts/keras/he-used-sarcasm/#org776dbe4">It's a Sequence of Layers</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org628aa8b">Start With An Embedding Layer</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org1d3105d">The Convolutional Layer</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#orgf546ab7">A Pooling Layer</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org8d4cfe7">The Fully-Connected Layers</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org386f454">Build It</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#org195077c">Compile It</a></li>
</ul>
</li>
<li><a href="/posts/keras/he-used-sarcasm/#org5942f51">Train It</a></li>
<li><a href="/posts/keras/he-used-sarcasm/#orgb5b8e5c">Plot the Performance</a></li>
</ul>
</li>
<li><a href="/posts/keras/he-used-sarcasm/#org71c3adf">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org03401a5">
<h2 id="org03401a5">Beginning</h2>
<div class="outline-text-2" id="text-org03401a5">
<p>This is a look at fitting a model to detect sarcasm using a json blob from Laurence Moroney (<a href="https://storage.googleapis.com/laurencemoroney-blog.appspot.com/sarcasm.json">https://storage.googleapis.com/laurencemoroney-blog.appspot.com/sarcasm.json</a>).</p>
</div>
<div class="outline-3" id="outline-container-orga5e014e">
<h3 id="orga5e014e">Imports</h3>
<div class="outline-text-3" id="text-orga5e014e"></div>
<div class="outline-4" id="outline-container-org2b1ddea">
<h4 id="org2b1ddea">Python</h4>
<div class="outline-text-4" id="text-org2b1ddea">
<div class="highlight">
<pre><span></span>from argparse import Namespace
from functools import partial
from pathlib import Path
from pprint import pprint
from urllib.parse import urlparse
import json
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgf1da60c">
<h4 id="orgf1da60c">PyPi</h4>
<div class="outline-text-4" id="text-orgf1da60c">
<div class="highlight">
<pre><span></span>from sklearn.model_selection import train_test_split
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
import hvplot.pandas
import pandas
import tensorflow
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org654f6ee">
<h4 id="org654f6ee">Other</h4>
<div class="outline-text-4" id="text-org654f6ee">
<div class="highlight">
<pre><span></span>from graeae import (
    CountPercentage,
    EmbedHoloviews,
    TextDownloader,
    Timer
)
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgabbaab9">
<h3 id="orgabbaab9">Set Up</h3>
<div class="outline-text-3" id="text-orgabbaab9"></div>
<div class="outline-4" id="outline-container-orgcaeaeb5">
<h4 id="orgcaeaeb5">The Timer</h4>
<div class="outline-text-4" id="text-orgcaeaeb5">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org67e59ae">
<h4 id="org67e59ae">The Plotting</h4>
<div class="outline-text-4" id="text-org67e59ae">
<div class="highlight">
<pre><span></span>SLUG = "he-used-sarcasm"
Embed = partial(EmbedHoloviews, folder_path=f"../../files/posts/keras/{SLUG}")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org184ca5c">
<h4 id="org184ca5c">The Data</h4>
<div class="outline-text-4" id="text-org184ca5c">
<div class="highlight">
<pre><span></span>URL = "https://storage.googleapis.com/laurencemoroney-blog.appspot.com/sarcasm.json"
path = Path("~/data/datasets/text/sarcasm/sarcasm.json").expanduser()
downloader = TextDownloader(URL, path)
with TIMER:
    data = json.loads(downloader.download)
</pre></div>
<pre class="example">
2019-09-22 15:05:27,302 graeae.timers.timer start: Started: 2019-09-22 15:05:27.301225
WARNING: Logging before flag parsing goes to stderr.
I0922 15:05:27.302001 139873020925760 timer.py:70] Started: 2019-09-22 15:05:27.301225
2019-09-22 15:05:27,306 [1mTextDownloader[0m download: /home/hades/data/datasets/text/sarcasm/sarcasm.json exists, opening it
I0922 15:05:27.306186 139873020925760 downloader.py:51] /home/hades/data/datasets/text/sarcasm/sarcasm.json exists, opening it
2019-09-22 15:05:27,367 graeae.timers.timer end: Ended: 2019-09-22 15:05:27.367036
I0922 15:05:27.367099 139873020925760 timer.py:77] Ended: 2019-09-22 15:05:27.367036
2019-09-22 15:05:27,369 graeae.timers.timer end: Elapsed: 0:00:00.065811
I0922 15:05:27.369417 139873020925760 timer.py:78] Elapsed: 0:00:00.065811
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgb358018">
<h2 id="orgb358018">Middle</h2>
<div class="outline-text-2" id="text-orgb358018"></div>
<div class="outline-3" id="outline-container-orge4a503c">
<h3 id="orge4a503c">Looking At the Data</h3>
<div class="outline-text-3" id="text-orge4a503c">
<div class="highlight">
<pre><span></span>pprint(data[0])
</pre></div>
<pre class="example">
{'article_link': 'https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5',
 'headline': "former versace store clerk sues over secret 'black code' for "
             'minority shoppers',
 'is_sarcastic': 0}
</pre>
<p>So our data is a dictionary with three keys - the source of the article, the headline of the article, and whether it's a sarcastic headline or not. There's no citation in the original notebook, but it looks like it might be this one <a href="https://github.com/rishabhmisra/News-Headlines-Dataset-For-Sarcasm-Detection">on GitHub</a>.</p>
<div class="highlight">
<pre><span></span>data = pandas.DataFrame(data)
data.loc[:, "site"] = data.article_link.apply(lambda link: urlparse(link).netloc)
</pre></div>
<div class="highlight">
<pre><span></span>CountPercentage(data.site, value_label="Site")()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Site</th>
<th class="org-right" scope="col">Count</th>
<th class="org-right" scope="col">Percent (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">www.huffingtonpost.com</td>
<td class="org-right">14403</td>
<td class="org-right">53.93</td>
</tr>
<tr>
<td class="org-left">www.theonion.com</td>
<td class="org-right">5811</td>
<td class="org-right">21.76</td>
</tr>
<tr>
<td class="org-left">local.theonion.com</td>
<td class="org-right">2852</td>
<td class="org-right">10.68</td>
</tr>
<tr>
<td class="org-left">politics.theonion.com</td>
<td class="org-right">1767</td>
<td class="org-right">6.62</td>
</tr>
<tr>
<td class="org-left">entertainment.theonion.com</td>
<td class="org-right">1194</td>
<td class="org-right">4.47</td>
</tr>
<tr>
<td class="org-left">www.huffingtonpost.comhttp:</td>
<td class="org-right">503</td>
<td class="org-right">1.88</td>
</tr>
<tr>
<td class="org-left">sports.theonion.com</td>
<td class="org-right">100</td>
<td class="org-right">0.37</td>
</tr>
<tr>
<td class="org-left">www.huffingtonpost.comhttps:</td>
<td class="org-right">79</td>
<td class="org-right">0.30</td>
</tr>
</tbody>
</table>
<p>So, it looks like there's some problems with the URLs. I don't think that's important, but maybe I can clean up a little anyway.</p>
<div class="highlight">
<pre><span></span>print(
    data[
        data.site.str.contains("www.huffingtonpost.comhttp"
                               )].article_link.value_counts())
</pre></div>
<pre class="example">
https://www.huffingtonpost.comhttp://nymag.com/daily/intelligencer/2016/05/hillary-clinton-candidacy.html                                                                                              2
https://www.huffingtonpost.comhttps://www.facebook.com/HuffPostQueerVoices/videos/1153919084666530/                                                                                                    1
https://www.huffingtonpost.comhttp://live.huffingtonpost.com/r/segment/chris-meloni-star-underground/56d8584f99ec6dca3d00000a                                                                          1
https://www.huffingtonpost.comhttp://www.thestreet.com/story/13223501/1/post-retirement-work-may-not-save-your-golden-years.html                                                                       1
https://www.huffingtonpost.comhttps://www.facebook.com/HuffPostEntertainment/                                                                                                                          1
                                                                                                                                                                                                      ..
https://www.huffingtonpost.comhttp://nymag.com/thecut/2015/10/first-legal-abortionists-tell-their-stories.html?mid=twitter_nymag                                                                       1
https://www.huffingtonpost.comhttp://www.tampabay.com/blogs/the-buzz-florida-politics/marco-rubio-warming-up-to-donald-trump/2275308                                                                   1
https://www.huffingtonpost.comhttp://live.huffingtonpost.com/r/segment/porn-to-pay-for-college/55aeadf62b8c2a2f6f000193                                                                                1
https://www.huffingtonpost.comhttps://www.thedodo.com/dog-mouth-taped-shut-facebook-1481874724.html                                                                                                    1
https://www.huffingtonpost.comhttps://www.washingtonpost.com/politics/ben-carson-to-tell-supporters-he-sees-no-path-forward-for-campaign/2016/03/02/d6bef352-d9b3-11e5-891a-4ed04f4213e8_story.html    1
Name: article_link, Length: 581, dtype: int64
</pre>
<p>That's kind of odd, I don't know what that means, maybe the Huffington Post was citing other sites? I went to go check the GitHub dataset I mentioned but it's actually much larger than this one so I don't know if it's really the source or not.</p>
<div class="highlight">
<pre><span></span>prefixes = ("www.huffingtonpost.comhttp:", "www.huffingtonpost.comhttps:")
for prefix in prefixes:
    data.loc[:, "site"] = data.site.str.replace(
        prefix,
        "www.huffingtonpost.com")

prefixes = ("local.theonion.com",
            "politics.theonion.com",
            "entertainment.theonion.com",
            "sports.theonion.com")

for prefix in prefixes:
    data.loc[:, "site"] = data.site.str.replace(prefix,
                                                "www.theonion.com")
</pre></div>
<div class="highlight">
<pre><span></span>counter = CountPercentage(data.site, value_label="Site")
counter()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Site</th>
<th class="org-right" scope="col">Count</th>
<th class="org-right" scope="col">Percent (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">www.huffingtonpost.com</td>
<td class="org-right">14985</td>
<td class="org-right">56.10</td>
</tr>
<tr>
<td class="org-left">www.theonion.com</td>
<td class="org-right">11724</td>
<td class="org-right">43.90</td>
</tr>
</tbody>
</table>
<div class="highlight">
<pre><span></span>plot = counter.table.hvplot.bar(x="Site", y="Count").opts(
    title="Distribution by Site",
    width=1000,
    height=800)
Embed(plot=plot, file_name="site_distribution")()
</pre></div>
<object data="/posts/keras/he-used-sarcasm/site_distribution.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<div class="highlight">
<pre><span></span>counter = CountPercentage(data.is_sarcastic, value_label="Is Sarcastic")
counter()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-right">
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-right" scope="col">Is Sarcastic</th>
<th class="org-left" scope="col">Count</th>
<th class="org-right" scope="col">Percent (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">14,985</td>
<td class="org-right">56.10</td>
</tr>
<tr>
<td class="org-right">1</td>
<td class="org-left">11,724</td>
<td class="org-right">43.90</td>
</tr>
</tbody>
</table>
<p>Given that the counts match I'm assuming anything from the Huffington Post is labeled as not sarcastic and anything from the onion is sarcastic.</p>
<div class="highlight">
<pre><span></span>assert all(data[data.site=="www.onion.com"].is_sarcastic)
assert not any(data[data.site=="www.huffingtonpost.com"].is_sarcastic)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgaa27055">
<h3 id="orgaa27055">Set Up the Tokenizing and Training Data</h3>
<div class="outline-text-3" id="text-orgaa27055">
<div class="highlight">
<pre><span></span>print(f"{len(data):,}")
</pre></div>
<pre class="example">
26,709
</pre>
<div class="highlight">
<pre><span></span>Text = Namespace(
    vocabulary_size = 1000,
    embedding_dim = 16,
    max_length = 120,
    truncating_type='post',
    padding_type='post',
    out_of_vocabulary_tok = "&lt;OOV&gt;",
)

# this is actually the default for train_test_split
Training = Namespace(
    size = 0.75,
    epochs = 50,
    verbosity = 2,
    )
</pre></div>
</div>
<div class="outline-4" id="outline-container-orga87f413">
<h4 id="orga87f413">The Training and Testing Data</h4>
<div class="outline-text-4" id="text-orga87f413">
<div class="highlight">
<pre><span></span>x_train, x_test, y_train, y_test = train_test_split(
    data.headline, data.is_sarcastic, train_size=Training.size,
)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org4e486d8">
<h4 id="org4e486d8">The Tokenizer</h4>
<div class="outline-text-4" id="text-org4e486d8">
<div class="highlight">
<pre><span></span>tokenizer = Tokenizer(num_words=Text.vocabulary_size,
                      oov_token=Text.out_of_vocabulary_tok)
</pre></div>
<div class="highlight">
<pre><span></span>print(tokenizer.__doc__)
</pre></div>
<pre class="example">
Text tokenization utility class.

    This class allows to vectorize a text corpus, by turning each
    text into either a sequence of integers (each integer being the index
    of a token in a dictionary) or into a vector where the coefficient
    for each token could be binary, based on word count, based on tf-idf...

    # Arguments
        num_words: the maximum number of words to keep, based
            on word frequency. Only the most common `num_words-1` words will
            be kept.
        filters: a string where each element is a character that will be
            filtered from the texts. The default is all punctuation, plus
            tabs and line breaks, minus the `'` character.
        lower: boolean. Whether to convert the texts to lowercase.
        split: str. Separator for word splitting.
        char_level: if True, every character will be treated as a token.
        oov_token: if given, it will be added to word_index and used to
            replace out-of-vocabulary words during text_to_sequence calls

    By default, all punctuation is removed, turning the texts into
    space-separated sequences of words
    (words maybe include the `'` character). These sequences are then
    split into lists of tokens. They will then be indexed or vectorized.

    `0` is a reserved index that won't be assigned to any word.
</pre>
<p>Now that we have a tokenizer we can tokenize our training headlines.</p>
<div class="highlight">
<pre><span></span>help(tokenizer.fit_on_texts)
</pre></div>
<pre class="example">
Help on method fit_on_texts in module keras_preprocessing.text:

fit_on_texts(texts) method of keras_preprocessing.text.Tokenizer instance
    Updates internal vocabulary based on a list of texts.
    
    In the case where texts contains lists,
    we assume each entry of the lists to be a token.
    
    Required before using `texts_to_sequences` or `texts_to_matrix`.
    
    # Arguments
        texts: can be a list of strings,
            a generator of strings (for memory-efficiency),
            or a list of list of strings.

</pre>
<div class="highlight">
<pre><span></span>tokenizer.fit_on_texts(x_train)
</pre></div>
<p>Now that we've fit the headlines we can get the word index, a dict mapping words to their index.</p>
<div class="highlight">
<pre><span></span>word_index = tokenizer.word_index
</pre></div>
<p>Note that the tokenizer doesn't remove stop-words.</p>
<div class="highlight">
<pre><span></span>print("the" in word_index)
</pre></div>
<pre class="example">
True
</pre>
<p>Now we'll convert the training headlines to sequences of numbers.</p>
<div class="highlight">
<pre><span></span>help(tokenizer.texts_to_sequences)
</pre></div>
<pre class="example">
Help on method texts_to_sequences in module keras_preprocessing.text:

texts_to_sequences(texts) method of keras_preprocessing.text.Tokenizer instance
    Transforms each text in texts to a sequence of integers.
    
    Only top `num_words-1` most frequent words will be taken into account.
    Only words known by the tokenizer will be taken into account.
    
    # Arguments
        texts: A list of texts (strings).
    
    # Returns
        A list of sequences.

</pre>
<p>We're also going to have to pad them to make them the same length.</p>
<div class="highlight">
<pre><span></span>help(pad_sequences)
</pre></div>
<pre class="example">
Help on function pad_sequences in module keras_preprocessing.sequence:

pad_sequences(sequences, maxlen=None, dtype='int32', padding='pre', truncating='pre', value=0.0)
    Pads sequences to the same length.
    
    This function transforms a list of
    `num_samples` sequences (lists of integers)
    into a 2D Numpy array of shape `(num_samples, num_timesteps)`.
    `num_timesteps` is either the `maxlen` argument if provided,
    or the length of the longest sequence otherwise.
    
    Sequences that are shorter than `num_timesteps`
    are padded with `value` at the end.
    
    Sequences longer than `num_timesteps` are truncated
    so that they fit the desired length.
    The position where padding or truncation happens is determined by
    the arguments `padding` and `truncating`, respectively.
    
    Pre-padding is the default.
    
    # Arguments
        sequences: List of lists, where each element is a sequence.
        maxlen: Int, maximum length of all sequences.
        dtype: Type of the output sequences.
            To pad sequences with variable length strings, you can use `object`.
        padding: String, 'pre' or 'post':
            pad either before or after each sequence.
        truncating: String, 'pre' or 'post':
            remove values from sequences larger than
            `maxlen`, either at the beginning or at the end of the sequences.
        value: Float or String, padding value.
    
    # Returns
        x: Numpy array with shape `(len(sequences), maxlen)`
    
    # Raises
        ValueError: In case of invalid values for `truncating` or `padding`,
            or in case of invalid shape for a `sequences` entry.

</pre>
<div class="highlight">
<pre><span></span>training_sequences = tokenizer.texts_to_sequences(x_train)
training_padded = pad_sequences(training_sequences, maxlen=Text.max_length, padding=Text.padding_type, truncating=Text.truncating_type)

testing_sequences = tokenizer.texts_to_sequences(x_test)
testing_padded = pad_sequences(testing_sequences, maxlen=Text.max_length, padding=Text.padding_type, truncating=Text.truncating_type)
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org2612a6f">
<h3 id="org2612a6f">Build The Model</h3>
<div class="outline-text-3" id="text-org2612a6f">
<p>We're going to use a convolutional neural network to try and classify our headlines as sarcastic or not-sarcastic.</p>
</div>
<div class="outline-4" id="outline-container-org776dbe4">
<h4 id="org776dbe4">It's a Sequence of Layers</h4>
<div class="outline-text-4" id="text-org776dbe4">
<div class="highlight">
<pre><span></span>print(tensorflow.keras.Sequential.__doc__)
</pre></div>
<pre class="example">
Linear stack of layers.

  Arguments:
      layers: list of layers to add to the model.

  Example:

  ```python
  # Optionally, the first layer can receive an `input_shape` argument:
  model = Sequential()
  model.add(Dense(32, input_shape=(500,)))
  # Afterwards, we do automatic shape inference:
  model.add(Dense(32))

  # This is identical to the following:
  model = Sequential()
  model.add(Dense(32, input_dim=500))

  # And to the following:
  model = Sequential()
  model.add(Dense(32, batch_input_shape=(None, 500)))

  # Note that you can also omit the `input_shape` argument:
  # In that case the model gets built the first time you call `fit` (or other
  # training and evaluation methods).
  model = Sequential()
  model.add(Dense(32))
  model.add(Dense(32))
  model.compile(optimizer=optimizer, loss=loss)
  # This builds the model for the first time:
  model.fit(x, y, batch_size=32, epochs=10)

  # Note that when using this delayed-build pattern (no input shape specified),
  # the model doesn't have any weights until the first call
  # to a training/evaluation method (since it isn't yet built):
  model = Sequential()
  model.add(Dense(32))
  model.add(Dense(32))
  model.weights  # returns []

  # Whereas if you specify the input shape, the model gets built continuously
  # as you are adding layers:
  model = Sequential()
  model.add(Dense(32, input_shape=(500,)))
  model.add(Dense(32))
  model.weights  # returns list of length 4

  # When using the delayed-build pattern (no input shape specified), you can
  # choose to manually build your model by calling `build(batch_input_shape)`:
  model = Sequential()
  model.add(Dense(32))
  model.add(Dense(32))
  model.build((None, 500))
  model.weights  # returns list of length 4
  ```
  
</pre></div>
</div>
<div class="outline-4" id="outline-container-org628aa8b">
<h4 id="org628aa8b">Start With An Embedding Layer</h4>
<div class="outline-text-4" id="text-org628aa8b">
<div class="highlight">
<pre><span></span>print(tensorflow.keras.layers.Embedding.__doc__)
</pre></div>
<pre class="example">
Turns positive integers (indexes) into dense vectors of fixed size.

  e.g. `[[4], [20]] -&gt; [[0.25, 0.1], [0.6, -0.2]]`

  This layer can only be used as the first layer in a model.

  Example:

  ```python
  model = Sequential()
  model.add(Embedding(1000, 64, input_length=10))
  # the model will take as input an integer matrix of size (batch,
  # input_length).
  # the largest integer (i.e. word index) in the input should be no larger
  # than 999 (vocabulary size).
  # now model.output_shape == (None, 10, 64), where None is the batch
  # dimension.

  input_array = np.random.randint(1000, size=(32, 10))

  model.compile('rmsprop', 'mse')
  output_array = model.predict(input_array)
  assert output_array.shape == (32, 10, 64)
  ```

  Arguments:
    input_dim: int &gt; 0. Size of the vocabulary,
      i.e. maximum integer index + 1.
    output_dim: int &gt;= 0. Dimension of the dense embedding.
    embeddings_initializer: Initializer for the `embeddings` matrix.
    embeddings_regularizer: Regularizer function applied to
      the `embeddings` matrix.
    embeddings_constraint: Constraint function applied to
      the `embeddings` matrix.
    mask_zero: Whether or not the input value 0 is a special "padding"
      value that should be masked out.
      This is useful when using recurrent layers
      which may take variable length input.
      If this is `True` then all subsequent layers
      in the model need to support masking or an exception will be raised.
      If mask_zero is set to True, as a consequence, index 0 cannot be
      used in the vocabulary (input_dim should equal size of
      vocabulary + 1).
    input_length: Length of input sequences, when it is constant.
      This argument is required if you are going to connect
      `Flatten` then `Dense` layers upstream
      (without it, the shape of the dense outputs cannot be computed).

  Input shape:
    2D tensor with shape: `(batch_size, input_length)`.

  Output shape:
    3D tensor with shape: `(batch_size, input_length, output_dim)`.
  
</pre></div>
</div>
<div class="outline-4" id="outline-container-org1d3105d">
<h4 id="org1d3105d">The Convolutional Layer</h4>
<div class="outline-text-4" id="text-org1d3105d">
<div class="highlight">
<pre><span></span>print(tensorflow.keras.layers.Conv1D.__doc__)
</pre></div>
<pre class="example">
1D convolution layer (e.g. temporal convolution).

  This layer creates a convolution kernel that is convolved
  with the layer input over a single spatial (or temporal) dimension
  to produce a tensor of outputs.
  If `use_bias` is True, a bias vector is created and added to the outputs.
  Finally, if `activation` is not `None`,
  it is applied to the outputs as well.

  When using this layer as the first layer in a model,
  provide an `input_shape` argument
  (tuple of integers or `None`, e.g.
  `(10, 128)` for sequences of 10 vectors of 128-dimensional vectors,
  or `(None, 128)` for variable-length sequences of 128-dimensional vectors.

  Arguments:
    filters: Integer, the dimensionality of the output space
      (i.e. the number of output filters in the convolution).
    kernel_size: An integer or tuple/list of a single integer,
      specifying the length of the 1D convolution window.
    strides: An integer or tuple/list of a single integer,
      specifying the stride length of the convolution.
      Specifying any stride value != 1 is incompatible with specifying
      any `dilation_rate` value != 1.
    padding: One of `"valid"`, `"causal"` or `"same"` (case-insensitive).
      `"causal"` results in causal (dilated) convolutions, e.g. output[t]
      does not depend on input[t+1:]. Useful when modeling temporal data
      where the model should not violate the temporal order.
      See [WaveNet: A Generative Model for Raw Audio, section
        2.1](https://arxiv.org/abs/1609.03499).
    data_format: A string,
      one of `channels_last` (default) or `channels_first`.
    dilation_rate: an integer or tuple/list of a single integer, specifying
      the dilation rate to use for dilated convolution.
      Currently, specifying any `dilation_rate` value != 1 is
      incompatible with specifying any `strides` value != 1.
    activation: Activation function to use.
      If you don't specify anything, no activation is applied
      (ie. "linear" activation: `a(x) = x`).
    use_bias: Boolean, whether the layer uses a bias vector.
    kernel_initializer: Initializer for the `kernel` weights matrix.
    bias_initializer: Initializer for the bias vector.
    kernel_regularizer: Regularizer function applied to
      the `kernel` weights matrix.
    bias_regularizer: Regularizer function applied to the bias vector.
    activity_regularizer: Regularizer function applied to
      the output of the layer (its "activation")..
    kernel_constraint: Constraint function applied to the kernel matrix.
    bias_constraint: Constraint function applied to the bias vector.

  Examples:
    ```python
    # Small convolutional model for 128-length vectors with 6 timesteps
    # model.input_shape == (None, 6, 128)
    
    model = Sequential()
    model.add(Conv1D(32, 3, 
              activation='relu', 
              input_shape=(6, 128)))
    
    # now: model.output_shape == (None, 4, 32)
    ```

  Input shape:
    3D tensor with shape: `(batch_size, steps, input_dim)`

  Output shape:
    3D tensor with shape: `(batch_size, new_steps, filters)`
      `steps` value might have changed due to padding or strides.
  
</pre></div>
</div>
<div class="outline-4" id="outline-container-orgf546ab7">
<h4 id="orgf546ab7">A Pooling Layer</h4>
<div class="outline-text-4" id="text-orgf546ab7">
<div class="highlight">
<pre><span></span>print(tensorflow.keras.layers.GlobalMaxPooling1D.__doc__)
</pre></div>
<pre class="example">
Global max pooling operation for temporal data.

  Arguments:
    data_format: A string,
      one of `channels_last` (default) or `channels_first`.
      The ordering of the dimensions in the inputs.
      `channels_last` corresponds to inputs with shape
      `(batch, steps, features)` while `channels_first`
      corresponds to inputs with shape
      `(batch, features, steps)`.

  Input shape:
    - If `data_format='channels_last'`:
      3D tensor with shape:
      `(batch_size, steps, features)`
    - If `data_format='channels_first'`:
      3D tensor with shape:
      `(batch_size, features, steps)`

  Output shape:
    2D tensor with shape `(batch_size, features)`.
  
</pre></div>
</div>
<div class="outline-4" id="outline-container-org8d4cfe7">
<h4 id="org8d4cfe7">The Fully-Connected Layers</h4>
<div class="outline-text-4" id="text-org8d4cfe7">
<p>Finally our output layers.</p>
<div class="highlight">
<pre><span></span>print(tensorflow.keras.layers.Dense.__doc__)
</pre></div>
<pre class="example">
Just your regular densely-connected NN layer.

  `Dense` implements the operation:
  `output = activation(dot(input, kernel) + bias)`
  where `activation` is the element-wise activation function
  passed as the `activation` argument, `kernel` is a weights matrix
  created by the layer, and `bias` is a bias vector created by the layer
  (only applicable if `use_bias` is `True`).

  Note: If the input to the layer has a rank greater than 2, then
  it is flattened prior to the initial dot product with `kernel`.

  Example:

  ```python
  # as first layer in a sequential model:
  model = Sequential()
  model.add(Dense(32, input_shape=(16,)))
  # now the model will take as input arrays of shape (*, 16)
  # and output arrays of shape (*, 32)

  # after the first layer, you don't need to specify
  # the size of the input anymore:
  model.add(Dense(32))
  ```

  Arguments:
    units: Positive integer, dimensionality of the output space.
    activation: Activation function to use.
      If you don't specify anything, no activation is applied
      (ie. "linear" activation: `a(x) = x`).
    use_bias: Boolean, whether the layer uses a bias vector.
    kernel_initializer: Initializer for the `kernel` weights matrix.
    bias_initializer: Initializer for the bias vector.
    kernel_regularizer: Regularizer function applied to
      the `kernel` weights matrix.
    bias_regularizer: Regularizer function applied to the bias vector.
    activity_regularizer: Regularizer function applied to
      the output of the layer (its "activation")..
    kernel_constraint: Constraint function applied to
      the `kernel` weights matrix.
    bias_constraint: Constraint function applied to the bias vector.

  Input shape:
    N-D tensor with shape: `(batch_size, ..., input_dim)`.
    The most common situation would be
    a 2D input with shape `(batch_size, input_dim)`.

  Output shape:
    N-D tensor with shape: `(batch_size, ..., units)`.
    For instance, for a 2D input with shape `(batch_size, input_dim)`,
    the output would have shape `(batch_size, units)`.
  
</pre></div>
</div>
<div class="outline-4" id="outline-container-org386f454">
<h4 id="org386f454">Build It</h4>
<div class="outline-text-4" id="text-org386f454">
<p>I originally added the layers using the <code>model.add</code> method, but then when I tried to train it the output said the layers didn't have gradients and it never improved… I'll have to look into that, but in the meantime, passing them all in seems to work.</p>
<div class="highlight">
<pre><span></span>model = tensorflow.keras.Sequential([
    tensorflow.keras.layers.Embedding(
        input_dim=Text.vocabulary_size,
        output_dim=Text.embedding_dim,
        input_length=Text.max_length),
    tensorflow.keras.layers.Conv1D(filters=128,
                                   kernel_size=5,
                                   activation='relu'),
    tensorflow.keras.layers.GlobalMaxPooling1D(),
    tensorflow.keras.layers.Dense(24, activation='relu'),
    tensorflow.keras.layers.Dense(1, activation='sigmoid')
])
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org195077c">
<h4 id="org195077c">Compile It</h4>
<div class="outline-text-4" id="text-org195077c">
<div class="highlight">
<pre><span></span>print(model.compile.__doc__)
</pre></div>
<pre class="example">
Configures the model for training.

    Arguments:
        optimizer: String (name of optimizer) or optimizer instance.
            See `tf.keras.optimizers`.
        loss: String (name of objective function), objective function or
            `tf.losses.Loss` instance. See `tf.losses`. If the model has
            multiple outputs, you can use a different loss on each output by
            passing a dictionary or a list of losses. The loss value that will
            be minimized by the model will then be the sum of all individual
            losses.
        metrics: List of metrics to be evaluated by the model during training
            and testing. Typically you will use `metrics=['accuracy']`.
            To specify different metrics for different outputs of a
            multi-output model, you could also pass a dictionary, such as
            `metrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']}`.
            You can also pass a list (len = len(outputs)) of lists of metrics
            such as `metrics=[['accuracy'], ['accuracy', 'mse']]` or
            `metrics=['accuracy', ['accuracy', 'mse']]`.
        loss_weights: Optional list or dictionary specifying scalar
            coefficients (Python floats) to weight the loss contributions
            of different model outputs.
            The loss value that will be minimized by the model
            will then be the *weighted sum* of all individual losses,
            weighted by the `loss_weights` coefficients.
            If a list, it is expected to have a 1:1 mapping
            to the model's outputs. If a tensor, it is expected to map
            output names (strings) to scalar coefficients.
        sample_weight_mode: If you need to do timestep-wise
            sample weighting (2D weights), set this to `"temporal"`.
            `None` defaults to sample-wise weights (1D).
            If the model has multiple outputs, you can use a different
            `sample_weight_mode` on each output by passing a
            dictionary or a list of modes.
        weighted_metrics: List of metrics to be evaluated and weighted
            by sample_weight or class_weight during training and testing.
        target_tensors: By default, Keras will create placeholders for the
            model's target, which will be fed with the target data during
            training. If instead you would like to use your own
            target tensors (in turn, Keras will not expect external
            Numpy data for these targets at training time), you
            can specify them via the `target_tensors` argument. It can be
            a single tensor (for a single-output model), a list of tensors,
            or a dict mapping output names to target tensors.
        distribute: NOT SUPPORTED IN TF 2.0, please create and compile the
            model under distribution strategy scope instead of passing it to
            compile.
        **kwargs: Any additional arguments.

    Raises:
        ValueError: In case of invalid arguments for
            `optimizer`, `loss`, `metrics` or `sample_weight_mode`.
    
</pre>
<div class="highlight">
<pre><span></span>model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
print(model.summary())
</pre></div>
<pre class="example">
Model: "sequential_1"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding_2 (Embedding)      (None, 120, 16)           16000     
_________________________________________________________________
conv1d_1 (Conv1D)            (None, 116, 128)          10368     
_________________________________________________________________
global_max_pooling1d_2 (Glob (None, 128)               0         
_________________________________________________________________
dense_4 (Dense)              (None, 24)                3096      
_________________________________________________________________
dense_5 (Dense)              (None, 1)                 25        
=================================================================
Total params: 29,489
Trainable params: 29,489
Non-trainable params: 0
_________________________________________________________________
None
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org5942f51">
<h3 id="org5942f51">Train It</h3>
<div class="outline-text-3" id="text-org5942f51">
<div class="highlight">
<pre><span></span>print(model.fit.__doc__)
</pre></div>
<pre class="example">
Trains the model for a fixed number of epochs (iterations on a dataset).

    Arguments:
        x: Input data. It could be:
          - A Numpy array (or array-like), or a list of arrays
            (in case the model has multiple inputs).
          - A TensorFlow tensor, or a list of tensors
            (in case the model has multiple inputs).
          - A dict mapping input names to the corresponding array/tensors,
            if the model has named inputs.
          - A `tf.data` dataset. Should return a tuple
            of either `(inputs, targets)` or
            `(inputs, targets, sample_weights)`.
          - A generator or `keras.utils.Sequence` returning `(inputs, targets)`
            or `(inputs, targets, sample weights)`.
        y: Target data. Like the input data `x`,
          it could be either Numpy array(s) or TensorFlow tensor(s).
          It should be consistent with `x` (you cannot have Numpy inputs and
          tensor targets, or inversely). If `x` is a dataset, generator,
          or `keras.utils.Sequence` instance, `y` should
          not be specified (since targets will be obtained from `x`).
        batch_size: Integer or `None`.
            Number of samples per gradient update.
            If unspecified, `batch_size` will default to 32.
            Do not specify the `batch_size` if your data is in the
            form of symbolic tensors, datasets,
            generators, or `keras.utils.Sequence` instances (since they generate
            batches).
        epochs: Integer. Number of epochs to train the model.
            An epoch is an iteration over the entire `x` and `y`
            data provided.
            Note that in conjunction with `initial_epoch`,
            `epochs` is to be understood as "final epoch".
            The model is not trained for a number of iterations
            given by `epochs`, but merely until the epoch
            of index `epochs` is reached.
        verbose: 0, 1, or 2. Verbosity mode.
            0 = silent, 1 = progress bar, 2 = one line per epoch.
            Note that the progress bar is not particularly useful when
            logged to a file, so verbose=2 is recommended when not running
            interactively (eg, in a production environment).
        callbacks: List of `keras.callbacks.Callback` instances.
            List of callbacks to apply during training.
            See `tf.keras.callbacks`.
        validation_split: Float between 0 and 1.
            Fraction of the training data to be used as validation data.
            The model will set apart this fraction of the training data,
            will not train on it, and will evaluate
            the loss and any model metrics
            on this data at the end of each epoch.
            The validation data is selected from the last samples
            in the `x` and `y` data provided, before shuffling. This argument is
            not supported when `x` is a dataset, generator or
           `keras.utils.Sequence` instance.
        validation_data: Data on which to evaluate
            the loss and any model metrics at the end of each epoch.
            The model will not be trained on this data.
            `validation_data` will override `validation_split`.
            `validation_data` could be:
              - tuple `(x_val, y_val)` of Numpy arrays or tensors
              - tuple `(x_val, y_val, val_sample_weights)` of Numpy arrays
              - dataset
            For the first two cases, `batch_size` must be provided.
            For the last case, `validation_steps` must be provided.
        shuffle: Boolean (whether to shuffle the training data
            before each epoch) or str (for 'batch').
            'batch' is a special option for dealing with the
            limitations of HDF5 data; it shuffles in batch-sized chunks.
            Has no effect when `steps_per_epoch` is not `None`.
        class_weight: Optional dictionary mapping class indices (integers)
            to a weight (float) value, used for weighting the loss function
            (during training only).
            This can be useful to tell the model to
            "pay more attention" to samples from
            an under-represented class.
        sample_weight: Optional Numpy array of weights for
            the training samples, used for weighting the loss function
            (during training only). You can either pass a flat (1D)
            Numpy array with the same length as the input samples
            (1:1 mapping between weights and samples),
            or in the case of temporal data,
            you can pass a 2D array with shape
            `(samples, sequence_length)`,
            to apply a different weight to every timestep of every sample.
            In this case you should make sure to specify
            `sample_weight_mode="temporal"` in `compile()`. This argument is not
            supported when `x` is a dataset, generator, or
           `keras.utils.Sequence` instance, instead provide the sample_weights
            as the third element of `x`.
        initial_epoch: Integer.
            Epoch at which to start training
            (useful for resuming a previous training run).
        steps_per_epoch: Integer or `None`.
            Total number of steps (batches of samples)
            before declaring one epoch finished and starting the
            next epoch. When training with input tensors such as
            TensorFlow data tensors, the default `None` is equal to
            the number of samples in your dataset divided by
            the batch size, or 1 if that cannot be determined. If x is a
            `tf.data` dataset, and 'steps_per_epoch'
            is None, the epoch will run until the input dataset is exhausted.
            This argument is not supported with array inputs.
        validation_steps: Only relevant if `validation_data` is provided and
            is a `tf.data` dataset. Total number of steps (batches of
            samples) to draw before stopping when performing validation
            at the end of every epoch. If validation_data is a `tf.data` dataset
            and 'validation_steps' is None, validation
            will run until the `validation_data` dataset is exhausted.
        validation_freq: Only relevant if validation data is provided. Integer
            or `collections_abc.Container` instance (e.g. list, tuple, etc.).
            If an integer, specifies how many training epochs to run before a
            new validation run is performed, e.g. `validation_freq=2` runs
            validation every 2 epochs. If a Container, specifies the epochs on
            which to run validation, e.g. `validation_freq=[1, 2, 10]` runs
            validation at the end of the 1st, 2nd, and 10th epochs.
        max_queue_size: Integer. Used for generator or `keras.utils.Sequence`
            input only. Maximum size for the generator queue.
            If unspecified, `max_queue_size` will default to 10.
        workers: Integer. Used for generator or `keras.utils.Sequence` input
            only. Maximum number of processes to spin up
            when using process-based threading. If unspecified, `workers`
            will default to 1. If 0, will execute the generator on the main
            thread.
        use_multiprocessing: Boolean. Used for generator or
            `keras.utils.Sequence` input only. If `True`, use process-based
            threading. If unspecified, `use_multiprocessing` will default to
            `False`. Note that because this implementation relies on
            multiprocessing, you should not pass non-picklable arguments to
            the generator as they can't be passed easily to children processes.
        **kwargs: Used for backwards compatibility.

    Returns:
        A `History` object. Its `History.history` attribute is
        a record of training loss values and metrics values
        at successive epochs, as well as validation loss values
        and validation metrics values (if applicable).

    Raises:
        RuntimeError: If the model was never compiled.
        ValueError: In case of mismatch between the provided input data
            and what the model expects.
    
</pre>
<div class="highlight">
<pre><span></span>with TIMER:
    history = model.fit(training_padded,
                        y_train.values,
                        epochs=Training.epochs,
                        validation_data=(testing_padded, y_test.values),
                        verbose=Training.verbosity)
</pre></div>
<pre class="example">
2019-09-22 16:30:20,369 graeae.timers.timer start: Started: 2019-09-22 16:30:20.369886
I0922 16:30:20.369913 139873020925760 timer.py:70] Started: 2019-09-22 16:30:20.369886
Train on 20031 samples, validate on 6678 samples
Epoch 1/50
20031/20031 - 5s - loss: 0.4741 - accuracy: 0.7623 - val_loss: 0.4033 - val_accuracy: 0.8146
Epoch 2/50
20031/20031 - 4s - loss: 0.3663 - accuracy: 0.8366 - val_loss: 0.3980 - val_accuracy: 0.8196
Epoch 3/50
20031/20031 - 4s - loss: 0.3306 - accuracy: 0.8554 - val_loss: 0.3909 - val_accuracy: 0.8240
Epoch 4/50
20031/20031 - 4s - loss: 0.2990 - accuracy: 0.8721 - val_loss: 0.4148 - val_accuracy: 0.8179
Epoch 5/50
20031/20031 - 4s - loss: 0.2697 - accuracy: 0.8867 - val_loss: 0.4050 - val_accuracy: 0.8282
Epoch 6/50
20031/20031 - 4s - loss: 0.2406 - accuracy: 0.9003 - val_loss: 0.4291 - val_accuracy: 0.8212
Epoch 7/50
20031/20031 - 4s - loss: 0.2080 - accuracy: 0.9165 - val_loss: 0.4650 - val_accuracy: 0.8181
Epoch 8/50
20031/20031 - 4s - loss: 0.1824 - accuracy: 0.9272 - val_loss: 0.5053 - val_accuracy: 0.8130
Epoch 9/50
20031/20031 - 4s - loss: 0.1559 - accuracy: 0.9393 - val_loss: 0.5389 - val_accuracy: 0.8065
Epoch 10/50
20031/20031 - 4s - loss: 0.1325 - accuracy: 0.9498 - val_loss: 0.6213 - val_accuracy: 0.8044
Epoch 11/50
20031/20031 - 4s - loss: 0.1104 - accuracy: 0.9599 - val_loss: 0.6902 - val_accuracy: 0.8034
Epoch 12/50
20031/20031 - 4s - loss: 0.0966 - accuracy: 0.9646 - val_loss: 0.7437 - val_accuracy: 0.8035
Epoch 13/50
20031/20031 - 4s - loss: 0.0848 - accuracy: 0.9689 - val_loss: 0.8285 - val_accuracy: 0.7954
Epoch 14/50
20031/20031 - 4s - loss: 0.0693 - accuracy: 0.9753 - val_loss: 0.9121 - val_accuracy: 0.7934
Epoch 15/50
20031/20031 - 4s - loss: 0.0608 - accuracy: 0.9777 - val_loss: 1.0783 - val_accuracy: 0.7931
Epoch 16/50
20031/20031 - 4s - loss: 0.0529 - accuracy: 0.9810 - val_loss: 1.0620 - val_accuracy: 0.7889
Epoch 17/50
20031/20031 - 4s - loss: 0.0506 - accuracy: 0.9819 - val_loss: 1.2497 - val_accuracy: 0.7889
Epoch 18/50
20031/20031 - 4s - loss: 0.0471 - accuracy: 0.9821 - val_loss: 1.2518 - val_accuracy: 0.7963
Epoch 19/50
20031/20031 - 4s - loss: 0.0457 - accuracy: 0.9819 - val_loss: 1.3492 - val_accuracy: 0.7917
Epoch 20/50
20031/20031 - 4s - loss: 0.0392 - accuracy: 0.9851 - val_loss: 1.3702 - val_accuracy: 0.7948
Epoch 21/50
20031/20031 - 4s - loss: 0.0357 - accuracy: 0.9860 - val_loss: 1.4300 - val_accuracy: 0.7948
Epoch 22/50
20031/20031 - 4s - loss: 0.0341 - accuracy: 0.9864 - val_loss: 1.5654 - val_accuracy: 0.7889
Epoch 23/50
20031/20031 - 4s - loss: 0.0360 - accuracy: 0.9860 - val_loss: 1.5615 - val_accuracy: 0.7951
Epoch 24/50
20031/20031 - 4s - loss: 0.0307 - accuracy: 0.9872 - val_loss: 1.6964 - val_accuracy: 0.7953
Epoch 25/50
20031/20031 - 4s - loss: 0.0283 - accuracy: 0.9893 - val_loss: 1.6917 - val_accuracy: 0.7920
Epoch 26/50
20031/20031 - 4s - loss: 0.0365 - accuracy: 0.9850 - val_loss: 1.6935 - val_accuracy: 0.7944
Epoch 27/50
20031/20031 - 4s - loss: 0.0342 - accuracy: 0.9851 - val_loss: 1.7912 - val_accuracy: 0.7853
Epoch 28/50
20031/20031 - 4s - loss: 0.0301 - accuracy: 0.9879 - val_loss: 1.8194 - val_accuracy: 0.7887
Epoch 29/50
20031/20031 - 4s - loss: 0.0254 - accuracy: 0.9887 - val_loss: 1.9231 - val_accuracy: 0.7922
Epoch 30/50
20031/20031 - 4s - loss: 0.0216 - accuracy: 0.9910 - val_loss: 1.9480 - val_accuracy: 0.7914
Epoch 31/50
20031/20031 - 4s - loss: 0.0243 - accuracy: 0.9895 - val_loss: 1.9487 - val_accuracy: 0.7847
Epoch 32/50
20031/20031 - 4s - loss: 0.0241 - accuracy: 0.9891 - val_loss: 2.0333 - val_accuracy: 0.7893
Epoch 33/50
20031/20031 - 4s - loss: 0.0334 - accuracy: 0.9863 - val_loss: 1.9498 - val_accuracy: 0.7937
Epoch 34/50
20031/20031 - 4s - loss: 0.0318 - accuracy: 0.9873 - val_loss: 2.0181 - val_accuracy: 0.7942
Epoch 35/50
20031/20031 - 4s - loss: 0.0273 - accuracy: 0.9882 - val_loss: 2.0254 - val_accuracy: 0.7913
Epoch 36/50
20031/20031 - 4s - loss: 0.0236 - accuracy: 0.9897 - val_loss: 2.1159 - val_accuracy: 0.7937
Epoch 37/50
20031/20031 - 4s - loss: 0.0204 - accuracy: 0.9905 - val_loss: 2.1018 - val_accuracy: 0.7950
Epoch 38/50
20031/20031 - 4s - loss: 0.0187 - accuracy: 0.9916 - val_loss: 2.1939 - val_accuracy: 0.7947
Epoch 39/50
20031/20031 - 4s - loss: 0.0253 - accuracy: 0.9888 - val_loss: 2.2090 - val_accuracy: 0.7920
Epoch 40/50
20031/20031 - 4s - loss: 0.0270 - accuracy: 0.9889 - val_loss: 2.2737 - val_accuracy: 0.7862
Epoch 41/50
20031/20031 - 4s - loss: 0.0234 - accuracy: 0.9893 - val_loss: 2.2559 - val_accuracy: 0.7926
Epoch 42/50
20031/20031 - 4s - loss: 0.0223 - accuracy: 0.9902 - val_loss: 2.3223 - val_accuracy: 0.7884
Epoch 43/50
20031/20031 - 4s - loss: 0.0251 - accuracy: 0.9897 - val_loss: 2.2547 - val_accuracy: 0.7863
Epoch 44/50
20031/20031 - 4s - loss: 0.0209 - accuracy: 0.9900 - val_loss: 2.3917 - val_accuracy: 0.7823
Epoch 45/50
20031/20031 - 4s - loss: 0.0245 - accuracy: 0.9889 - val_loss: 2.4222 - val_accuracy: 0.7881
Epoch 46/50
20031/20031 - 4s - loss: 0.0215 - accuracy: 0.9901 - val_loss: 2.4135 - val_accuracy: 0.7869
Epoch 47/50
20031/20031 - 4s - loss: 0.0229 - accuracy: 0.9896 - val_loss: 2.3287 - val_accuracy: 0.7823
Epoch 48/50
20031/20031 - 4s - loss: 0.0191 - accuracy: 0.9918 - val_loss: 2.4639 - val_accuracy: 0.7845
Epoch 49/50
20031/20031 - 4s - loss: 0.0183 - accuracy: 0.9911 - val_loss: 2.6068 - val_accuracy: 0.7811
Epoch 50/50
20031/20031 - 4s - loss: 0.0229 - accuracy: 0.9897 - val_loss: 2.5152 - val_accuracy: 0.7928
2019-09-22 16:33:41,089 graeae.timers.timer end: Ended: 2019-09-22 16:33:41.089405
I0922 16:33:41.089459 139873020925760 timer.py:77] Ended: 2019-09-22 16:33:41.089405
2019-09-22 16:33:41,091 graeae.timers.timer end: Elapsed: 0:03:20.719519
I0922 16:33:41.091247 139873020925760 timer.py:78] Elapsed: 0:03:20.719519
</pre>
<p>Once again it looks like the model is overfitting, I should add a checkpoint or something.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgb5b8e5c">
<h3 id="orgb5b8e5c">Plot the Performance</h3>
<div class="outline-text-3" id="text-orgb5b8e5c">
<div class="highlight">
<pre><span></span>performance = pandas.DataFrame(history.history)
plot = performance.hvplot().opts(title="CNN Sarcasm Training Performance",
                                 width=1000,
                                 height=800)
Embed(plot=plot, file_name="cnn_training")()
</pre></div>
<object data="/posts/keras/he-used-sarcasm/cnn_training.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<p>There's something very wrong with the validation. I'll have to look into that.</p>
<div class="highlight">
<pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org71c3adf">
<h2 id="org71c3adf">End</h2>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/keras/multi-layer-lstm/">Multi-Layer LSTM</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/keras/multi-layer-lstm/" rel="bookmark"><time class="published dt-published" datetime="2019-09-19T16:07:27-07:00" itemprop="datePublished" title="2019-09-19 16:07">2019-09-19 16:07</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/keras/multi-layer-lstm/#orgb12e436">Beginning</a>
<ul>
<li><a href="/posts/keras/multi-layer-lstm/#org01487f8">Imports</a>
<ul>
<li><a href="/posts/keras/multi-layer-lstm/#org1f15f87">Python</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#org03b103e">PyPi</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#orgbd3b2d5">Others</a></li>
</ul>
</li>
<li><a href="/posts/keras/multi-layer-lstm/#orgb3ddb56">Set Up</a>
<ul>
<li><a href="/posts/keras/multi-layer-lstm/#org99f7894">The Timer</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#orgaa00da2">Plotting</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#org67642ea">The Dataset</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/multi-layer-lstm/#orgbb719fa">Middle</a>
<ul>
<li><a href="/posts/keras/multi-layer-lstm/#org8fb6f67">Set Up the Datasets</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#orga75455e">The Model</a>
<ul>
<li><a href="/posts/keras/multi-layer-lstm/#org0b6a562">Embedding</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#org94c90d6">Bidirectional</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#org9f68728">LSTM</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#orgec4b1a5">Compile It</a></li>
</ul>
</li>
<li><a href="/posts/keras/multi-layer-lstm/#orgce4a691">Train the Model</a></li>
<li><a href="/posts/keras/multi-layer-lstm/#orgd6e9d83">Looking at the Performance</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgb12e436">
<h2 id="orgb12e436">Beginning</h2>
<div class="outline-text-2" id="text-orgb12e436"></div>
<div class="outline-3" id="outline-container-org01487f8">
<h3 id="org01487f8">Imports</h3>
<div class="outline-text-3" id="text-org01487f8"></div>
<div class="outline-4" id="outline-container-org1f15f87">
<h4 id="org1f15f87">Python</h4>
<div class="outline-text-4" id="text-org1f15f87">
<div class="highlight">
<pre><span></span>from functools import partial
from pathlib import Path
import pickle
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org03b103e">
<h4 id="org03b103e">PyPi</h4>
<div class="outline-text-4" id="text-org03b103e">
<div class="highlight">
<pre><span></span>import holoviews
import hvplot.pandas
import pandas
import tensorflow
import tensorflow_datasets
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgbd3b2d5">
<h4 id="orgbd3b2d5">Others</h4>
<div class="outline-text-4" id="text-orgbd3b2d5">
<div class="highlight">
<pre><span></span>from graeae import Timer, EmbedHoloviews
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgb3ddb56">
<h3 id="orgb3ddb56">Set Up</h3>
<div class="outline-text-3" id="text-orgb3ddb56"></div>
<div class="outline-4" id="outline-container-org99f7894">
<h4 id="org99f7894">The Timer</h4>
<div class="outline-text-4" id="text-org99f7894">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgaa00da2">
<h4 id="orgaa00da2">Plotting</h4>
<div class="outline-text-4" id="text-orgaa00da2">
<div class="highlight">
<pre><span></span>Embed = partial(EmbedHoloviews,
                folder_path="../../files/posts/keras/multi-layer-lstm/")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org67642ea">
<h4 id="org67642ea">The Dataset</h4>
<div class="outline-text-4" id="text-org67642ea">
<p>This once again uses the <a href="https://www.tensorflow.org/datasets/catalog/imdb_reviews">IMDB dataset</a> with 50,000 reviews. It has already been converted from strings to integers - each word is encoded as its own integer. Adding <code>with_info=True</code> returns an object that contains the dictionary with the word to integer mapping. Passing in <code>imdb_reviews/subwords8k</code> limits the vocabulary to 8,000 words.</p>
<p><b>Note:</b> The first time you run this it will download a fairly large dataset so it might appear to hang, but after the first time it is fairly quick.</p>
<div class="highlight">
<pre><span></span>dataset, info = tensorflow_datasets.load("imdb_reviews/subwords8k",
                                         with_info=True,
                                         as_supervised=True)
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgbb719fa">
<h2 id="orgbb719fa">Middle</h2>
<div class="outline-text-2" id="text-orgbb719fa"></div>
<div class="outline-3" id="outline-container-org8fb6f67">
<h3 id="org8fb6f67">Set Up the Datasets</h3>
<div class="outline-text-3" id="text-org8fb6f67">
<div class="highlight">
<pre><span></span>train_dataset, test_dataset = dataset["train"], dataset["test"]
tokenizer = info.features['text'].encoder
</pre></div>
<p>Now we're going to shuffle and padd the data. The <code>BUFFER_SIZE</code> argument sets the size of the data to sample from. In this case 10,000 entries in the training set will be selected to be put in the buffer and then the "shuffle" is created by randomly selecting items from the buffer, replacing each item as it's selected until all the data has been through the buffer. The <code>padded_batch</code> method creates batches of consecutive data and pads them so that they are all the same shape.</p>
<p>The BATCH_SIZE needs to be tuned a little. If it's too big the amount of memory needed might keep the GPU from being able to use it (and it might not generalize), and if it's too small, you will take a long time to train, so you have to do a little tuning. If you train it and the GPU process percentage stays at 0, try reducing the Batch Size.</p>
<p>Also note that if you change the batch-size you have to go back to the previous step and re-define <code>train_dataset</code> and <code>test_dataset</code> because we alter them in the next step and re-altering them makes the shape wrong somehow.</p>
<div class="highlight">
<pre><span></span>BUFFER_SIZE = 10000
# if the batch size is too big it will run out of memory on the GPU 
# so you might have to experiment with this
BATCH_SIZE = 32

train_dataset = train_dataset.shuffle(BUFFER_SIZE)
train_dataset = train_dataset.padded_batch(BATCH_SIZE, train_dataset.output_shapes)
test_dataset = test_dataset.padded_batch(BATCH_SIZE, test_dataset.output_shapes)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orga75455e">
<h3 id="orga75455e">The Model</h3>
<div class="outline-text-3" id="text-orga75455e">
<p>The previous model had one Bidirectional layer, this will add a second one.</p>
</div>
<div class="outline-4" id="outline-container-org0b6a562">
<h4 id="org0b6a562">Embedding</h4>
<div class="outline-text-4" id="text-org0b6a562">
<p>The <a href="https://www.tensorflow.org/guide/embedding">Embedding layer</a> converts our inputs of integers and converts them to vectors of real-numbers, which is a better input for a neural network.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org94c90d6">
<h4 id="org94c90d6">Bidirectional</h4>
<div class="outline-text-4" id="text-org94c90d6">
<p>The <a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Bidirectional">Bidirectional layer</a> is a wrapper for Recurrent Neural Networks.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org9f68728">
<h4 id="org9f68728">LSTM</h4>
<div class="outline-text-4" id="text-org9f68728">
<p>The <a href="https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/keras/layers/LSTM">LSTM layer</a> implements Long-Short-Term Memory. The first argument is the size of the outputs. This is similar to the model that we ran previously on the same data, but it has an extra layer (so it uses more memory).</p>
<div class="highlight">
<pre><span></span>model = tensorflow.keras.Sequential([
    tensorflow.keras.layers.Embedding(tokenizer.vocab_size, 64),
    tensorflow.keras.layers.Bidirectional(
        tensorflow.keras.layers.LSTM(64, return_sequences=True)),
    tensorflow.keras.layers.Bidirectional(
        tensorflow.keras.layers.LSTM(32)),
    tensorflow.keras.layers.Dense(64, activation='relu'),
    tensorflow.keras.layers.Dense(1, activation='sigmoid')
])
</pre></div>
<div class="highlight">
<pre><span></span>print(model.summary())
</pre></div>
<pre class="example">
Model: "sequential"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding (Embedding)        (None, None, 64)          523840    
_________________________________________________________________
bidirectional (Bidirectional (None, None, 128)         66048     
_________________________________________________________________
bidirectional_1 (Bidirection (None, 64)                41216     
_________________________________________________________________
dense (Dense)                (None, 64)                4160      
_________________________________________________________________
dense_1 (Dense)              (None, 1)                 65        
=================================================================
Total params: 635,329
Trainable params: 635,329
Non-trainable params: 0
_________________________________________________________________
None
</pre></div>
</div>
<div class="outline-4" id="outline-container-orgec4b1a5">
<h4 id="orgec4b1a5">Compile It</h4>
<div class="outline-text-4" id="text-orgec4b1a5">
<div class="highlight">
<pre><span></span>model.compile(loss='binary_crossentropy',
              optimizer="adam",
              metrics=['accuracy'])
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgce4a691">
<h3 id="orgce4a691">Train the Model</h3>
<div class="outline-text-3" id="text-orgce4a691">
<div class="highlight">
<pre><span></span>ONCE_PER_EPOCH = 2
NUM_EPOCHS = 10
with TIMER:
    history = model.fit(train_dataset,
                        epochs=NUM_EPOCHS,
                        validation_data=test_dataset,
                        verbose=ONCE_PER_EPOCH)
</pre></div>
<pre class="example">
2019-09-21 17:26:50,395 graeae.timers.timer start: Started: 2019-09-21 17:26:50.394797
I0921 17:26:50.395130 140275698915136 timer.py:70] Started: 2019-09-21 17:26:50.394797
Epoch 1/10
W0921 17:26:51.400280 140275698915136 deprecation.py:323] From /home/hades/.virtualenvs/In-Too-Deep/lib/python3.7/site-packages/tensorflow_core/python/ops/nn_impl.py:183: where (from tensorflow.python.ops.array_ops) is deprecated and will be removed in a future version.
Instructions for updating:
Use tf.where in 2.0, which has the same broadcast rule as np.where
782/782 - 224s - loss: 0.6486 - accuracy: 0.6039 - val_loss: 0.0000e+00 - val_accuracy: 0.0000e+00
Epoch 2/10
782/782 - 214s - loss: 0.4941 - accuracy: 0.7661 - val_loss: 0.6706 - val_accuracy: 0.6744
Epoch 3/10
782/782 - 216s - loss: 0.4087 - accuracy: 0.8266 - val_loss: 0.4024 - val_accuracy: 0.8222
Epoch 4/10
782/782 - 217s - loss: 0.2855 - accuracy: 0.8865 - val_loss: 0.3343 - val_accuracy: 0.8645
Epoch 5/10
782/782 - 216s - loss: 0.2097 - accuracy: 0.9217 - val_loss: 0.2936 - val_accuracy: 0.8837
Epoch 6/10
782/782 - 217s - loss: 0.1526 - accuracy: 0.9467 - val_loss: 0.3188 - val_accuracy: 0.8771
Epoch 7/10
782/782 - 215s - loss: 0.1048 - accuracy: 0.9657 - val_loss: 0.3750 - val_accuracy: 0.8710
Epoch 8/10
782/782 - 216s - loss: 0.0764 - accuracy: 0.9757 - val_loss: 0.3821 - val_accuracy: 0.8762
Epoch 9/10
782/782 - 216s - loss: 0.0585 - accuracy: 0.9832 - val_loss: 0.4747 - val_accuracy: 0.8683
Epoch 10/10
782/782 - 216s - loss: 0.0438 - accuracy: 0.9883 - val_loss: 0.4441 - val_accuracy: 0.8704
2019-09-21 18:02:56,353 graeae.timers.timer end: Ended: 2019-09-21 18:02:56.353722
I0921 18:02:56.353781 140275698915136 timer.py:77] Ended: 2019-09-21 18:02:56.353722
2019-09-21 18:02:56,356 graeae.timers.timer end: Elapsed: 0:36:05.958925
I0921 18:02:56.356238 140275698915136 timer.py:78] Elapsed: 0:36:05.958925
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgd6e9d83">
<h3 id="orgd6e9d83">Looking at the Performance</h3>
<div class="outline-text-3" id="text-orgd6e9d83">
<p>To get the history I had to pickle it and then copy it over to the machine with this org-notebook, so you can't just run this notebook and make it work unless everything is run on the same machine (which it wasn't).</p>
<div class="highlight">
<pre><span></span>path = Path("~/history.pkl").expanduser()
with path.open("wb") as writer:
    pickle.dump(history.history, writer)
</pre></div>
<div class="highlight">
<pre><span></span>path = Path("~/history.pkl").expanduser()
with path.open("rb") as reader:
    history = pickle.load(reader)
</pre></div>
<div class="highlight">
<pre><span></span>data = pandas.DataFrame(history)
best = data.val_loss.idxmin()
best_line = holoviews.VLine(best)
plot = (data.hvplot() * best_line).opts(
    title="Two-Layer LSTM Model",
    width=1000,
    height=800)
Embed(plot=plot, file_name="lstm_training")()
</pre></div>
<object data="/posts/keras/multi-layer-lstm/lstm_training.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<p>It looks like the best epoch was the fifth one, with a validation loss of 0.29 and a validation accuracy of 0.88, after that it looks like it overfits. It seems that text might be a harder problem than images.</p>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/keras/imdb-reviews-tensorflow-dataset/">IMDB Reviews Tensorflow Dataset</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/keras/imdb-reviews-tensorflow-dataset/" rel="bookmark"><time class="published dt-published" datetime="2019-09-09T16:24:46-07:00" itemprop="datePublished" title="2019-09-09 16:24">2019-09-09 16:24</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org8fbfa99">Beginning</a>
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org57b4c0c">Imports</a>
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org5031863">Python</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org7112ec7">PyPi</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org6043e04">Graeae</a></li>
</ul>
</li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org1c3a4cc">Set Up</a>
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org32ac284">Plotting</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org9ddfee5">Timer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org46583a7">Middle</a>
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#orgdd5f87d">Get the Dataset</a>
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org8fa174d">Load It</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org7f6f438">Split It</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org808a294">The Tokenizer</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#orgba55015">Set Up Data</a></li>
</ul>
</li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org0d2ed39">The Model</a>
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org99ac84a">Compile It</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org3ed7a59">Train It</a></li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org8f0e54f">Plot the Performance</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org360dae3">End</a>
<ul>
<li><a href="/posts/keras/imdb-reviews-tensorflow-dataset/#org9efad09">Citation</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org8fbfa99">
<h2 id="org8fbfa99">Beginning</h2>
<div class="outline-text-2" id="text-org8fbfa99">
<p>We're going to use the <a href="https://www.tensorflow.org/datasets/catalog/imdb_reviews">IMDB Reviews Dataset</a> (used in <a href="https://www.tensorflow.org/tutorials/keras/basic_text_classification">this tutorial</a>) - a set of 50,000 movie reviews taken from the <a href="https://www.imdb.com/">Internet Movie Database</a> that have been classified as either positive or negative. It looks like the original source is from a page on Stanford University's web sight title <a href="http://ai.stanford.edu/~amaas/data/sentiment/">Large Movie Review Dataset</a>. The dataset seems to be widely available (the Stanford page and <a href="https://www.kaggle.com/lakshmi25npathi/imdb-dataset-of-50k-movie-reviews">Kaggle</a> for instance) but this will serve as practice for using tensorflow datasets as well.</p>
</div>
<div class="outline-3" id="outline-container-org57b4c0c">
<h3 id="org57b4c0c">Imports</h3>
<div class="outline-text-3" id="text-org57b4c0c"></div>
<div class="outline-4" id="outline-container-org5031863">
<h4 id="org5031863">Python</h4>
<div class="outline-text-4" id="text-org5031863">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org7112ec7">
<h4 id="org7112ec7">PyPi</h4>
<div class="outline-text-4" id="text-org7112ec7">
<div class="highlight">
<pre><span></span><span class="kn">import</span> <span class="nn">hvplot.pandas</span>
<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">import</span> <span class="nn">tensorflow</span>
<span class="kn">import</span> <span class="nn">tensorflow_datasets</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6043e04">
<h4 id="org6043e04">Graeae</h4>
<div class="outline-text-4" id="text-org6043e04">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">graeae</span> <span class="kn">import</span> <span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">Timer</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org1c3a4cc">
<h3 id="org1c3a4cc">Set Up</h3>
<div class="outline-text-3" id="text-org1c3a4cc"></div>
<div class="outline-4" id="outline-container-org32ac284">
<h4 id="org32ac284">Plotting</h4>
<div class="outline-text-4" id="text-org32ac284">
<div class="highlight">
<pre><span></span><span class="n">SLUG</span> <span class="o">=</span> <span class="s2">"imdb-reviews-tensorflow-dataset"</span>
<span class="n">Embed</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">EmbedHoloviews</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="n">f</span><span class="s2">"../../files/posts/keras/{SLUG}"</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9ddfee5">
<h4 id="org9ddfee5">Timer</h4>
<div class="outline-text-4" id="text-org9ddfee5">
<div class="highlight">
<pre><span></span><span class="n">TIMER</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org46583a7">
<h2 id="org46583a7">Middle</h2>
<div class="outline-text-2" id="text-org46583a7"></div>
<div class="outline-3" id="outline-container-orgdd5f87d">
<h3 id="orgdd5f87d">Get the Dataset</h3>
<div class="outline-text-3" id="text-orgdd5f87d"></div>
<div class="outline-4" id="outline-container-org8fa174d">
<h4 id="org8fa174d">Load It</h4>
<div class="outline-text-4" id="text-org8fa174d">
<p>The <a href="https://www.tensorflow.org/datasets/api_docs/python/tfds/load">load</a> function takes quite a few parameters, in this case we're just passing in three - the name of the dataset, <code>with_info</code> which tells it to return both a <a href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset">Dataset</a> and a <a href="https://www.tensorflow.org/datasets/api_docs/python/tfds/core/DatasetInfo">DatasetInfo</a> object, and <code>as_supervised</code>, which tells the builder to return the <code>Dataset</code> as a series of <code>(input, label)</code> tuples.</p>
<div class="highlight">
<pre><span></span><span class="n">dataset</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">tensorflow_datasets</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">'imdb_reviews/subwords8k'</span><span class="p">,</span>
                                         <span class="n">with_info</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                         <span class="n">as_supervised</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org7f6f438">
<h4 id="org7f6f438">Split It</h4>
<div class="outline-text-4" id="text-org7f6f438">
<p>The <code>dataset</code> is a dict with three keys:</p>
<div class="highlight">
<pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
<pre class="example">
dict_keys(['test', 'train', 'unsupervised'])
</pre>
<p>As you might guess, we don't use the <code>unsupervised</code> key.</p>
<div class="highlight">
<pre><span></span><span class="n">train_dataset</span><span class="p">,</span> <span class="n">test_dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">'train'</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">'test'</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org808a294">
<h4 id="org808a294">The Tokenizer</h4>
<div class="outline-text-4" id="text-org808a294">
<p>One of the advantages of using the tensorflow dataset version of this is that it comes with a pre-built tokenizer inside the DatasetInfo object.</p>
<div class="highlight">
<pre><span></span><span class="k">print</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">features</span><span class="p">)</span>
</pre></div>
<pre class="example">
FeaturesDict({
    'label': ClassLabel(shape=(), dtype=tf.int64, num_classes=2),
    'text': Text(shape=(None,), dtype=tf.int64, encoder=&lt;SubwordTextEncoder vocab_size=8185&gt;),
})
</pre>
<div class="highlight">
<pre><span></span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">features</span><span class="p">[</span><span class="s1">'text'</span><span class="p">]</span><span class="o">.</span><span class="n">encoder</span>
<span class="k">print</span><span class="p">(</span><span class="n">tokenizer</span><span class="p">)</span>
</pre></div>
<pre class="example">
&lt;SubwordTextEncoder vocab_size=8185&gt;
</pre>
<p>The <code>tokenizer</code> is a <a href="https://www.tensorflow.org/datasets/api_docs/python/tfds/features/text/SubwordTextEncoder">SubwordTextEncoder</a> with a vocabulary size of 8,185.</p>
</div>
</div>
<div class="outline-4" id="outline-container-orgba55015">
<h4 id="orgba55015">Set Up Data</h4>
<div class="outline-text-4" id="text-orgba55015">
<p>We're going to shuffle the training data and then add padding to both sets so theyre all the same size.</p>
<div class="highlight">
<pre><span></span><span class="n">BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">train_dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">)</span>
<span class="n">train_dataset</span> <span class="o">=</span> <span class="n">train_dataset</span><span class="o">.</span><span class="n">padded_batch</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">,</span> <span class="n">train_dataset</span><span class="o">.</span><span class="n">output_shapes</span><span class="p">)</span>
<span class="n">test_dataset</span> <span class="o">=</span> <span class="n">test_dataset</span><span class="o">.</span><span class="n">padded_batch</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">,</span> <span class="n">test_dataset</span><span class="o">.</span><span class="n">output_shapes</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org0d2ed39">
<h3 id="org0d2ed39">The Model</h3>
<div class="outline-text-3" id="text-org0d2ed39">
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">tensorflow</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">tensorflow</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="n">vocab_size</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
    <span class="n">tensorflow</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Bidirectional</span><span class="p">(</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">LSTM</span><span class="p">(</span><span class="mi">64</span><span class="p">)),</span>
    <span class="n">tensorflow</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">'relu'</span><span class="p">),</span>
    <span class="n">tensorflow</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">'sigmoid'</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
</pre></div>
<pre class="example">
Model: "sequential"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding (Embedding)        (None, None, 64)          523840    
_________________________________________________________________
bidirectional (Bidirectional (None, 128)               66048     
_________________________________________________________________
dense (Dense)                (None, 64)                8256      
_________________________________________________________________
dense_1 (Dense)              (None, 1)                 65        
=================================================================
Total params: 598,209
Trainable params: 598,209
Non-trainable params: 0
_________________________________________________________________
</pre></div>
<div class="outline-4" id="outline-container-org99ac84a">
<h4 id="org99ac84a">Compile It</h4>
<div class="outline-text-4" id="text-org99ac84a">
<div class="highlight">
<pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s1">'binary_crossentropy'</span><span class="p">,</span>
              <span class="n">optimizer</span><span class="o">=</span><span class="s1">'adam'</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">'accuracy'</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org3ed7a59">
<h4 id="org3ed7a59">Train It</h4>
<div class="outline-text-4" id="text-org3ed7a59">
<div class="highlight">
<pre><span></span><span class="n">EPOCHS</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">SILENT</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ONCE_PER_EPOCH</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">with</span> <span class="n">TIMER</span><span class="p">:</span>
    <span class="n">history</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_dataset</span><span class="p">,</span>
                        <span class="n">epochs</span><span class="o">=</span><span class="n">EPOCHS</span><span class="p">,</span>
                        <span class="n">validation_data</span><span class="o">=</span><span class="n">test_dataset</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">ONCE_PER_EPOCH</span><span class="p">)</span>
</pre></div>
<pre class="example">
2019-09-21 15:52:50,469 graeae.timers.timer start: Started: 2019-09-21 15:52:50.469787
I0921 15:52:50.469841 140086305412928 timer.py:70] Started: 2019-09-21 15:52:50.469787
Epoch 1/10
391/391 - 80s - loss: 0.3991 - accuracy: 0.8377 - val_loss: 0.0000e+00 - val_accuracy: 0.0000e+00
Epoch 2/10
391/391 - 80s - loss: 0.3689 - accuracy: 0.8571 - val_loss: 0.4595 - val_accuracy: 0.8021
Epoch 3/10
391/391 - 80s - loss: 0.3664 - accuracy: 0.8444 - val_loss: 0.5262 - val_accuracy: 0.7228
Epoch 4/10
391/391 - 80s - loss: 0.5611 - accuracy: 0.7133 - val_loss: 0.6832 - val_accuracy: 0.6762
Epoch 5/10
391/391 - 80s - loss: 0.6151 - accuracy: 0.6597 - val_loss: 0.5164 - val_accuracy: 0.7844
Epoch 6/10
391/391 - 80s - loss: 0.3842 - accuracy: 0.8340 - val_loss: 0.4970 - val_accuracy: 0.7996
Epoch 7/10
391/391 - 80s - loss: 0.2449 - accuracy: 0.9058 - val_loss: 0.3639 - val_accuracy: 0.8463
Epoch 8/10
391/391 - 80s - loss: 0.1896 - accuracy: 0.9306 - val_loss: 0.3698 - val_accuracy: 0.8614
Epoch 9/10
391/391 - 80s - loss: 0.1555 - accuracy: 0.9456 - val_loss: 0.3896 - val_accuracy: 0.8535
Epoch 10/10
391/391 - 80s - loss: 0.1195 - accuracy: 0.9606 - val_loss: 0.4878 - val_accuracy: 0.8428
2019-09-21 16:06:09,935 graeae.timers.timer end: Ended: 2019-09-21 16:06:09.935707
I0921 16:06:09.935745 140086305412928 timer.py:77] Ended: 2019-09-21 16:06:09.935707
2019-09-21 16:06:09,938 graeae.timers.timer end: Elapsed: 0:13:19.465920
I0921 16:06:09.938812 140086305412928 timer.py:78] Elapsed: 0:13:19.465920
</pre></div>
</div>
<div class="outline-4" id="outline-container-org8f0e54f">
<h4 id="org8f0e54f">Plot the Performance</h4>
<div class="outline-text-4" id="text-org8f0e54f">
<ul class="org-ul">
<li><b>Note</b>: This only works if your kernel is on the local machine, running it remotely gives an error, as it tries to save it on the remote machine.</li>
</ul>
<div class="highlight">
<pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">history</span><span class="o">.</span><span class="n">history</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">"loss"</span><span class="p">:</span> <span class="s2">"Training Loss"</span><span class="p">,</span>
                            <span class="s2">"accuracy"</span><span class="p">:</span> <span class="s2">"Training Accuracy"</span><span class="p">,</span>
                            <span class="s2">"val_loss"</span><span class="p">:</span> <span class="s2">"Validation Loss"</span><span class="p">,</span>
                            <span class="s2">"val_accuracy"</span><span class="p">:</span> <span class="s2">"Validation Accuracy"</span><span class="p">})</span>
<span class="n">plot</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">hvplot</span><span class="p">()</span><span class="o">.</span><span class="n">opts</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s2">"LSTM IMDB Performance"</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>
<span class="n">Embed</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">"model_performance"</span><span class="p">)()</span>
</pre></div>
<object data="/posts/keras/imdb-reviews-tensorflow-dataset/model_performance.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<p>It looks like I over-trained it, as the loss is getting high. (Also note that I used this notebook to troubleshoot so there was actually one extra epoch that isn't shown).</p>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org360dae3">
<h2 id="org360dae3">End</h2>
<div class="outline-text-2" id="text-org360dae3"></div>
<div class="outline-3" id="outline-container-org9efad09">
<h3 id="org9efad09">Citation</h3>
<div class="outline-text-3" id="text-org9efad09">
<p>This is the paper where the dataset was originally used.</p>
<ul class="org-ul">
<li>Andrew L. Maas, Raymond E. Daly, Peter T. Pham, Dan Huang, Andrew Y. Ng, and Christopher Potts. (2011). Learning Word Vectors for Sentiment Analysis. The 49th Annual Meeting of the Association for Computational Linguistics (ACL 2011).</li>
</ul>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="/posts/keras/bbc-news-classification/">BBC News Classification</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/keras/bbc-news-classification/" rel="bookmark"><time class="published dt-published" datetime="2019-08-26T15:28:56-07:00" itemprop="datePublished" title="2019-08-26 15:28">2019-08-26 15:28</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/keras/bbc-news-classification/#org38ee150">Beginning</a>
<ul>
<li><a href="/posts/keras/bbc-news-classification/#orgcee04a6">Imports</a>
<ul>
<li><a href="/posts/keras/bbc-news-classification/#orge627f09">Python</a></li>
<li><a href="/posts/keras/bbc-news-classification/#org0f97fe9">PyPi</a></li>
<li><a href="/posts/keras/bbc-news-classification/#org8d1eee4">Graeae</a></li>
</ul>
</li>
<li><a href="/posts/keras/bbc-news-classification/#orge25b1e8">Setup</a>
<ul>
<li><a href="/posts/keras/bbc-news-classification/#org18971fd">The Timer</a></li>
<li><a href="/posts/keras/bbc-news-classification/#org6bdab2d">The Environment</a></li>
<li><a href="/posts/keras/bbc-news-classification/#org857db46">Spacy</a></li>
<li><a href="/posts/keras/bbc-news-classification/#org6c8b6e8">Plotting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/posts/keras/bbc-news-classification/#org9d3fb8d">Middle</a>
<ul>
<li><a href="/posts/keras/bbc-news-classification/#org2de0b99">Load the Datasets</a></li>
<li><a href="/posts/keras/bbc-news-classification/#org1abc976">The Tokenizers</a></li>
<li><a href="/posts/keras/bbc-news-classification/#orgf89f739">Making the Sequences</a></li>
<li><a href="/posts/keras/bbc-news-classification/#orgbc6c887">Make training and testing sets</a></li>
<li><a href="/posts/keras/bbc-news-classification/#orgcd744cd">The Model</a></li>
<li><a href="/posts/keras/bbc-news-classification/#orgde3f2a1">Plotting the Performance</a></li>
</ul>
</li>
<li><a href="/posts/keras/bbc-news-classification/#org8386b26">End</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org38ee150">
<h2 id="org38ee150">Beginning</h2>
<div class="outline-text-2" id="text-org38ee150"></div>
<div class="outline-3" id="outline-container-orgcee04a6">
<h3 id="orgcee04a6">Imports</h3>
<div class="outline-text-3" id="text-orgcee04a6"></div>
<div class="outline-4" id="outline-container-orge627f09">
<h4 id="orge627f09">Python</h4>
<div class="outline-text-4" id="text-orge627f09">
<div class="highlight">
<pre><span></span>from functools import partial
from pathlib import Path
import csv
import random
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org0f97fe9">
<h4 id="org0f97fe9">PyPi</h4>
<div class="outline-text-4" id="text-org0f97fe9">
<div class="highlight">
<pre><span></span>from sklearn.model_selection import train_test_split
from tensorflow.keras import layers
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
import hvplot.pandas
import numpy
import pandas
import spacy
import tensorflow
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org8d1eee4">
<h4 id="org8d1eee4">Graeae</h4>
<div class="outline-text-4" id="text-org8d1eee4">
<div class="highlight">
<pre><span></span>from graeae import EmbedHoloviews, SubPathLoader, Timer
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orge25b1e8">
<h3 id="orge25b1e8">Setup</h3>
<div class="outline-text-3" id="text-orge25b1e8"></div>
<div class="outline-4" id="outline-container-org18971fd">
<h4 id="org18971fd">The Timer</h4>
<div class="outline-text-4" id="text-org18971fd">
<div class="highlight">
<pre><span></span>TIMER = Timer()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6bdab2d">
<h4 id="org6bdab2d">The Environment</h4>
<div class="outline-text-4" id="text-org6bdab2d">
<div class="highlight">
<pre><span></span>ENVIRONMENT = SubPathLoader('DATASETS')
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org857db46">
<h4 id="org857db46">Spacy</h4>
<div class="outline-text-4" id="text-org857db46">
<div class="highlight">
<pre><span></span>spacy.prefer_gpu()
nlp = spacy.load("en_core_web_lg")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6c8b6e8">
<h4 id="org6c8b6e8">Plotting</h4>
<div class="outline-text-4" id="text-org6c8b6e8">
<div class="highlight">
<pre><span></span>SLUG = "bbc-news-classification"
Embed = partial(EmbedHoloviews, folder_path=f"../../files/posts/keras/{SLUG}")
</pre></div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org9d3fb8d">
<h2 id="org9d3fb8d">Middle</h2>
<div class="outline-text-2" id="text-org9d3fb8d"></div>
<div class="outline-3" id="outline-container-org2de0b99">
<h3 id="org2de0b99">Load the Datasets</h3>
<div class="outline-text-3" id="text-org2de0b99">
<div class="highlight">
<pre><span></span>path = Path(ENVIRONMENT["BBC_NEWS"]).expanduser()

texts = []
labels = []
with TIMER:
    with path.open() as csvfile:
        lines = csv.DictReader(csvfile)
        for line in lines:
            labels.append(line["category"])
            texts.append(nlp(line["text"]))
</pre></div>
<pre class="example">
WARNING: Logging before flag parsing goes to stderr.
I0908 13:32:14.804769 139839933974336 environment.py:35] Environment Path: /home/athena/.env
I0908 13:32:14.806000 139839933974336 environment.py:90] Environment Path: /home/athena/.config/datasets/env
2019-09-08 13:32:14,806 graeae.timers.timer start: Started: 2019-09-08 13:32:14.806861
I0908 13:32:14.806965 139839933974336 timer.py:70] Started: 2019-09-08 13:32:14.806861
2019-09-08 13:33:37,430 graeae.timers.timer end: Ended: 2019-09-08 13:33:37.430228
I0908 13:33:37.430259 139839933974336 timer.py:77] Ended: 2019-09-08 13:33:37.430228
2019-09-08 13:33:37,431 graeae.timers.timer end: Elapsed: 0:01:22.623367
I0908 13:33:37.431128 139839933974336 timer.py:78] Elapsed: 0:01:22.623367

</pre>
<div class="highlight">
<pre><span></span>print(texts[random.randrange(len(texts))])
</pre></div>
<pre class="example">
candidate resigns over bnp link a prospective candidate for the uk independence party (ukip) has resigned after admitting a  brief attachment  to the british national party(bnp).  nicholas betts-green  who had been selected to fight the suffolk coastal seat  quit after reports in a newspaper that he attended a bnp meeting. the former teacher confirmed he had attended the meeting but said that was the only contact he had with the group. mr betts-green resigned after being questioned by the party s leadership. a ukip spokesman said mr betts-green s resignation followed disclosures in the east anglian daily times last month about his attendance at a bnp meeting.  he did once attend a bnp meeting. he did not like what he saw and heard and will take no further part of it   the spokesman added. a meeting of suffolk coastal ukip members is due to be held next week to discuss a replacement. mr betts-green  of woodbridge  suffolk  has also resigned as ukip s branch chairman.

</pre>
<p>So, it looks like the text has been lower-cased but there's still punctuation and extra white-space.</p>
<div class="highlight">
<pre><span></span>print(f"Rows: {len(labels):,}")
print(f"Unique Labels: {len(set(labels)):,}")
</pre></div>
<pre class="example">
Rows: 2,225
Unique Labels: 5

</pre>
<p>Since there's only five maybe we should plot it.</p>
<div class="highlight">
<pre><span></span>labels_frame = pandas.DataFrame({"label": labels})
counts = labels_frame.label.value_counts().reset_index().rename(
    columns={"index": "Category", "label": "Articles"})
plot = counts.hvplot.bar("Category", "Articles").opts(
    title="Count of BBC News Articles by Category",
    height=800, width=1000)
Embed(plot=plot, file_name="bbc_category_counts")()
</pre></div>
<object data="/posts/keras/bbc-news-classification/bbc_category_counts.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<p>It looks like the categories are somewhat unevenly distributed. Now to normalize the tokens.</p>
<div class="highlight">
<pre><span></span>with TIMER:
    cleaned = [[token.lemma_ for token in text if not any((token.is_stop, token.is_space, token.is_punct))]
               for text in texts]
</pre></div>
<pre class="example">
2019-09-08 13:33:40,257 graeae.timers.timer start: Started: 2019-09-08 13:33:40.257908
I0908 13:33:40.257930 139839933974336 timer.py:70] Started: 2019-09-08 13:33:40.257908
2019-09-08 13:33:40,810 graeae.timers.timer end: Ended: 2019-09-08 13:33:40.810135
I0908 13:33:40.810176 139839933974336 timer.py:77] Ended: 2019-09-08 13:33:40.810135
2019-09-08 13:33:40,811 graeae.timers.timer end: Elapsed: 0:00:00.552227
I0908 13:33:40.811067 139839933974336 timer.py:78] Elapsed: 0:00:00.552227

</pre></div>
</div>
<div class="outline-3" id="outline-container-org1abc976">
<h3 id="org1abc976">The Tokenizers</h3>
<div class="outline-text-3" id="text-org1abc976">
<p>Even though I've already tokenized the texts, we need to eventually one-hot-encode them so I'll use the <a href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/text/Tokenizer">tensorflow keras Tokenizer</a>.</p>
<p><b>Note:</b> The labels tokenizer doesn't get the out-of-vocabulary token, only the text-tokenizer does.</p>
<div class="highlight">
<pre><span></span>tokenizer = Tokenizer(num_words=1000, oov_token="&lt;OOV&gt;")
labels_tokenizer = Tokenizer()
labels_tokenizer.fit_on_texts(labels)
</pre></div>
<p>The <code>num_words</code> is the total amount of words that will be kept in the word index - I don't know why a thousand, I just found that in the "answer" notebook. The <code>oov_token</code> is what's used when a word is encountered outside of the words we're building into our word-index (<i>Out Of Vocabulary</i>). The next step is to create the word-index by fitting the tokenizer to the text.</p>
<div class="highlight">
<pre><span></span>with TIMER:
    tokenizer.fit_on_texts(cleaned)
</pre></div>
<pre class="example">
2019-09-08 14:59:30,671 graeae.timers.timer start: Started: 2019-09-08 14:59:30.671536
I0908 14:59:30.671563 139839933974336 timer.py:70] Started: 2019-09-08 14:59:30.671536
2019-09-08 14:59:30,862 graeae.timers.timer end: Ended: 2019-09-08 14:59:30.862483
I0908 14:59:30.862523 139839933974336 timer.py:77] Ended: 2019-09-08 14:59:30.862483
2019-09-08 14:59:30,863 graeae.timers.timer end: Elapsed: 0:00:00.190947
I0908 14:59:30.863504 139839933974336 timer.py:78] Elapsed: 0:00:00.190947

</pre>
<p>The tokenizer now has a dictionary named <code>word_index</code> that holds the words:index pairs for all the tokens found (it only uses the <code>num_words</code> when you call tokenizer's methods according to <a href="https://stackoverflow.com/questions/46202519/keras-tokenizer-num-words-doesnt-seem-to-work">Stack Overflow</a>).</p>
<div class="highlight">
<pre><span></span>print(f"{len(tokenizer.word_index):,}")
</pre></div>
<pre class="example">
24,339

</pre></div>
</div>
<div class="outline-3" id="outline-container-orgf89f739">
<h3 id="orgf89f739">Making the Sequences</h3>
<div class="outline-text-3" id="text-orgf89f739">
<p>I've trained the Tokenizer so that it has a word-index, but now we have to one hot encode our texts and pad them so they're all the same length.</p>
<div class="highlight">
<pre><span></span>MAX_LENGTH = 120
sequences = tokenizer.texts_to_sequences(cleaned)
padded = pad_sequences(sequences, padding="post", maxlen=MAX_LENGTH)
labels_sequenced = labels_tokenizer.texts_to_sequences(labels)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgbc6c887">
<h3 id="orgbc6c887">Make training and testing sets</h3>
<div class="outline-text-3" id="text-orgbc6c887">
<div class="highlight">
<pre><span></span>TESTING = 0.2
x_train, x_test, y_train, y_test = train_test_split(
    padded, labels_sequenced,
    test_size=TESTING)
x_train, x_validation, y_train, y_validation = train_test_split(
    x_train, y_train, test_size=TESTING)

y_train = numpy.array(y_train)
y_test = numpy.array(y_test)
y_validation = numpy.array(y_validation)

print(f"Training: {x_train.shape}")
print(f"Validation: {x_validation.shape}")
print(f"Testing: {x_test.shape}")
</pre></div>
<pre class="example">
Training: (1424, 120)
Validation: (356, 120)
Testing: (445, 120)

</pre>
<p><b>Note:</b> I originally forgot to pass the <code>TESTING</code> variable with the keyword <code>test_size</code> and got an error that I couldn't use a Singleton array - don't forget the keywords when you pass in anything other than the data to <code>train_test_split</code>.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgcd744cd">
<h3 id="orgcd744cd">The Model</h3>
<div class="outline-text-3" id="text-orgcd744cd">
<div class="highlight">
<pre><span></span>vocabulary_size = 1000
embedding_dimension = 16
max_length=120

model = tensorflow.keras.Sequential([
    layers.Embedding(vocabulary_size, embedding_dimension,
                     input_length=max_length),
    layers.GlobalAveragePooling1D(),
    layers.Dense(24, activation="relu"),
    layers.Dense(6, activation="softmax"),
])
model.compile(loss='sparse_categorical_crossentropy',optimizer='adam',metrics=['accuracy'])
print(model.summary())
</pre></div>
<pre class="example">
Model: "sequential_1"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding_1 (Embedding)      (None, 120, 16)           16000     
_________________________________________________________________
global_average_pooling1d_1 ( (None, 16)                0         
_________________________________________________________________
dense_2 (Dense)              (None, 24)                408       
_________________________________________________________________
dense_3 (Dense)              (None, 6)                 150       
=================================================================
Total params: 16,558
Trainable params: 16,558
Non-trainable params: 0
_________________________________________________________________
None
</pre>
<div class="highlight">
<pre><span></span>model.fit(x_train, y_train, epochs=30,
          validation_data=(x_validation, y_validation), verbose=2)
</pre></div>
<pre class="example">
Train on 1424 samples, validate on 356 samples
Epoch 1/30
1424/1424 - 0s - loss: 1.7623 - accuracy: 0.2879 - val_loss: 1.7257 - val_accuracy: 0.5000
Epoch 2/30
1424/1424 - 0s - loss: 1.6871 - accuracy: 0.5190 - val_loss: 1.6332 - val_accuracy: 0.5281
Epoch 3/30
1424/1424 - 0s - loss: 1.5814 - accuracy: 0.4782 - val_loss: 1.5118 - val_accuracy: 0.4944
Epoch 4/30
1424/1424 - 0s - loss: 1.4417 - accuracy: 0.4677 - val_loss: 1.3543 - val_accuracy: 0.5365
Epoch 5/30
1424/1424 - 0s - loss: 1.2706 - accuracy: 0.5934 - val_loss: 1.1850 - val_accuracy: 0.7022
Epoch 6/30
1424/1424 - 0s - loss: 1.1075 - accuracy: 0.6749 - val_loss: 1.0387 - val_accuracy: 0.8006
Epoch 7/30
1424/1424 - 0s - loss: 0.9606 - accuracy: 0.8483 - val_loss: 0.9081 - val_accuracy: 0.8567
Epoch 8/30
1424/1424 - 0s - loss: 0.8244 - accuracy: 0.8869 - val_loss: 0.7893 - val_accuracy: 0.8848
Epoch 9/30
1424/1424 - 0s - loss: 0.6963 - accuracy: 0.9164 - val_loss: 0.6747 - val_accuracy: 0.8961
Epoch 10/30
1424/1424 - 0s - loss: 0.5815 - accuracy: 0.9228 - val_loss: 0.5767 - val_accuracy: 0.9185
Epoch 11/30
1424/1424 - 0s - loss: 0.4831 - accuracy: 0.9375 - val_loss: 0.4890 - val_accuracy: 0.9270
Epoch 12/30
1424/1424 - 0s - loss: 0.3991 - accuracy: 0.9473 - val_loss: 0.4195 - val_accuracy: 0.9326
Epoch 13/30
1424/1424 - 0s - loss: 0.3321 - accuracy: 0.9508 - val_loss: 0.3669 - val_accuracy: 0.9438
Epoch 14/30
1424/1424 - 0s - loss: 0.2800 - accuracy: 0.9572 - val_loss: 0.3268 - val_accuracy: 0.9494
Epoch 15/30
1424/1424 - 0s - loss: 0.2385 - accuracy: 0.9656 - val_loss: 0.2936 - val_accuracy: 0.9438
Epoch 16/30
1424/1424 - 0s - loss: 0.2053 - accuracy: 0.9740 - val_loss: 0.2693 - val_accuracy: 0.9466
Epoch 17/30
1424/1424 - 0s - loss: 0.1775 - accuracy: 0.9761 - val_loss: 0.2501 - val_accuracy: 0.9466
Epoch 18/30
1424/1424 - 0s - loss: 0.1557 - accuracy: 0.9789 - val_loss: 0.2332 - val_accuracy: 0.9494
Epoch 19/30
1424/1424 - 0s - loss: 0.1362 - accuracy: 0.9831 - val_loss: 0.2189 - val_accuracy: 0.9522
Epoch 20/30
1424/1424 - 0s - loss: 0.1209 - accuracy: 0.9853 - val_loss: 0.2082 - val_accuracy: 0.9551
Epoch 21/30
1424/1424 - 0s - loss: 0.1070 - accuracy: 0.9860 - val_loss: 0.1979 - val_accuracy: 0.9579
Epoch 22/30
1424/1424 - 0s - loss: 0.0952 - accuracy: 0.9888 - val_loss: 0.1897 - val_accuracy: 0.9551
Epoch 23/30
1424/1424 - 0s - loss: 0.0854 - accuracy: 0.9902 - val_loss: 0.1815 - val_accuracy: 0.9579
Epoch 24/30
1424/1424 - 0s - loss: 0.0765 - accuracy: 0.9916 - val_loss: 0.1761 - val_accuracy: 0.9522
Epoch 25/30
1424/1424 - 0s - loss: 0.0689 - accuracy: 0.9930 - val_loss: 0.1729 - val_accuracy: 0.9579
Epoch 26/30
1424/1424 - 0s - loss: 0.0618 - accuracy: 0.9951 - val_loss: 0.1680 - val_accuracy: 0.9551
Epoch 27/30
1424/1424 - 0s - loss: 0.0559 - accuracy: 0.9958 - val_loss: 0.1633 - val_accuracy: 0.9551
Epoch 28/30
1424/1424 - 0s - loss: 0.0505 - accuracy: 0.9958 - val_loss: 0.1594 - val_accuracy: 0.9579
Epoch 29/30
1424/1424 - 0s - loss: 0.0457 - accuracy: 0.9965 - val_loss: 0.1559 - val_accuracy: 0.9522
Epoch 30/30
1424/1424 - 0s - loss: 0.0416 - accuracy: 0.9972 - val_loss: 0.1544 - val_accuracy: 0.9551
</pre>
<p>It seems to get good suprisingly fast - it might be overfitting toward the end.</p>
<div class="highlight">
<pre><span></span>loss, accuracy =model.evaluate(x_test, y_test, verbose=0)
print(f"Loss: {loss: .2f} Accuracy: {accuracy:.2f}")
</pre></div>
<pre class="example">
Loss:  0.16 Accuracy: 0.95

</pre>
<p>It does pretty well, even on the test set.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgde3f2a1">
<h3 id="orgde3f2a1">Plotting the Performance</h3>
<div class="outline-text-3" id="text-orgde3f2a1">
<div class="highlight">
<pre><span></span>data = pandas.DataFrame(model.history.history)
plot = data.hvplot().opts(title="Training Performance", width=1000, height=800)
Embed(plot=plot, file_name="model_performance")()
</pre></div>
<object data="/posts/keras/bbc-news-classification/model_performance.html" height="800" style="width:100%" type="text/html">
<p>Figure Missing</p>
</object>
<p>Unlike with the image classifications, the validation performance never quite matches the training performance (although it's quite good), probably because we aren't doing any kind of augmentation the way you tend to do with images.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org8386b26">
<h2 id="org8386b26">End</h2>
<div class="outline-text-2" id="text-org8386b26">
<p>Okay, so we seem to have a decent model, but is that really the end-game? No, we want to be able to predict what classification a new input should get.</p>
<div class="highlight">
<pre><span></span>index_to_label = {value:key for (key, value) in labels_tokenizer.word_index.items()}

def category(text: str) -&gt; None:
    """Categorizes the text

    Args:
     text: text to categorize
    """
    text = tokenizer.texts_to_sequences([text])
    predictions = model.predict(pad_sequences(text, maxlen=MAX_LENGTH))
    print(f"Predicted Category: {index_to_label[predictions.argmax()]}")
    return
</pre></div>
<div class="highlight">
<pre><span></span>text = "crickets are nutritious and delicious but make for such a silly game"
category(text)
</pre></div>
<pre class="example">
Predicted Category: sport

</pre>
<div class="highlight">
<pre><span></span>text = "i like butts that are big and round, something something like a xxx throw down, and so does the house of parliament"
category(text)
</pre></div>
<pre class="example">
Predicted Category: sport

</pre>
<p>It kind of looks like it's biased toward sports.</p>
<div class="highlight">
<pre><span></span>text = "tv future hand viewer home theatre"
category(text)
</pre></div>
<pre class="example">
Predicted Category: sport

</pre>
<p>Something isn't right here.</p>
</div>
</div>
</div>
</article>
</div>
<ul class="pager postindexpager clearfix">
<li class="next"><a href="/index-9.html" rel="next">Older posts</a></li>
</ul>
<!--End of body content-->
<footer id="footer">Contents © 2020 <a href="mailto:necromuralist@protonmail.com">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a></footer>
</div>
</div>
<script src="/assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
</script> 
</body>
</html>
