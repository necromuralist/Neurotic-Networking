<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Neurotic Networking (Posts about max pooling)</title><link>https://necromuralist.github.io/Neurotic-Networking/</link><description></description><atom:link href="https://necromuralist.github.io/Neurotic-Networking/categories/max-pooling.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2023 &lt;a href="mailto:cloisteredmonkey.jmark@slmail.me"&gt;Cloistered Monkey&lt;/a&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by/4.0/"&gt;&lt;img id="license-image" alt="Creative Commons License" style="border-width:0" src="https://licensebuttons.net/l/by/4.0/80x15.png" /&gt;&lt;/a&gt;This work is licensed under a &lt;a rel="license" href="http://creativecommons.org/licenses/by/4.0/"&gt;Creative Commons Attribution 4.0 International License&lt;/a&gt;.</copyright><lastBuildDate>Mon, 15 May 2023 06:55:01 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Visualizing Max Pooling</title><link>https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents" role="doc-toc"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents" role="doc-toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/#org9e8607f"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/#orgfbc56a0"&gt;Set Up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/#org79be0f2"&gt;Define and visualize the filters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/#org2b7bb11"&gt;Define convolutional and pooling layers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/#orgbe3f7f2"&gt;Visualize the output of each filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/#org73ba87f"&gt;ReLu activation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/#org1d7bd60"&gt;Visualize the output of the pooling layer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9e8607f" class="outline-2"&gt;
&lt;h2 id="org9e8607f"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9e8607f"&gt;
&lt;p&gt;
This is from &lt;a href="https://github.com/udacity/deep-learning-v2-pytorch.git"&gt;Udacity's Deep Learning Repository&lt;/a&gt; which supports their Deep Learning Nanodegree.
&lt;/p&gt;

&lt;p&gt;
In this notebook, we will visualize the output of a maxpooling layer in a CNN. 
&lt;/p&gt;

&lt;p&gt;
A convolutional layer + activation function, followed by a pooling layer, and a linear layer (to create a desired output size) make up the basic layers of a CNN.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfbc56a0" class="outline-2"&gt;
&lt;h2 id="orgfbc56a0"&gt;Set Up&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfbc56a0"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb568348" class="outline-3"&gt;
&lt;h3 id="orgb568348"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb568348"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org931d53c" class="outline-4"&gt;
&lt;h4 id="org931d53c"&gt;PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org931d53c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from dotenv import load_dotenv
import cv2
import matplotlib.pyplot as pyplot
import numpy
import seaborn
import torch
import torch.nn as nn
import torch.nn.functional as F
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb2e1d48" class="outline-4"&gt;
&lt;h4 id="orgb2e1d48"&gt;This Project&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb2e1d48"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from neurotic.tangles.data_paths import DataPathTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4ade976" class="outline-3"&gt;
&lt;h3 id="org4ade976"&gt;Plotting&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4ade976"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_ipython().run_line_magic('matplotlib', 'inline')
seaborn.set(style="whitegrid",
	    rc={"axes.grid": False,
		"font.family": ["sans-serif"],
		"font.sans-serif": ["Latin Modern Sans", "Lato"],
		"figure.figsize": (14, 12)},
	    font_scale=3)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6f55afc" class="outline-3"&gt;
&lt;h3 id="org6f55afc"&gt;Load the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6f55afc"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;load_dotenv()
path = DataPathTwo("rodin.jpg", "CNN")
print(path.from_folder)
assert path.from_folder.is_file()
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/brunhilde/datasets/cnn/rodin.jpg
&lt;/pre&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bgr_img = cv2.imread(str(path.from_folder))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb28245f" class="outline-4"&gt;
&lt;h4 id="orgb28245f"&gt;Convert To Grayscale&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb28245f"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2GRAY)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org7685f2a" class="outline-4"&gt;
&lt;h4 id="org7685f2a"&gt;Normalize: Rescale Entries To Lie In [0,1]&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7685f2a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img = gray_img.astype("float32")/255
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;image = pyplot.imshow(gray_img, cmap='gray')
&lt;/pre&gt;&lt;/div&gt;


&lt;div id="org31f2fb8" class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/gray_image.png" alt="gray_image.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org79be0f2" class="outline-2"&gt;
&lt;h2 id="org79be0f2"&gt;Define and visualize the filters&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org79be0f2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;filter_vals = numpy.array([[-1, -1, -1],
			   [-1, 8, -1],
			   [-1, -1, -1]])
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print('Filter shape: ', filter_vals.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Filter shape:  (3, 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf7bd0b6" class="outline-3"&gt;
&lt;h3 id="orgf7bd0b6"&gt;Defining four different filters,&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf7bd0b6"&gt;
&lt;p&gt;
All of these are linear combinations of the &lt;code&gt;filter_vals&lt;/code&gt; defined above
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;filter_1 = filter_vals
filter_2 = -filter_1
filter_3 = filter_1.T
filter_4 = -filter_3
filters = numpy.array([filter_1, filter_2, filter_3, filter_4])
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print('Filter 1: \n', filter_4)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Filter 1: 
 [[ 1  1  1]
 [ 1 -8  1]
 [ 1  1  1]]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2b7bb11" class="outline-2"&gt;
&lt;h2 id="org2b7bb11"&gt;Define convolutional and pooling layers&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org2b7bb11"&gt;
&lt;p&gt;
You've seen how to define a convolutional layer, next is a &lt;b&gt;Pooling Layer&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
In the next cell, we initialize a convolutional layer so that it contains all the created filters. Then add a maxpooling layer, &lt;a href="http://pytorch.org/docs/stable/_modules/torch/nn/modules/pooling.html"&gt;documented here&lt;/a&gt;, with a kernel size of (2x2) so you can see that the image resolution has been reduced after this step.
&lt;/p&gt;

&lt;p&gt;
A maxpooling layer reduces the x-y size of an input and only keeps the most &lt;b&gt;active&lt;/b&gt; pixel values. Below is an example of a 2x2 pooling kernel, with a stride of 2, appied to a small patch of grayscale pixel values; reducing the x-y size of the patch by a factor of 2. Only the maximum pixel values in 2x2 remain in the new, pooled output.
&lt;/p&gt;


&lt;p&gt;
Define a neural network with a convolutional layer with four filters &lt;i&gt;and&lt;/i&gt; a pooling layer of size (2, 2).
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6e8bb83" class="outline-3"&gt;
&lt;h3 id="org6e8bb83"&gt;The Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6e8bb83"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class Net(nn.Module):
    """A convolutional neural network to process 4 filters

    Args:
     weight: matrix of filters
    """
    def __init__(self, weight: numpy.ndarray) -&amp;gt; None:
	super(Net, self).__init__()
	# initializes the weights of the convolutional layer to be the weights of the 4 defined filters
	k_height, k_width = weight.shape[2:]
	# assumes there are 4 grayscale filters
	self.conv = nn.Conv2d(1, 4, kernel_size=(k_height, k_width), bias=False)
	self.conv.weight = torch.nn.Parameter(weight)
	# define a pooling layer
	self.pool = nn.MaxPool2d(2, 2)
	return

    def forward(self, x: torch.Tensor):
	"""calculates the output of a convolutional layer

	Args:
	 x: image to process

	Returns:
	 layers: convolutional, activated, and pooled layers
	"""
	conv_x = self.conv(x)
	activated_x = F.relu(conv_x)

	# applies pooling layer
	pooled_x = self.pool(activated_x)

	# returns all layers
	return conv_x, activated_x, pooled_x
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf8d4953" class="outline-3"&gt;
&lt;h3 id="orgf8d4953"&gt;instantiate the model and set the weights&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf8d4953"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;weight = torch.from_numpy(filters).unsqueeze(1).type(torch.FloatTensor)
model = Net(weight)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(model)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Net(
  (conv): Conv2d(1, 4, kernel_size=(3, 3), stride=(1, 1), bias=False)
  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbe3f7f2" class="outline-2"&gt;
&lt;h2 id="orgbe3f7f2"&gt;Visualize the output of each filter&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbe3f7f2"&gt;
&lt;p&gt;
First, we'll define a helper function, &lt;code&gt;viz_layer&lt;/code&gt; that takes in a specific layer and number of filters (optional argument), and displays the output of that layer once an image has been passed through.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def viz_layer(layer, n_filters= 4):
    fig = pyplot.figure(figsize=(20, 20))

    for i in range(n_filters):
	ax = fig.add_subplot(1, n_filters, i+1)
	# grab layer outputs
	ax.imshow(numpy.squeeze(layer[0,i].data.numpy()), cmap='gray')
	ax.set_title('Output %s' % str(i+1))
    return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Let's look at the output of a convolutional layer after a ReLu activation function is applied.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org73ba87f" class="outline-2"&gt;
&lt;h2 id="org73ba87f"&gt;ReLu activation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org73ba87f"&gt;
&lt;p&gt;
A ReLu function turns all negative pixel values in 0's (black). See the equation pictured below for input pixel values, &lt;code&gt;x&lt;/code&gt;. 
&lt;/p&gt;


&lt;div id="org995d121" class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/gray_image.png" alt="gray_image.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2848a3c" class="outline-3"&gt;
&lt;h3 id="org2848a3c"&gt;Visualize All the Filters&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2848a3c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fig = pyplot.figure(figsize=(12, 6))
fig.subplots_adjust(left=0, right=1.5, bottom=0.8, top=1, hspace=0.05, wspace=0.05)
for i in range(4):
    ax = fig.add_subplot(1, 4, i+1, xticks=[], yticks=[])
    ax.imshow(filters[i], cmap='gray')
    ax.set_title('Filter %s' % str(i+1))
&lt;/pre&gt;&lt;/div&gt;


&lt;div id="orgc12bbed" class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/filters.png" alt="filters.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org17dfba6" class="outline-4"&gt;
&lt;h4 id="org17dfba6"&gt;convert the image into an input Tensor&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org17dfba6"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img_tensor = torch.from_numpy(gray_img).unsqueeze(0).unsqueeze(1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orga5e451e" class="outline-4"&gt;
&lt;h4 id="orga5e451e"&gt;get all the layers&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orga5e451e"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;conv_layer, activated_layer, pooled_layer = model(gray_img_tensor)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
visualize the output of the activated conv layer
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;viz_layer(activated_layer)
&lt;/pre&gt;&lt;/div&gt;



&lt;div id="org300f407" class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/activated_layer.png" alt="activated_layer.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1d7bd60" class="outline-2"&gt;
&lt;h2 id="org1d7bd60"&gt;Visualize the output of the pooling layer&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1d7bd60"&gt;
&lt;p&gt;
Then, take a look at the output of a pooling layer. The pooling layer takes as input the feature maps pictured above and reduces the dimensionality of those maps, by some pooling factor, by constructing a new, smaller image of only the maximum (brightest) values in a given kernel area.
&lt;/p&gt;

&lt;p&gt;
Take a look at the values on the x, y axes to see how the image has changed size.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;viz_layer(pooled_layer)
&lt;/pre&gt;&lt;/div&gt;


&lt;div id="org53db302" class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/pooled_layer.png" alt="pooled_layer.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><category>max pooling</category><category>visualization</category><guid>https://necromuralist.github.io/Neurotic-Networking/posts/nano/cnn/visualizing-max-pooling/</guid><pubDate>Mon, 03 Dec 2018 15:25:07 GMT</pubDate></item></channel></rss>